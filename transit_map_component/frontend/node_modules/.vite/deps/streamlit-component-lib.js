import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics2;
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/streamlit-component-lib/node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/streamlit-component-lib/node_modules/react/cjs/react.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var _assign = require_object_assign();
        var checkPropTypes = require_checkPropTypes();
        var ReactVersion = "16.14.0";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          suspense: null
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
        function describeComponentFrame(name, source, ownerName) {
          var sourceInfo = "";
          if (source) {
            var path = source.fileName;
            var fileName = path.replace(BEFORE_SLASH_RE, "");
            {
              if (/^index\./.test(fileName)) {
                var match = path.match(BEFORE_SLASH_RE);
                if (match) {
                  var pathBeforeSlash = match[1];
                  if (pathBeforeSlash) {
                    var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
                    fileName = folderName + "/" + fileName;
                  }
                }
              }
            }
            sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
          } else if (ownerName) {
            sourceInfo = " (created by " + ownerName + ")";
          }
          return "\n    in " + (name || "Unknown") + sourceInfo;
        }
        var Resolved = 1;
        function refineResolvedLazyComponent(lazyComponent) {
          return lazyComponent._status === Resolved ? lazyComponent._result : null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                return "Context.Consumer";
              case REACT_PROVIDER_TYPE:
                return "Context.Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type.render);
              case REACT_LAZY_TYPE: {
                var thenable = type;
                var resolvedThenable = refineResolvedLazyComponent(thenable);
                if (resolvedThenable) {
                  return getComponentName(resolvedThenable);
                }
                break;
              }
            }
          }
          return null;
        }
        var ReactDebugCurrentFrame = {};
        var currentlyValidatingElement = null;
        function setCurrentlyValidatingElement(element) {
          {
            currentlyValidatingElement = element;
          }
        }
        {
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentlyValidatingElement) {
              var name = getComponentName(currentlyValidatingElement.type);
              var owner = currentlyValidatingElement._owner;
              stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          // Used by renderers to avoid bundling object-assign twice in UMD bundles:
          assign: _assign
        };
        {
          _assign(ReactSharedInternals, {
            // These should not be included in production.
            ReactDebugCurrentFrame,
            // Shim for React DOM 16.0.0 which still destructured (but not used) this.
            // TODO: remove in React 17.0.
            ReactComponentTreeHook: {}
          });
        }
        function warn(format) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
        function error(format) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
        function printWarning(level, format, args) {
          {
            var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === "string" && args[args.length - 1].indexOf("\n    in") === 0;
            if (!hasExistingStack) {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
            try {
              var argIndex = 0;
              var message = "Warning: " + format.replace(/%s/g, function() {
                return args[argIndex++];
              });
              throw new Error(message);
            } catch (x) {
            }
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            self = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = ("" + key).replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return ("" + text).replace(userProvidedKeyEscapeRegex, "$&/");
        }
        var POOL_SIZE = 10;
        var traverseContextPool = [];
        function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
          if (traverseContextPool.length) {
            var traverseContext = traverseContextPool.pop();
            traverseContext.result = mapResult;
            traverseContext.keyPrefix = keyPrefix;
            traverseContext.func = mapFunction;
            traverseContext.context = mapContext;
            traverseContext.count = 0;
            return traverseContext;
          } else {
            return {
              result: mapResult,
              keyPrefix,
              func: mapFunction,
              context: mapContext,
              count: 0
            };
          }
        }
        function releaseTraverseContext(traverseContext) {
          traverseContext.result = null;
          traverseContext.keyPrefix = null;
          traverseContext.func = null;
          traverseContext.context = null;
          traverseContext.count = 0;
          if (traverseContextPool.length < POOL_SIZE) {
            traverseContextPool.push(traverseContext);
          }
        }
        function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            callback(
              traverseContext,
              children,
              // If it's the only child, treat the name as if it was wrapped in an array
              // so that it's consistent if the number of children grows.
              nameSoFar === "" ? SEPARATOR + getComponentKey(children, 0) : nameSoFar
            );
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getComponentKey(child, i);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              {
                if (iteratorFn === children.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is deprecated and will be removed in a future major release. Consider converting children to an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(children);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getComponentKey(child, ii++);
                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
              }
            } else if (type === "object") {
              var addendum = "";
              {
                addendum = " If you meant to render a collection of children, use an array instead." + ReactDebugCurrentFrame.getStackAddendum();
              }
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + ")." + addendum);
                }
              }
            }
          }
          return subtreeCount;
        }
        function traverseAllChildren(children, callback, traverseContext) {
          if (children == null) {
            return 0;
          }
          return traverseAllChildrenImpl(children, "", callback, traverseContext);
        }
        function getComponentKey(component, index) {
          if (typeof component === "object" && component !== null && component.key != null) {
            return escape(component.key);
          }
          return index.toString(36);
        }
        function forEachSingleChild(bookKeeping, child, name) {
          var func = bookKeeping.func, context = bookKeeping.context;
          func.call(context, child, bookKeeping.count++);
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          if (children == null) {
            return children;
          }
          var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
          traverseAllChildren(children, forEachSingleChild, traverseContext);
          releaseTraverseContext(traverseContext);
        }
        function mapSingleChildIntoContext(bookKeeping, child, childKey) {
          var result = bookKeeping.result, keyPrefix = bookKeeping.keyPrefix, func = bookKeeping.func, context = bookKeeping.context;
          var mappedChild = func.call(context, child, bookKeeping.count++);
          if (Array.isArray(mappedChild)) {
            mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function(c) {
              return c;
            });
          } else if (mappedChild != null) {
            if (isValidElement(mappedChild)) {
              mappedChild = cloneAndReplaceKey(
                mappedChild,
                // Keep both the (mapped) and old keys if they differ, just as
                // traverseAllChildren used to do for objects as children
                keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + "/" : "") + childKey
              );
            }
            result.push(mappedChild);
          }
        }
        function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
          var escapedPrefix = "";
          if (prefix != null) {
            escapedPrefix = escapeUserProvidedKey(prefix) + "/";
          }
          var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
          traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
          releaseTraverseContext(traverseContext);
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          mapIntoWithKeyPrefixInternal(children, result, null, func, context);
          return result;
        }
        function countChildren(children) {
          return traverseAllChildren(children, function() {
            return null;
          }, null);
        }
        function toArray(children) {
          var result = [];
          mapIntoWithKeyPrefixInternal(children, result, null, function(child) {
            return child;
          });
          return result;
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        function lazy(ctor) {
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _ctor: ctor,
            // React uses these fields to store the result.
            _status: -1,
            _result: null
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          return {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
        }
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          return {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://fb.me/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement(element);
          {
            error('Each child in a list should have a unique "key" prop.%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
          }
          setCurrentlyValidatingElement(null);
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var name = getComponentName(type);
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              setCurrentlyValidatingElement(element);
              checkPropTypes(propTypes, element.props, "prop", name, ReactDebugCurrentFrame.getStackAddendum);
              setCurrentlyValidatingElement(null);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            setCurrentlyValidatingElement(fragment);
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                break;
              }
            }
            if (fragment.ref !== null) {
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
            }
            setCurrentlyValidatingElement(null);
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (Array.isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            var testMap = /* @__PURE__ */ new Map([[frozenObject, null]]);
            var testSet = /* @__PURE__ */ new Set([frozenObject]);
            testMap.set(0, 0);
            testSet.add(0);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useEffect = useEffect;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/streamlit-component-lib/node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/streamlit-component-lib/node_modules/react/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/flatbuffers/js/flatbuffers.mjs
var flatbuffers_exports = {};
__export(flatbuffers_exports, {
  flatbuffers: () => flatbuffers
});
var flatbuffers;
var init_flatbuffers = __esm({
  "node_modules/flatbuffers/js/flatbuffers.mjs"() {
    flatbuffers = {};
    flatbuffers.Offset;
    flatbuffers.Table;
    flatbuffers.SIZEOF_SHORT = 2;
    flatbuffers.SIZEOF_INT = 4;
    flatbuffers.FILE_IDENTIFIER_LENGTH = 4;
    flatbuffers.Encoding = {
      UTF8_BYTES: 1,
      UTF16_STRING: 2
    };
    flatbuffers.int32 = new Int32Array(2);
    flatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);
    flatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);
    flatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
    flatbuffers.Long = function(low, high) {
      this.low = low | 0;
      this.high = high | 0;
    };
    flatbuffers.Long.create = function(low, high) {
      return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);
    };
    flatbuffers.Long.prototype.toFloat64 = function() {
      return (this.low >>> 0) + this.high * 4294967296;
    };
    flatbuffers.Long.prototype.equals = function(other) {
      return this.low == other.low && this.high == other.high;
    };
    flatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);
    flatbuffers.Builder = function(opt_initial_size) {
      if (!opt_initial_size) {
        var initial_size = 1024;
      } else {
        var initial_size = opt_initial_size;
      }
      this.bb = flatbuffers.ByteBuffer.allocate(initial_size);
      this.space = initial_size;
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
    };
    flatbuffers.Builder.prototype.clear = function() {
      this.bb.clear();
      this.space = this.bb.capacity();
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
    };
    flatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {
      this.force_defaults = forceDefaults;
    };
    flatbuffers.Builder.prototype.dataBuffer = function() {
      return this.bb;
    };
    flatbuffers.Builder.prototype.asUint8Array = function() {
      return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    };
    flatbuffers.Builder.prototype.prep = function(size, additional_bytes) {
      if (size > this.minalign) {
        this.minalign = size;
      }
      var align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
      while (this.space < align_size + size + additional_bytes) {
        var old_buf_size = this.bb.capacity();
        this.bb = flatbuffers.Builder.growByteBuffer(this.bb);
        this.space += this.bb.capacity() - old_buf_size;
      }
      this.pad(align_size);
    };
    flatbuffers.Builder.prototype.pad = function(byte_size) {
      for (var i = 0; i < byte_size; i++) {
        this.bb.writeInt8(--this.space, 0);
      }
    };
    flatbuffers.Builder.prototype.writeInt8 = function(value) {
      this.bb.writeInt8(this.space -= 1, value);
    };
    flatbuffers.Builder.prototype.writeInt16 = function(value) {
      this.bb.writeInt16(this.space -= 2, value);
    };
    flatbuffers.Builder.prototype.writeInt32 = function(value) {
      this.bb.writeInt32(this.space -= 4, value);
    };
    flatbuffers.Builder.prototype.writeInt64 = function(value) {
      this.bb.writeInt64(this.space -= 8, value);
    };
    flatbuffers.Builder.prototype.writeFloat32 = function(value) {
      this.bb.writeFloat32(this.space -= 4, value);
    };
    flatbuffers.Builder.prototype.writeFloat64 = function(value) {
      this.bb.writeFloat64(this.space -= 8, value);
    };
    flatbuffers.Builder.prototype.addInt8 = function(value) {
      this.prep(1, 0);
      this.writeInt8(value);
    };
    flatbuffers.Builder.prototype.addInt16 = function(value) {
      this.prep(2, 0);
      this.writeInt16(value);
    };
    flatbuffers.Builder.prototype.addInt32 = function(value) {
      this.prep(4, 0);
      this.writeInt32(value);
    };
    flatbuffers.Builder.prototype.addInt64 = function(value) {
      this.prep(8, 0);
      this.writeInt64(value);
    };
    flatbuffers.Builder.prototype.addFloat32 = function(value) {
      this.prep(4, 0);
      this.writeFloat32(value);
    };
    flatbuffers.Builder.prototype.addFloat64 = function(value) {
      this.prep(8, 0);
      this.writeFloat64(value);
    };
    flatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt8(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt16(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt32(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {
      if (this.force_defaults || !value.equals(defaultValue)) {
        this.addInt64(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat32(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat64(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addOffset(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {
      if (value != defaultValue) {
        this.nested(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.nested = function(obj) {
      if (obj != this.offset()) {
        throw new Error("FlatBuffers: struct must be serialized inline.");
      }
    };
    flatbuffers.Builder.prototype.notNested = function() {
      if (this.isNested) {
        throw new Error("FlatBuffers: object serialization must not be nested.");
      }
    };
    flatbuffers.Builder.prototype.slot = function(voffset) {
      this.vtable[voffset] = this.offset();
    };
    flatbuffers.Builder.prototype.offset = function() {
      return this.bb.capacity() - this.space;
    };
    flatbuffers.Builder.growByteBuffer = function(bb) {
      var old_buf_size = bb.capacity();
      if (old_buf_size & 3221225472) {
        throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
      }
      var new_buf_size = old_buf_size << 1;
      var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);
      nbb.setPosition(new_buf_size - old_buf_size);
      nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
      return nbb;
    };
    flatbuffers.Builder.prototype.addOffset = function(offset) {
      this.prep(flatbuffers.SIZEOF_INT, 0);
      this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);
    };
    flatbuffers.Builder.prototype.startObject = function(numfields) {
      this.notNested();
      if (this.vtable == null) {
        this.vtable = [];
      }
      this.vtable_in_use = numfields;
      for (var i = 0; i < numfields; i++) {
        this.vtable[i] = 0;
      }
      this.isNested = true;
      this.object_start = this.offset();
    };
    flatbuffers.Builder.prototype.endObject = function() {
      if (this.vtable == null || !this.isNested) {
        throw new Error("FlatBuffers: endObject called without startObject");
      }
      this.addInt32(0);
      var vtableloc = this.offset();
      var i = this.vtable_in_use - 1;
      for (; i >= 0 && this.vtable[i] == 0; i--) {
      }
      var trimmed_size = i + 1;
      for (; i >= 0; i--) {
        this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
      }
      var standard_fields = 2;
      this.addInt16(vtableloc - this.object_start);
      var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;
      this.addInt16(len);
      var existing_vtable = 0;
      var vt1 = this.space;
      outer_loop:
        for (i = 0; i < this.vtables.length; i++) {
          var vt2 = this.bb.capacity() - this.vtables[i];
          if (len == this.bb.readInt16(vt2)) {
            for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {
              if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                continue outer_loop;
              }
            }
            existing_vtable = this.vtables[i];
            break;
          }
        }
      if (existing_vtable) {
        this.space = this.bb.capacity() - vtableloc;
        this.bb.writeInt32(this.space, existing_vtable - vtableloc);
      } else {
        this.vtables.push(this.offset());
        this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
      }
      this.isNested = false;
      return vtableloc;
    };
    flatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier) {
      if (opt_file_identifier) {
        var file_identifier = opt_file_identifier;
        this.prep(this.minalign, flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH);
        if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
          throw new Error("FlatBuffers: file identifier must be length " + flatbuffers.FILE_IDENTIFIER_LENGTH);
        }
        for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
          this.writeInt8(file_identifier.charCodeAt(i));
        }
      }
      this.prep(this.minalign, flatbuffers.SIZEOF_INT);
      this.addOffset(root_table);
      this.bb.setPosition(this.space);
    };
    flatbuffers.Builder.prototype.requiredField = function(table, field) {
      var table_start = this.bb.capacity() - table;
      var vtable_start = table_start - this.bb.readInt32(table_start);
      var ok = this.bb.readInt16(vtable_start + field) != 0;
      if (!ok) {
        throw new Error("FlatBuffers: field " + field + " must be set");
      }
    };
    flatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {
      this.notNested();
      this.vector_num_elems = num_elems;
      this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);
      this.prep(alignment, elem_size * num_elems);
    };
    flatbuffers.Builder.prototype.endVector = function() {
      this.writeInt32(this.vector_num_elems);
      return this.offset();
    };
    flatbuffers.Builder.prototype.createString = function(s) {
      if (s instanceof Uint8Array) {
        var utf8 = s;
      } else {
        var utf8 = [];
        var i = 0;
        while (i < s.length) {
          var codePoint;
          var a = s.charCodeAt(i++);
          if (a < 55296 || a >= 56320) {
            codePoint = a;
          } else {
            var b = s.charCodeAt(i++);
            codePoint = (a << 10) + b + (65536 - (55296 << 10) - 56320);
          }
          if (codePoint < 128) {
            utf8.push(codePoint);
          } else {
            if (codePoint < 2048) {
              utf8.push(codePoint >> 6 & 31 | 192);
            } else {
              if (codePoint < 65536) {
                utf8.push(codePoint >> 12 & 15 | 224);
              } else {
                utf8.push(
                  codePoint >> 18 & 7 | 240,
                  codePoint >> 12 & 63 | 128
                );
              }
              utf8.push(codePoint >> 6 & 63 | 128);
            }
            utf8.push(codePoint & 63 | 128);
          }
        }
      }
      this.addInt8(0);
      this.startVector(1, utf8.length, 1);
      this.bb.setPosition(this.space -= utf8.length);
      for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
        bytes[offset++] = utf8[i];
      }
      return this.endVector();
    };
    flatbuffers.Builder.prototype.createLong = function(low, high) {
      return flatbuffers.Long.create(low, high);
    };
    flatbuffers.ByteBuffer = function(bytes) {
      this.bytes_ = bytes;
      this.position_ = 0;
    };
    flatbuffers.ByteBuffer.allocate = function(byte_size) {
      return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));
    };
    flatbuffers.ByteBuffer.prototype.clear = function() {
      this.position_ = 0;
    };
    flatbuffers.ByteBuffer.prototype.bytes = function() {
      return this.bytes_;
    };
    flatbuffers.ByteBuffer.prototype.position = function() {
      return this.position_;
    };
    flatbuffers.ByteBuffer.prototype.setPosition = function(position) {
      this.position_ = position;
    };
    flatbuffers.ByteBuffer.prototype.capacity = function() {
      return this.bytes_.length;
    };
    flatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {
      return this.readUint8(offset) << 24 >> 24;
    };
    flatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {
      return this.bytes_[offset];
    };
    flatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {
      return this.readUint16(offset) << 16 >> 16;
    };
    flatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    };
    flatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    };
    flatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {
      return this.readInt32(offset) >>> 0;
    };
    flatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {
      return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));
    };
    flatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {
      return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));
    };
    flatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {
      flatbuffers.int32[0] = this.readInt32(offset);
      return flatbuffers.float32[0];
    };
    flatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {
      flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);
      flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
      return flatbuffers.float64[0];
    };
    flatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {
      this.bytes_[offset] = /** @type {number} */
      value;
    };
    flatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {
      this.bytes_[offset] = value;
    };
    flatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    };
    flatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    };
    flatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    };
    flatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    };
    flatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {
      this.writeInt32(offset, value.low);
      this.writeInt32(offset + 4, value.high);
    };
    flatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {
      this.writeUint32(offset, value.low);
      this.writeUint32(offset + 4, value.high);
    };
    flatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {
      flatbuffers.float32[0] = value;
      this.writeInt32(offset, flatbuffers.int32[0]);
    };
    flatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {
      flatbuffers.float64[0] = value;
      this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);
      this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);
    };
    flatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {
      if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH) {
        throw new Error(
          "FlatBuffers: ByteBuffer is too short to contain an identifier."
        );
      }
      var result = "";
      for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
        result += String.fromCharCode(
          this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)
        );
      }
      return result;
    };
    flatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {
      var vtable = bb_pos - this.readInt32(bb_pos);
      return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    };
    flatbuffers.ByteBuffer.prototype.__union = function(t, offset) {
      t.bb_pos = offset + this.readInt32(offset);
      t.bb = this;
      return t;
    };
    flatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {
      offset += this.readInt32(offset);
      var length = this.readInt32(offset);
      var result = "";
      var i = 0;
      offset += flatbuffers.SIZEOF_INT;
      if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {
        return this.bytes_.subarray(offset, offset + length);
      }
      while (i < length) {
        var codePoint;
        var a = this.readUint8(offset + i++);
        if (a < 192) {
          codePoint = a;
        } else {
          var b = this.readUint8(offset + i++);
          if (a < 224) {
            codePoint = (a & 31) << 6 | b & 63;
          } else {
            var c = this.readUint8(offset + i++);
            if (a < 240) {
              codePoint = (a & 15) << 12 | (b & 63) << 6 | c & 63;
            } else {
              var d = this.readUint8(offset + i++);
              codePoint = (a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63;
            }
          }
        }
        if (codePoint < 65536) {
          result += String.fromCharCode(codePoint);
        } else {
          codePoint -= 65536;
          result += String.fromCharCode(
            (codePoint >> 10) + 55296,
            (codePoint & (1 << 10) - 1) + 56320
          );
        }
      }
      return result;
    };
    flatbuffers.ByteBuffer.prototype.__indirect = function(offset) {
      return offset + this.readInt32(offset);
    };
    flatbuffers.ByteBuffer.prototype.__vector = function(offset) {
      return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT;
    };
    flatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {
      return this.readInt32(offset + this.readInt32(offset));
    };
    flatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {
      if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: file identifier must be length " + flatbuffers.FILE_IDENTIFIER_LENGTH);
      }
      for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
        if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {
          return false;
        }
      }
      return true;
    };
    flatbuffers.ByteBuffer.prototype.createLong = function(low, high) {
      return flatbuffers.Long.create(low, high);
    };
  }
});

// node_modules/text-encoding-utf-8/src/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  TextDecoder: () => TextDecoder2,
  TextEncoder: () => TextEncoder2
});
function inRange(a, min, max) {
  return min <= a && a <= max;
}
function ToDictionary(o) {
  if (o === void 0) return {};
  if (o === Object(o)) return o;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(string) {
  var s = String(string);
  var n = s.length;
  var i = 0;
  var u = [];
  while (i < n) {
    var c = s.charCodeAt(i);
    if (c < 55296 || c > 57343) {
      u.push(c);
    } else if (56320 <= c && c <= 57343) {
      u.push(65533);
    } else if (55296 <= c && c <= 56319) {
      if (i === n - 1) {
        u.push(65533);
      } else {
        var d = string.charCodeAt(i + 1);
        if (56320 <= d && d <= 57343) {
          var a = c & 1023;
          var b = d & 1023;
          u.push(65536 + (a << 10) + b);
          i += 1;
        } else {
          u.push(65533);
        }
      }
    }
    i += 1;
  }
  return u;
}
function codePointsToString(code_points) {
  var s = "";
  for (var i = 0; i < code_points.length; ++i) {
    var cp = code_points[i];
    if (cp <= 65535) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 65536;
      s += String.fromCharCode(
        (cp >> 10) + 55296,
        (cp & 1023) + 56320
      );
    }
  }
  return s;
}
function Stream(tokens) {
  this.tokens = [].slice.call(tokens);
}
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
function Decoder() {
}
function Encoder() {
}
function TextDecoder2(encoding, options) {
  if (!(this instanceof TextDecoder2)) {
    return new TextDecoder2(encoding, options);
  }
  encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._BOMseen = false;
  this._decoder = null;
  this._fatal = Boolean(options["fatal"]);
  this._ignoreBOM = Boolean(options["ignoreBOM"]);
  Object.defineProperty(this, "encoding", { value: "utf-8" });
  Object.defineProperty(this, "fatal", { value: this._fatal });
  Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
function TextEncoder2(encoding, options) {
  if (!(this instanceof TextEncoder2))
    return new TextEncoder2(encoding, options);
  encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._encoder = null;
  this._options = { fatal: Boolean(options["fatal"]) };
  Object.defineProperty(this, "encoding", { value: "utf-8" });
}
function UTF8Decoder(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream)
      return finished;
    if (utf8_bytes_needed === 0) {
      if (inRange(bite, 0, 127)) {
        return bite;
      }
      if (inRange(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 192;
      } else if (inRange(bite, 224, 239)) {
        if (bite === 224)
          utf8_lower_boundary = 160;
        if (bite === 237)
          utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 224;
      } else if (inRange(bite, 240, 244)) {
        if (bite === 240)
          utf8_lower_boundary = 144;
        if (bite === 244)
          utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 240;
      } else {
        return decoderError(fatal);
      }
      utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
      return null;
    }
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream.prepend(bite);
      return decoderError(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_bytes_seen += 1;
    utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (inRange(code_point, 0, 127))
      return code_point;
    var count, offset;
    if (inRange(code_point, 128, 2047)) {
      count = 1;
      offset = 192;
    } else if (inRange(code_point, 2048, 65535)) {
      count = 2;
      offset = 224;
    } else if (inRange(code_point, 65536, 1114111)) {
      count = 3;
      offset = 240;
    }
    var bytes = [(code_point >> 6 * count) + offset];
    while (count > 0) {
      var temp = code_point >> 6 * (count - 1);
      bytes.push(128 | temp & 63);
      count -= 1;
    }
    return bytes;
  };
}
var end_of_stream, finished, DEFAULT_ENCODING;
var init_encoding = __esm({
  "node_modules/text-encoding-utf-8/src/encoding.js"() {
    "use strict";
    end_of_stream = -1;
    Stream.prototype = {
      /**
       * @return {boolean} True if end-of-stream has been hit.
       */
      endOfStream: function() {
        return !this.tokens.length;
      },
      /**
       * When a token is read from a stream, the first token in the
       * stream must be returned and subsequently removed, and
       * end-of-stream must be returned otherwise.
       *
       * @return {number} Get the next token from the stream, or
       * end_of_stream.
       */
      read: function() {
        if (!this.tokens.length)
          return end_of_stream;
        return this.tokens.shift();
      },
      /**
       * When one or more tokens are prepended to a stream, those tokens
       * must be inserted, in given order, before the first token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
       */
      prepend: function(token) {
        if (Array.isArray(token)) {
          var tokens = (
            /**@type {!Array.<number>}*/
            token
          );
          while (tokens.length)
            this.tokens.unshift(tokens.pop());
        } else {
          this.tokens.unshift(token);
        }
      },
      /**
       * When one or more tokens are pushed to a stream, those tokens
       * must be inserted, in given order, after the last token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
       */
      push: function(token) {
        if (Array.isArray(token)) {
          var tokens = (
            /**@type {!Array.<number>}*/
            token
          );
          while (tokens.length)
            this.tokens.push(tokens.shift());
        } else {
          this.tokens.push(token);
        }
      }
    };
    finished = -1;
    Decoder.prototype = {
      /**
       * @param {Stream} stream The stream of bytes being decoded.
       * @param {number} bite The next byte read from the stream.
       * @return {?(number|!Array.<number>)} The next code point(s)
       *     decoded, or null if not enough data exists in the input
       *     stream to decode a complete code point, or |finished|.
       */
      handler: function(stream, bite) {
      }
    };
    Encoder.prototype = {
      /**
       * @param {Stream} stream The stream of code points being encoded.
       * @param {number} code_point Next code point read from the stream.
       * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.
       */
      handler: function(stream, code_point) {
      }
    };
    DEFAULT_ENCODING = "utf-8";
    TextDecoder2.prototype = {
      /**
       * @param {ArrayBufferView=} input The buffer of bytes to decode.
       * @param {Object=} options
       * @return {string} The decoded string.
       */
      decode: function decode(input, options) {
        var bytes;
        if (typeof input === "object" && input instanceof ArrayBuffer) {
          bytes = new Uint8Array(input);
        } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
          bytes = new Uint8Array(
            input.buffer,
            input.byteOffset,
            input.byteLength
          );
        } else {
          bytes = new Uint8Array(0);
        }
        options = ToDictionary(options);
        if (!this._streaming) {
          this._decoder = new UTF8Decoder({ fatal: this._fatal });
          this._BOMseen = false;
        }
        this._streaming = Boolean(options["stream"]);
        var input_stream = new Stream(bytes);
        var code_points = [];
        var result;
        while (!input_stream.endOfStream()) {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (result === null)
            continue;
          if (Array.isArray(result))
            code_points.push.apply(
              code_points,
              /**@type {!Array.<number>}*/
              result
            );
          else
            code_points.push(result);
        }
        if (!this._streaming) {
          do {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(
                code_points,
                /**@type {!Array.<number>}*/
                result
              );
            else
              code_points.push(result);
          } while (!input_stream.endOfStream());
          this._decoder = null;
        }
        if (code_points.length) {
          if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
            if (code_points[0] === 65279) {
              this._BOMseen = true;
              code_points.shift();
            } else {
              this._BOMseen = true;
            }
          }
        }
        return codePointsToString(code_points);
      }
    };
    TextEncoder2.prototype = {
      /**
       * @param {string=} opt_string The string to encode.
       * @param {Object=} options
       * @return {Uint8Array} Encoded bytes, as a Uint8Array.
       */
      encode: function encode(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : "";
        options = ToDictionary(options);
        if (!this._streaming)
          this._encoder = new UTF8Encoder(this._options);
        this._streaming = Boolean(options["stream"]);
        var bytes = [];
        var input_stream = new Stream(stringToCodePoints(opt_string));
        var result;
        while (!input_stream.endOfStream()) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (Array.isArray(result))
            bytes.push.apply(
              bytes,
              /**@type {!Array.<number>}*/
              result
            );
          else
            bytes.push(result);
        }
        if (!this._streaming) {
          while (true) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes.push.apply(
                bytes,
                /**@type {!Array.<number>}*/
                result
              );
            else
              bytes.push(result);
          }
          this._encoder = null;
        }
        return new Uint8Array(bytes);
      }
    };
  }
});

// node_modules/apache-arrow/util/utf8.js
var require_utf8 = __commonJS({
  "node_modules/apache-arrow/util/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    var text_encoding_utf_8_1 = (init_encoding(), __toCommonJS(encoding_exports));
    var _Buffer = typeof Buffer === "function" ? Buffer : null;
    var useNativeEncoders = typeof TextDecoder === "function" && typeof TextEncoder === "function";
    exports.decodeUtf8 = ((TextDecoder3) => {
      if (useNativeEncoders || !_Buffer) {
        const decoder = new TextDecoder3("utf-8");
        return (buffer) => decoder.decode(buffer);
      }
      return (input) => {
        const { buffer, byteOffset, length } = buffer_1.toUint8Array(input);
        return _Buffer.from(buffer, byteOffset, length).toString();
      };
    })(typeof TextDecoder !== "undefined" ? TextDecoder : text_encoding_utf_8_1.TextDecoder);
    exports.encodeUtf8 = ((TextEncoder3) => {
      if (useNativeEncoders || !_Buffer) {
        const encoder = new TextEncoder3();
        return (value) => encoder.encode(value);
      }
      return (input = "") => buffer_1.toUint8Array(_Buffer.from(input, "utf8"));
    })(typeof TextEncoder !== "undefined" ? TextEncoder : text_encoding_utf_8_1.TextEncoder);
  }
});

// node_modules/apache-arrow/io/interfaces.js
var require_interfaces = __commonJS({
  "node_modules/apache-arrow/io/interfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var adapters_1 = require_adapters();
    exports.ITERATOR_DONE = Object.freeze({ done: true, value: void 0 });
    var ArrowJSON = class {
      // @ts-ignore
      constructor(_json) {
        this._json = _json;
      }
      get schema() {
        return this._json["schema"];
      }
      get batches() {
        return this._json["batches"] || [];
      }
      get dictionaries() {
        return this._json["dictionaries"] || [];
      }
    };
    exports.ArrowJSON = ArrowJSON;
    var ReadableInterop = class {
      tee() {
        return this._getDOMStream().tee();
      }
      pipe(writable, options) {
        return this._getNodeStream().pipe(writable, options);
      }
      pipeTo(writable, options) {
        return this._getDOMStream().pipeTo(writable, options);
      }
      pipeThrough(duplex, options) {
        return this._getDOMStream().pipeThrough(duplex, options);
      }
      _getDOMStream() {
        return this._DOMStream || (this._DOMStream = this.toDOMStream());
      }
      _getNodeStream() {
        return this._nodeStream || (this._nodeStream = this.toNodeStream());
      }
    };
    exports.ReadableInterop = ReadableInterop;
    var AsyncQueue = class extends ReadableInterop {
      constructor() {
        super();
        this._values = [];
        this.resolvers = [];
        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
      }
      get closed() {
        return this._closedPromise;
      }
      async cancel(reason) {
        await this.return(reason);
      }
      write(value) {
        if (this._ensureOpen()) {
          this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });
        }
      }
      abort(value) {
        if (this._closedPromiseResolve) {
          this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });
        }
      }
      close() {
        if (this._closedPromiseResolve) {
          const { resolvers } = this;
          while (resolvers.length > 0) {
            resolvers.shift().resolve(exports.ITERATOR_DONE);
          }
          this._closedPromiseResolve();
          this._closedPromiseResolve = void 0;
        }
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      toDOMStream(options) {
        return adapters_1.default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);
      }
      toNodeStream(options) {
        return adapters_1.default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);
      }
      async throw(_) {
        await this.abort(_);
        return exports.ITERATOR_DONE;
      }
      async return(_) {
        await this.close();
        return exports.ITERATOR_DONE;
      }
      async read(size) {
        return (await this.next(size, "read")).value;
      }
      async peek(size) {
        return (await this.next(size, "peek")).value;
      }
      next(..._args) {
        if (this._values.length > 0) {
          return Promise.resolve({ done: false, value: this._values.shift() });
        } else if (this._error) {
          return Promise.reject({ done: true, value: this._error.error });
        } else if (!this._closedPromiseResolve) {
          return Promise.resolve(exports.ITERATOR_DONE);
        } else {
          return new Promise((resolve, reject) => {
            this.resolvers.push({ resolve, reject });
          });
        }
      }
      _ensureOpen() {
        if (this._closedPromiseResolve) {
          return true;
        }
        throw new Error(`${this} is closed`);
      }
    };
    exports.AsyncQueue = AsyncQueue;
  }
});

// node_modules/apache-arrow/util/compat.js
var require_compat = __commonJS({
  "node_modules/apache-arrow/util/compat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var interfaces_1 = require_interfaces();
    var [BigIntCtor, BigIntAvailable] = (() => {
      const BigIntUnavailableError = () => {
        throw new Error("BigInt is not available in this environment");
      };
      function BigIntUnavailable() {
        throw BigIntUnavailableError();
      }
      BigIntUnavailable.asIntN = () => {
        throw BigIntUnavailableError();
      };
      BigIntUnavailable.asUintN = () => {
        throw BigIntUnavailableError();
      };
      return typeof BigInt !== "undefined" ? [BigInt, true] : [BigIntUnavailable, false];
    })();
    exports.BigInt = BigIntCtor;
    exports.BigIntAvailable = BigIntAvailable;
    var [BigInt64ArrayCtor, BigInt64ArrayAvailable] = (() => {
      const BigInt64ArrayUnavailableError = () => {
        throw new Error("BigInt64Array is not available in this environment");
      };
      class BigInt64ArrayUnavailable {
        static get BYTES_PER_ELEMENT() {
          return 8;
        }
        static of() {
          throw BigInt64ArrayUnavailableError();
        }
        static from() {
          throw BigInt64ArrayUnavailableError();
        }
        constructor() {
          throw BigInt64ArrayUnavailableError();
        }
      }
      return typeof BigInt64Array !== "undefined" ? [BigInt64Array, true] : [BigInt64ArrayUnavailable, false];
    })();
    exports.BigInt64Array = BigInt64ArrayCtor;
    exports.BigInt64ArrayAvailable = BigInt64ArrayAvailable;
    var [BigUint64ArrayCtor, BigUint64ArrayAvailable] = (() => {
      const BigUint64ArrayUnavailableError = () => {
        throw new Error("BigUint64Array is not available in this environment");
      };
      class BigUint64ArrayUnavailable {
        static get BYTES_PER_ELEMENT() {
          return 8;
        }
        static of() {
          throw BigUint64ArrayUnavailableError();
        }
        static from() {
          throw BigUint64ArrayUnavailableError();
        }
        constructor() {
          throw BigUint64ArrayUnavailableError();
        }
      }
      return typeof BigUint64Array !== "undefined" ? [BigUint64Array, true] : [BigUint64ArrayUnavailable, false];
    })();
    exports.BigUint64Array = BigUint64ArrayCtor;
    exports.BigUint64ArrayAvailable = BigUint64ArrayAvailable;
    var isNumber = (x) => typeof x === "number";
    var isBoolean = (x) => typeof x === "boolean";
    var isFunction = (x) => typeof x === "function";
    exports.isObject = (x) => x != null && Object(x) === x;
    exports.isPromise = (x) => {
      return exports.isObject(x) && isFunction(x.then);
    };
    exports.isObservable = (x) => {
      return exports.isObject(x) && isFunction(x.subscribe);
    };
    exports.isIterable = (x) => {
      return exports.isObject(x) && isFunction(x[Symbol.iterator]);
    };
    exports.isAsyncIterable = (x) => {
      return exports.isObject(x) && isFunction(x[Symbol.asyncIterator]);
    };
    exports.isArrowJSON = (x) => {
      return exports.isObject(x) && exports.isObject(x["schema"]);
    };
    exports.isArrayLike = (x) => {
      return exports.isObject(x) && isNumber(x["length"]);
    };
    exports.isIteratorResult = (x) => {
      return exports.isObject(x) && "done" in x && "value" in x;
    };
    exports.isUnderlyingSink = (x) => {
      return exports.isObject(x) && isFunction(x["abort"]) && isFunction(x["close"]) && isFunction(x["start"]) && isFunction(x["write"]);
    };
    exports.isFileHandle = (x) => {
      return exports.isObject(x) && isFunction(x["stat"]) && isNumber(x["fd"]);
    };
    exports.isFSReadStream = (x) => {
      return exports.isReadableNodeStream(x) && isNumber(x["bytesRead"]);
    };
    exports.isFetchResponse = (x) => {
      return exports.isObject(x) && exports.isReadableDOMStream(x["body"]);
    };
    exports.isWritableDOMStream = (x) => {
      return exports.isObject(x) && isFunction(x["abort"]) && isFunction(x["getWriter"]) && !(x instanceof interfaces_1.ReadableInterop);
    };
    exports.isReadableDOMStream = (x) => {
      return exports.isObject(x) && isFunction(x["cancel"]) && isFunction(x["getReader"]) && !(x instanceof interfaces_1.ReadableInterop);
    };
    exports.isWritableNodeStream = (x) => {
      return exports.isObject(x) && isFunction(x["end"]) && isFunction(x["write"]) && isBoolean(x["writable"]) && !(x instanceof interfaces_1.ReadableInterop);
    };
    exports.isReadableNodeStream = (x) => {
      return exports.isObject(x) && isFunction(x["read"]) && isFunction(x["pipe"]) && isBoolean(x["readable"]) && !(x instanceof interfaces_1.ReadableInterop);
    };
  }
});

// node_modules/apache-arrow/util/buffer.js
var require_buffer = __commonJS({
  "node_modules/apache-arrow/util/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var flatbuffers_1 = (init_flatbuffers(), __toCommonJS(flatbuffers_exports));
    var utf8_1 = require_utf8();
    var ByteBuffer = flatbuffers_1.flatbuffers.ByteBuffer;
    var compat_1 = require_compat();
    var SharedArrayBuf = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : ArrayBuffer;
    function collapseContiguousByteRanges(chunks) {
      let result = chunks[0] ? [chunks[0]] : [];
      let xOffset, yOffset, xLen, yLen;
      for (let x, y, i = 0, j = 0, n = chunks.length; ++i < n; ) {
        x = result[j];
        y = chunks[i];
        if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
          y && (result[++j] = y);
          continue;
        }
        ({ byteOffset: xOffset, byteLength: xLen } = x);
        ({ byteOffset: yOffset, byteLength: yLen } = y);
        if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
          y && (result[++j] = y);
          continue;
        }
        result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
      }
      return result;
    }
    function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
      const targetByteLength = target.byteLength;
      const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
      const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
      dst.set(src, targetByteOffset);
      return target;
    }
    exports.memcpy = memcpy;
    function joinUint8Arrays(chunks, size) {
      let result = collapseContiguousByteRanges(chunks);
      let byteLength = result.reduce((x, b) => x + b.byteLength, 0);
      let source, sliced, buffer;
      let offset = 0, index = -1, length = Math.min(size || Infinity, byteLength);
      for (let n = result.length; ++index < n; ) {
        source = result[index];
        sliced = source.subarray(0, Math.min(source.length, length - offset));
        if (length <= offset + sliced.length) {
          if (sliced.length < source.length) {
            result[index] = source.subarray(sliced.length);
          } else if (sliced.length === source.length) {
            index++;
          }
          buffer ? memcpy(buffer, sliced, offset) : buffer = sliced;
          break;
        }
        memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);
        offset += sliced.length;
      }
      return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];
    }
    exports.joinUint8Arrays = joinUint8Arrays;
    function toArrayBufferView(ArrayBufferViewCtor, input) {
      let value = compat_1.isIteratorResult(input) ? input.value : input;
      if (value instanceof ArrayBufferViewCtor) {
        if (ArrayBufferViewCtor === Uint8Array) {
          return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
        }
        return value;
      }
      if (!value) {
        return new ArrayBufferViewCtor(0);
      }
      if (typeof value === "string") {
        value = utf8_1.encodeUtf8(value);
      }
      if (value instanceof ArrayBuffer) {
        return new ArrayBufferViewCtor(value);
      }
      if (value instanceof SharedArrayBuf) {
        return new ArrayBufferViewCtor(value);
      }
      if (value instanceof ByteBuffer) {
        return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
      }
      return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
    }
    exports.toArrayBufferView = toArrayBufferView;
    exports.toInt8Array = (input) => toArrayBufferView(Int8Array, input);
    exports.toInt16Array = (input) => toArrayBufferView(Int16Array, input);
    exports.toInt32Array = (input) => toArrayBufferView(Int32Array, input);
    exports.toBigInt64Array = (input) => toArrayBufferView(compat_1.BigInt64Array, input);
    exports.toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
    exports.toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
    exports.toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
    exports.toBigUint64Array = (input) => toArrayBufferView(compat_1.BigUint64Array, input);
    exports.toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
    exports.toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
    exports.toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
    var pump = (iterator) => {
      iterator.next();
      return iterator;
    };
    function* toArrayBufferViewIterator(ArrayCtor, source) {
      const wrap = function* (x) {
        yield x;
      };
      const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !compat_1.isIterable(source) ? wrap(source) : source;
      yield* pump(function* (it) {
        let r = null;
        do {
          r = it.next(yield toArrayBufferView(ArrayCtor, r));
        } while (!r.done);
      }(buffers[Symbol.iterator]()));
    }
    exports.toArrayBufferViewIterator = toArrayBufferViewIterator;
    exports.toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
    exports.toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
    exports.toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
    exports.toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
    exports.toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
    exports.toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
    exports.toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
    exports.toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
    exports.toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
    async function* toArrayBufferViewAsyncIterator(ArrayCtor, source) {
      if (compat_1.isPromise(source)) {
        return yield* toArrayBufferViewAsyncIterator(ArrayCtor, await source);
      }
      const wrap = async function* (x) {
        yield await x;
      };
      const emit = async function* (source2) {
        yield* pump(function* (it) {
          let r = null;
          do {
            r = it.next(yield r && r.value);
          } while (!r.done);
        }(source2[Symbol.iterator]()));
      };
      const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : compat_1.isIterable(source) ? emit(source) : !compat_1.isAsyncIterable(source) ? wrap(source) : source;
      yield* pump(async function* (it) {
        let r = null;
        do {
          r = await it.next(yield toArrayBufferView(ArrayCtor, r));
        } while (!r.done);
      }(buffers[Symbol.asyncIterator]()));
    }
    exports.toArrayBufferViewAsyncIterator = toArrayBufferViewAsyncIterator;
    exports.toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
    exports.toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
    exports.toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
    exports.toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
    exports.toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
    exports.toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
    exports.toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
    exports.toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
    exports.toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
    function rebaseValueOffsets(offset, length, valueOffsets) {
      if (offset !== 0) {
        valueOffsets = valueOffsets.slice(0, length + 1);
        for (let i = -1; ++i <= length; ) {
          valueOffsets[i] += offset;
        }
      }
      return valueOffsets;
    }
    exports.rebaseValueOffsets = rebaseValueOffsets;
    function compareArrayLike(a, b) {
      let i = 0, n = a.length;
      if (n !== b.length) {
        return false;
      }
      if (n > 0) {
        do {
          if (a[i] !== b[i]) {
            return false;
          }
        } while (++i < n);
      }
      return true;
    }
    exports.compareArrayLike = compareArrayLike;
  }
});

// node_modules/apache-arrow/io/adapters.js
var require_adapters = __commonJS({
  "node_modules/apache-arrow/io/adapters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    exports.default = {
      fromIterable(source) {
        return pump(fromIterable(source));
      },
      fromAsyncIterable(source) {
        return pump(fromAsyncIterable(source));
      },
      fromDOMStream(source) {
        return pump(fromDOMStream(source));
      },
      fromNodeStream(stream) {
        return pump(fromNodeStream(stream));
      },
      // @ts-ignore
      toDOMStream(source, options) {
        throw new Error(`"toDOMStream" not available in this environment`);
      },
      // @ts-ignore
      toNodeStream(source, options) {
        throw new Error(`"toNodeStream" not available in this environment`);
      }
    };
    var pump = (iterator) => {
      iterator.next();
      return iterator;
    };
    function* fromIterable(source) {
      let done, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return buffer_1.joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = buffer_1.joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield null);
      let it = buffer_1.toUint8ArrayIterator(source)[Symbol.iterator]();
      try {
        do {
          ({ done, value: buffer } = isNaN(size - bufferLength) ? it.next(void 0) : it.next(size - bufferLength));
          if (!done && buffer.byteLength > 0) {
            buffers.push(buffer);
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield byteRange());
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && typeof it.throw === "function" && it.throw(e);
      } finally {
        threw === false && typeof it.return === "function" && it.return();
      }
    }
    async function* fromAsyncIterable(source) {
      let done, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return buffer_1.joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = buffer_1.joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield null);
      let it = buffer_1.toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();
      try {
        do {
          ({ done, value: buffer } = isNaN(size - bufferLength) ? await it.next(void 0) : await it.next(size - bufferLength));
          if (!done && buffer.byteLength > 0) {
            buffers.push(buffer);
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield byteRange());
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && typeof it.throw === "function" && await it.throw(e);
      } finally {
        threw === false && typeof it.return === "function" && await it.return();
      }
    }
    async function* fromDOMStream(source) {
      let done = false, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return buffer_1.joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = buffer_1.joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield null);
      let it = new AdaptiveByteReader(source);
      try {
        do {
          ({ done, value: buffer } = isNaN(size - bufferLength) ? await it["read"](void 0) : await it["read"](size - bufferLength));
          if (!done && buffer.byteLength > 0) {
            buffers.push(buffer_1.toUint8Array(buffer));
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield byteRange());
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && await it["cancel"](e);
      } finally {
        threw === false ? await it["cancel"]() : source["locked"] && it.releaseLock();
      }
    }
    var AdaptiveByteReader = class {
      constructor(source) {
        this.source = source;
        this.byobReader = null;
        this.defaultReader = null;
        try {
          this.supportsBYOB = !!(this.reader = this.getBYOBReader());
        } catch (e) {
          this.supportsBYOB = !!!(this.reader = this.getDefaultReader());
        }
      }
      get closed() {
        return this.reader ? this.reader["closed"].catch(() => {
        }) : Promise.resolve();
      }
      releaseLock() {
        if (this.reader) {
          this.reader.releaseLock();
        }
        this.reader = this.byobReader = this.defaultReader = null;
      }
      async cancel(reason) {
        const { reader, source } = this;
        reader && await reader["cancel"](reason).catch(() => {
        });
        source && (source["locked"] && this.releaseLock());
      }
      async read(size) {
        if (size === 0) {
          return { done: this.reader == null, value: new Uint8Array(0) };
        }
        const result = !this.supportsBYOB || typeof size !== "number" ? await this.getDefaultReader().read() : await this.readFromBYOBReader(size);
        !result.done && (result.value = buffer_1.toUint8Array(result));
        return result;
      }
      getDefaultReader() {
        if (this.byobReader) {
          this.releaseLock();
        }
        if (!this.defaultReader) {
          this.defaultReader = this.source["getReader"]();
          this.defaultReader["closed"].catch(() => {
          });
        }
        return this.reader = this.defaultReader;
      }
      getBYOBReader() {
        if (this.defaultReader) {
          this.releaseLock();
        }
        if (!this.byobReader) {
          this.byobReader = this.source["getReader"]({ mode: "byob" });
          this.byobReader["closed"].catch(() => {
          });
        }
        return this.reader = this.byobReader;
      }
      // This strategy plucked from the example in the streams spec:
      // https://streams.spec.whatwg.org/#example-manual-read-bytes
      async readFromBYOBReader(size) {
        return await readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);
      }
    };
    async function readInto(reader, buffer, offset, size) {
      if (offset >= size) {
        return { done: false, value: new Uint8Array(buffer, 0, size) };
      }
      const { done, value } = await reader.read(new Uint8Array(buffer, offset, size - offset));
      if ((offset += value.byteLength) < size && !done) {
        return await readInto(reader, value.buffer, offset, size);
      }
      return { done, value: new Uint8Array(value.buffer, 0, offset) };
    }
    var onEvent = (stream, event) => {
      let handler = (_) => resolve([event, _]);
      let resolve;
      return [event, handler, new Promise((r) => (resolve = r) && stream["once"](event, handler))];
    };
    async function* fromNodeStream(stream) {
      let events = [];
      let event = "error";
      let done = false, err = null;
      let cmd, size, bufferLength = 0;
      let buffers = [], buffer;
      function byteRange() {
        if (cmd === "peek") {
          return buffer_1.joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = buffer_1.joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield null);
      if (stream["isTTY"]) {
        return yield new Uint8Array(0);
      }
      try {
        events[0] = onEvent(stream, "end");
        events[1] = onEvent(stream, "error");
        do {
          events[2] = onEvent(stream, "readable");
          [event, err] = await Promise.race(events.map((x) => x[2]));
          if (event === "error") {
            break;
          }
          if (!(done = event === "end")) {
            if (!isFinite(size - bufferLength)) {
              buffer = buffer_1.toUint8Array(stream["read"](void 0));
            } else {
              buffer = buffer_1.toUint8Array(stream["read"](size - bufferLength));
              if (buffer.byteLength < size - bufferLength) {
                buffer = buffer_1.toUint8Array(stream["read"](void 0));
              }
            }
            if (buffer.byteLength > 0) {
              buffers.push(buffer);
              bufferLength += buffer.byteLength;
            }
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield byteRange());
            } while (size < bufferLength);
          }
        } while (!done);
      } finally {
        await cleanup(events, event === "error" ? err : null);
      }
      function cleanup(events2, err2) {
        buffer = buffers = null;
        return new Promise(async (resolve, reject) => {
          for (const [evt, fn] of events2) {
            stream["off"](evt, fn);
          }
          try {
            const destroy = stream["destroy"];
            destroy && destroy.call(stream, err2);
            err2 = void 0;
          } catch (e) {
            err2 = e || err2;
          } finally {
            err2 != null ? reject(err2) : resolve();
          }
        });
      }
    }
  }
});

// node_modules/apache-arrow/vector.js
var require_vector = __commonJS({
  "node_modules/apache-arrow/vector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractVector = class {
    };
    exports.AbstractVector = AbstractVector;
    exports.Vector = AbstractVector;
  }
});

// node_modules/apache-arrow/fb/Schema.js
var require_Schema = __commonJS({
  "node_modules/apache-arrow/fb/Schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var org;
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let MetadataVersion2;
            (function(MetadataVersion3) {
              MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
              MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
              MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
              MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
            })(MetadataVersion2 = flatbuf2.MetadataVersion || (flatbuf2.MetadataVersion = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let UnionMode2;
            (function(UnionMode3) {
              UnionMode3[UnionMode3["Sparse"] = 0] = "Sparse";
              UnionMode3[UnionMode3["Dense"] = 1] = "Dense";
            })(UnionMode2 = flatbuf2.UnionMode || (flatbuf2.UnionMode = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let Precision2;
            (function(Precision3) {
              Precision3[Precision3["HALF"] = 0] = "HALF";
              Precision3[Precision3["SINGLE"] = 1] = "SINGLE";
              Precision3[Precision3["DOUBLE"] = 2] = "DOUBLE";
            })(Precision2 = flatbuf2.Precision || (flatbuf2.Precision = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let DateUnit2;
            (function(DateUnit3) {
              DateUnit3[DateUnit3["DAY"] = 0] = "DAY";
              DateUnit3[DateUnit3["MILLISECOND"] = 1] = "MILLISECOND";
            })(DateUnit2 = flatbuf2.DateUnit || (flatbuf2.DateUnit = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let TimeUnit2;
            (function(TimeUnit3) {
              TimeUnit3[TimeUnit3["SECOND"] = 0] = "SECOND";
              TimeUnit3[TimeUnit3["MILLISECOND"] = 1] = "MILLISECOND";
              TimeUnit3[TimeUnit3["MICROSECOND"] = 2] = "MICROSECOND";
              TimeUnit3[TimeUnit3["NANOSECOND"] = 3] = "NANOSECOND";
            })(TimeUnit2 = flatbuf2.TimeUnit || (flatbuf2.TimeUnit = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let IntervalUnit2;
            (function(IntervalUnit3) {
              IntervalUnit3[IntervalUnit3["YEAR_MONTH"] = 0] = "YEAR_MONTH";
              IntervalUnit3[IntervalUnit3["DAY_TIME"] = 1] = "DAY_TIME";
            })(IntervalUnit2 = flatbuf2.IntervalUnit || (flatbuf2.IntervalUnit = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let Type2;
            (function(Type3) {
              Type3[Type3["NONE"] = 0] = "NONE";
              Type3[Type3["Null"] = 1] = "Null";
              Type3[Type3["Int"] = 2] = "Int";
              Type3[Type3["FloatingPoint"] = 3] = "FloatingPoint";
              Type3[Type3["Binary"] = 4] = "Binary";
              Type3[Type3["Utf8"] = 5] = "Utf8";
              Type3[Type3["Bool"] = 6] = "Bool";
              Type3[Type3["Decimal"] = 7] = "Decimal";
              Type3[Type3["Date"] = 8] = "Date";
              Type3[Type3["Time"] = 9] = "Time";
              Type3[Type3["Timestamp"] = 10] = "Timestamp";
              Type3[Type3["Interval"] = 11] = "Interval";
              Type3[Type3["List"] = 12] = "List";
              Type3[Type3["Struct_"] = 13] = "Struct_";
              Type3[Type3["Union"] = 14] = "Union";
              Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
              Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
              Type3[Type3["Map"] = 17] = "Map";
              Type3[Type3["Duration"] = 18] = "Duration";
              Type3[Type3["LargeBinary"] = 19] = "LargeBinary";
              Type3[Type3["LargeUtf8"] = 20] = "LargeUtf8";
              Type3[Type3["LargeList"] = 21] = "LargeList";
            })(Type2 = flatbuf2.Type || (flatbuf2.Type = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let Endianness;
            (function(Endianness2) {
              Endianness2[Endianness2["Little"] = 0] = "Little";
              Endianness2[Endianness2["Big"] = 1] = "Big";
            })(Endianness = flatbuf2.Endianness || (flatbuf2.Endianness = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Null2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Null
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Null= obj
               * @returns Null
               */
              static getRootAsNull(bb, obj) {
                return (obj || new Null2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startNull(builder) {
                builder.startObject(0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endNull(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createNull(builder) {
                Null2.startNull(builder);
                return Null2.endNull(builder);
              }
            }
            flatbuf2.Null = Null2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Struct_ {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Struct_
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Struct_= obj
               * @returns Struct_
               */
              static getRootAsStruct_(bb, obj) {
                return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startStruct_(builder) {
                builder.startObject(0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endStruct_(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createStruct_(builder) {
                Struct_.startStruct_(builder);
                return Struct_.endStruct_(builder);
              }
            }
            flatbuf2.Struct_ = Struct_;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class List2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns List
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param List= obj
               * @returns List
               */
              static getRootAsList(bb, obj) {
                return (obj || new List2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startList(builder) {
                builder.startObject(0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endList(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createList(builder) {
                List2.startList(builder);
                return List2.endList(builder);
              }
            }
            flatbuf2.List = List2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class LargeList {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns LargeList
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param LargeList= obj
               * @returns LargeList
               */
              static getRootAsLargeList(bb, obj) {
                return (obj || new LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startLargeList(builder) {
                builder.startObject(0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endLargeList(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createLargeList(builder) {
                LargeList.startLargeList(builder);
                return LargeList.endLargeList(builder);
              }
            }
            flatbuf2.LargeList = LargeList;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class FixedSizeList2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns FixedSizeList
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param FixedSizeList= obj
               * @returns FixedSizeList
               */
              static getRootAsFixedSizeList(bb, obj) {
                return (obj || new FixedSizeList2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * Number of list items per value
               *
               * @returns number
               */
              listSize() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startFixedSizeList(builder) {
                builder.startObject(1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number listSize
               */
              static addListSize(builder, listSize) {
                builder.addFieldInt32(0, listSize, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endFixedSizeList(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createFixedSizeList(builder, listSize) {
                FixedSizeList2.startFixedSizeList(builder);
                FixedSizeList2.addListSize(builder, listSize);
                return FixedSizeList2.endFixedSizeList(builder);
              }
            }
            flatbuf2.FixedSizeList = FixedSizeList2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Map2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Map
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Map= obj
               * @returns Map
               */
              static getRootAsMap(bb, obj) {
                return (obj || new Map2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * Set to true if the keys within each value are sorted
               *
               * @returns boolean
               */
              keysSorted() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startMap(builder) {
                builder.startObject(1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param boolean keysSorted
               */
              static addKeysSorted(builder, keysSorted) {
                builder.addFieldInt8(0, +keysSorted, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endMap(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createMap(builder, keysSorted) {
                Map2.startMap(builder);
                Map2.addKeysSorted(builder, keysSorted);
                return Map2.endMap(builder);
              }
            }
            flatbuf2.Map = Map2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Union2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Union
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Union= obj
               * @returns Union
               */
              static getRootAsUnion(bb, obj) {
                return (obj || new Union2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns org.apache.arrow.flatbuf.UnionMode
               */
              mode() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt16(this.bb_pos + offset)
                ) : org2.apache.arrow.flatbuf.UnionMode.Sparse;
              }
              /**
               * @param number index
               * @returns number
               */
              typeIds(index) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
              }
              /**
               * @returns number
               */
              typeIdsLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @returns Int32Array
               */
              typeIdsArray() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startUnion(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param org.apache.arrow.flatbuf.UnionMode mode
               */
              static addMode(builder, mode) {
                builder.addFieldInt16(0, mode, org2.apache.arrow.flatbuf.UnionMode.Sparse);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset typeIdsOffset
               */
              static addTypeIds(builder, typeIdsOffset) {
                builder.addFieldOffset(1, typeIdsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<number> data
               * @returns flatbuffers.Offset
               */
              static createTypeIdsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt32(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startTypeIdsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endUnion(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createUnion(builder, mode, typeIdsOffset) {
                Union2.startUnion(builder);
                Union2.addMode(builder, mode);
                Union2.addTypeIds(builder, typeIdsOffset);
                return Union2.endUnion(builder);
              }
            }
            flatbuf2.Union = Union2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Int2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Int
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Int= obj
               * @returns Int
               */
              static getRootAsInt(bb, obj) {
                return (obj || new Int2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns number
               */
              bitWidth() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
              }
              /**
               * @returns boolean
               */
              isSigned() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startInt(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number bitWidth
               */
              static addBitWidth(builder, bitWidth) {
                builder.addFieldInt32(0, bitWidth, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param boolean isSigned
               */
              static addIsSigned(builder, isSigned) {
                builder.addFieldInt8(1, +isSigned, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endInt(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createInt(builder, bitWidth, isSigned) {
                Int2.startInt(builder);
                Int2.addBitWidth(builder, bitWidth);
                Int2.addIsSigned(builder, isSigned);
                return Int2.endInt(builder);
              }
            }
            flatbuf2.Int = Int2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class FloatingPoint {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns FloatingPoint
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param FloatingPoint= obj
               * @returns FloatingPoint
               */
              static getRootAsFloatingPoint(bb, obj) {
                return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns org.apache.arrow.flatbuf.Precision
               */
              precision() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt16(this.bb_pos + offset)
                ) : org2.apache.arrow.flatbuf.Precision.HALF;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startFloatingPoint(builder) {
                builder.startObject(1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param org.apache.arrow.flatbuf.Precision precision
               */
              static addPrecision(builder, precision) {
                builder.addFieldInt16(0, precision, org2.apache.arrow.flatbuf.Precision.HALF);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endFloatingPoint(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createFloatingPoint(builder, precision) {
                FloatingPoint.startFloatingPoint(builder);
                FloatingPoint.addPrecision(builder, precision);
                return FloatingPoint.endFloatingPoint(builder);
              }
            }
            flatbuf2.FloatingPoint = FloatingPoint;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Utf82 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Utf8
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Utf8= obj
               * @returns Utf8
               */
              static getRootAsUtf8(bb, obj) {
                return (obj || new Utf82()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startUtf8(builder) {
                builder.startObject(0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endUtf8(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createUtf8(builder) {
                Utf82.startUtf8(builder);
                return Utf82.endUtf8(builder);
              }
            }
            flatbuf2.Utf8 = Utf82;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Binary2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Binary
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Binary= obj
               * @returns Binary
               */
              static getRootAsBinary(bb, obj) {
                return (obj || new Binary2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startBinary(builder) {
                builder.startObject(0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endBinary(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createBinary(builder) {
                Binary2.startBinary(builder);
                return Binary2.endBinary(builder);
              }
            }
            flatbuf2.Binary = Binary2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class LargeUtf8 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns LargeUtf8
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param LargeUtf8= obj
               * @returns LargeUtf8
               */
              static getRootAsLargeUtf8(bb, obj) {
                return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startLargeUtf8(builder) {
                builder.startObject(0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endLargeUtf8(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createLargeUtf8(builder) {
                LargeUtf8.startLargeUtf8(builder);
                return LargeUtf8.endLargeUtf8(builder);
              }
            }
            flatbuf2.LargeUtf8 = LargeUtf8;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class LargeBinary {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns LargeBinary
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param LargeBinary= obj
               * @returns LargeBinary
               */
              static getRootAsLargeBinary(bb, obj) {
                return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startLargeBinary(builder) {
                builder.startObject(0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endLargeBinary(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createLargeBinary(builder) {
                LargeBinary.startLargeBinary(builder);
                return LargeBinary.endLargeBinary(builder);
              }
            }
            flatbuf2.LargeBinary = LargeBinary;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class FixedSizeBinary2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns FixedSizeBinary
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param FixedSizeBinary= obj
               * @returns FixedSizeBinary
               */
              static getRootAsFixedSizeBinary(bb, obj) {
                return (obj || new FixedSizeBinary2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * Number of bytes per value
               *
               * @returns number
               */
              byteWidth() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startFixedSizeBinary(builder) {
                builder.startObject(1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number byteWidth
               */
              static addByteWidth(builder, byteWidth) {
                builder.addFieldInt32(0, byteWidth, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endFixedSizeBinary(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createFixedSizeBinary(builder, byteWidth) {
                FixedSizeBinary2.startFixedSizeBinary(builder);
                FixedSizeBinary2.addByteWidth(builder, byteWidth);
                return FixedSizeBinary2.endFixedSizeBinary(builder);
              }
            }
            flatbuf2.FixedSizeBinary = FixedSizeBinary2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Bool2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Bool
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Bool= obj
               * @returns Bool
               */
              static getRootAsBool(bb, obj) {
                return (obj || new Bool2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startBool(builder) {
                builder.startObject(0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endBool(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createBool(builder) {
                Bool2.startBool(builder);
                return Bool2.endBool(builder);
              }
            }
            flatbuf2.Bool = Bool2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Decimal2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Decimal
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Decimal= obj
               * @returns Decimal
               */
              static getRootAsDecimal(bb, obj) {
                return (obj || new Decimal2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * Total number of decimal digits
               *
               * @returns number
               */
              precision() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
              }
              /**
               * Number of digits after the decimal point "."
               *
               * @returns number
               */
              scale() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startDecimal(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number precision
               */
              static addPrecision(builder, precision) {
                builder.addFieldInt32(0, precision, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number scale
               */
              static addScale(builder, scale) {
                builder.addFieldInt32(1, scale, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endDecimal(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDecimal(builder, precision, scale) {
                Decimal2.startDecimal(builder);
                Decimal2.addPrecision(builder, precision);
                Decimal2.addScale(builder, scale);
                return Decimal2.endDecimal(builder);
              }
            }
            flatbuf2.Decimal = Decimal2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Date2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Date
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Date= obj
               * @returns Date
               */
              static getRootAsDate(bb, obj) {
                return (obj || new Date2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns org.apache.arrow.flatbuf.DateUnit
               */
              unit() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt16(this.bb_pos + offset)
                ) : org2.apache.arrow.flatbuf.DateUnit.MILLISECOND;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startDate(builder) {
                builder.startObject(1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param org.apache.arrow.flatbuf.DateUnit unit
               */
              static addUnit(builder, unit) {
                builder.addFieldInt16(0, unit, org2.apache.arrow.flatbuf.DateUnit.MILLISECOND);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endDate(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDate(builder, unit) {
                Date2.startDate(builder);
                Date2.addUnit(builder, unit);
                return Date2.endDate(builder);
              }
            }
            flatbuf2.Date = Date2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Time2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Time
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Time= obj
               * @returns Time
               */
              static getRootAsTime(bb, obj) {
                return (obj || new Time2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns org.apache.arrow.flatbuf.TimeUnit
               */
              unit() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt16(this.bb_pos + offset)
                ) : org2.apache.arrow.flatbuf.TimeUnit.MILLISECOND;
              }
              /**
               * @returns number
               */
              bitWidth() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startTime(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param org.apache.arrow.flatbuf.TimeUnit unit
               */
              static addUnit(builder, unit) {
                builder.addFieldInt16(0, unit, org2.apache.arrow.flatbuf.TimeUnit.MILLISECOND);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number bitWidth
               */
              static addBitWidth(builder, bitWidth) {
                builder.addFieldInt32(1, bitWidth, 32);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endTime(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createTime(builder, unit, bitWidth) {
                Time2.startTime(builder);
                Time2.addUnit(builder, unit);
                Time2.addBitWidth(builder, bitWidth);
                return Time2.endTime(builder);
              }
            }
            flatbuf2.Time = Time2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Timestamp2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Timestamp
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Timestamp= obj
               * @returns Timestamp
               */
              static getRootAsTimestamp(bb, obj) {
                return (obj || new Timestamp2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns org.apache.arrow.flatbuf.TimeUnit
               */
              unit() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt16(this.bb_pos + offset)
                ) : org2.apache.arrow.flatbuf.TimeUnit.SECOND;
              }
              timezone(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startTimestamp(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param org.apache.arrow.flatbuf.TimeUnit unit
               */
              static addUnit(builder, unit) {
                builder.addFieldInt16(0, unit, org2.apache.arrow.flatbuf.TimeUnit.SECOND);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset timezoneOffset
               */
              static addTimezone(builder, timezoneOffset) {
                builder.addFieldOffset(1, timezoneOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endTimestamp(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createTimestamp(builder, unit, timezoneOffset) {
                Timestamp2.startTimestamp(builder);
                Timestamp2.addUnit(builder, unit);
                Timestamp2.addTimezone(builder, timezoneOffset);
                return Timestamp2.endTimestamp(builder);
              }
            }
            flatbuf2.Timestamp = Timestamp2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Interval2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Interval
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Interval= obj
               * @returns Interval
               */
              static getRootAsInterval(bb, obj) {
                return (obj || new Interval2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns org.apache.arrow.flatbuf.IntervalUnit
               */
              unit() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt16(this.bb_pos + offset)
                ) : org2.apache.arrow.flatbuf.IntervalUnit.YEAR_MONTH;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startInterval(builder) {
                builder.startObject(1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param org.apache.arrow.flatbuf.IntervalUnit unit
               */
              static addUnit(builder, unit) {
                builder.addFieldInt16(0, unit, org2.apache.arrow.flatbuf.IntervalUnit.YEAR_MONTH);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endInterval(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createInterval(builder, unit) {
                Interval2.startInterval(builder);
                Interval2.addUnit(builder, unit);
                return Interval2.endInterval(builder);
              }
            }
            flatbuf2.Interval = Interval2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Duration {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Duration
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Duration= obj
               * @returns Duration
               */
              static getRootAsDuration(bb, obj) {
                return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns org.apache.arrow.flatbuf.TimeUnit
               */
              unit() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt16(this.bb_pos + offset)
                ) : org2.apache.arrow.flatbuf.TimeUnit.MILLISECOND;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startDuration(builder) {
                builder.startObject(1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param org.apache.arrow.flatbuf.TimeUnit unit
               */
              static addUnit(builder, unit) {
                builder.addFieldInt16(0, unit, org2.apache.arrow.flatbuf.TimeUnit.MILLISECOND);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endDuration(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDuration(builder, unit) {
                Duration.startDuration(builder);
                Duration.addUnit(builder, unit);
                return Duration.endDuration(builder);
              }
            }
            flatbuf2.Duration = Duration;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class KeyValue {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns KeyValue
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param KeyValue= obj
               * @returns KeyValue
               */
              static getRootAsKeyValue(bb, obj) {
                return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              key(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              value(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startKeyValue(builder) {
                builder.startObject(2);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset keyOffset
               */
              static addKey(builder, keyOffset) {
                builder.addFieldOffset(0, keyOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset valueOffset
               */
              static addValue(builder, valueOffset) {
                builder.addFieldOffset(1, valueOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endKeyValue(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createKeyValue(builder, keyOffset, valueOffset) {
                KeyValue.startKeyValue(builder);
                KeyValue.addKey(builder, keyOffset);
                KeyValue.addValue(builder, valueOffset);
                return KeyValue.endKeyValue(builder);
              }
            }
            flatbuf2.KeyValue = KeyValue;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class DictionaryEncoding {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns DictionaryEncoding
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param DictionaryEncoding= obj
               * @returns DictionaryEncoding
               */
              static getRootAsDictionaryEncoding(bb, obj) {
                return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * The known dictionary id in the application where this data is used. In
               * the file or streaming formats, the dictionary ids are found in the
               * DictionaryBatch messages
               *
               * @returns flatbuffers.Long
               */
              id() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              /**
               * The dictionary indices are constrained to be positive integers. If this
               * field is null, the indices must be signed int32
               *
               * @param org.apache.arrow.flatbuf.Int= obj
               * @returns org.apache.arrow.flatbuf.Int|null
               */
              indexType(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new org2.apache.arrow.flatbuf.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * By default, dictionaries are not ordered, or the order does not have
               * semantic meaning. In some statistical, applications, dictionary-encoding
               * is used to represent ordered categorical data, and we provide a way to
               * preserve that metadata here
               *
               * @returns boolean
               */
              isOrdered() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startDictionaryEncoding(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long id
               */
              static addId(builder, id) {
                builder.addFieldInt64(0, id, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset indexTypeOffset
               */
              static addIndexType(builder, indexTypeOffset) {
                builder.addFieldOffset(1, indexTypeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param boolean isOrdered
               */
              static addIsOrdered(builder, isOrdered) {
                builder.addFieldInt8(2, +isOrdered, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endDictionaryEncoding(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDictionaryEncoding(builder, id, indexTypeOffset, isOrdered) {
                DictionaryEncoding.startDictionaryEncoding(builder);
                DictionaryEncoding.addId(builder, id);
                DictionaryEncoding.addIndexType(builder, indexTypeOffset);
                DictionaryEncoding.addIsOrdered(builder, isOrdered);
                return DictionaryEncoding.endDictionaryEncoding(builder);
              }
            }
            flatbuf2.DictionaryEncoding = DictionaryEncoding;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Field2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Field
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Field= obj
               * @returns Field
               */
              static getRootAsField(bb, obj) {
                return (obj || new Field2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              name(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              /**
               * Whether or not this field can contain nulls. Should be true in general.
               *
               * @returns boolean
               */
              nullable() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
              }
              /**
               * @returns org.apache.arrow.flatbuf.Type
               */
              typeType() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (
                  /**  */
                  this.bb.readUint8(this.bb_pos + offset)
                ) : org2.apache.arrow.flatbuf.Type.NONE;
              }
              /**
               * This is the type of the decoded value if the field is dictionary encoded.
               *
               * @param flatbuffers.Table obj
               * @returns ?flatbuffers.Table
               */
              type(obj) {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
              }
              /**
               * Present only if the field is dictionary encoded.
               *
               * @param org.apache.arrow.flatbuf.DictionaryEncoding= obj
               * @returns org.apache.arrow.flatbuf.DictionaryEncoding|null
               */
              dictionary(obj) {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? (obj || new org2.apache.arrow.flatbuf.DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * children apply only to nested data types like Struct, List and Union. For
               * primitive types children will have length 0.
               *
               * @param number index
               * @param org.apache.arrow.flatbuf.Field= obj
               * @returns org.apache.arrow.flatbuf.Field
               */
              children(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? (obj || new org2.apache.arrow.flatbuf.Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
              }
              /**
               * @returns number
               */
              childrenLength() {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * User-defined metadata
               *
               * @param number index
               * @param org.apache.arrow.flatbuf.KeyValue= obj
               * @returns org.apache.arrow.flatbuf.KeyValue
               */
              customMetadata(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? (obj || new org2.apache.arrow.flatbuf.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
              }
              /**
               * @returns number
               */
              customMetadataLength() {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startField(builder) {
                builder.startObject(7);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nameOffset
               */
              static addName(builder, nameOffset) {
                builder.addFieldOffset(0, nameOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param boolean nullable
               */
              static addNullable(builder, nullable) {
                builder.addFieldInt8(1, +nullable, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param org.apache.arrow.flatbuf.Type typeType
               */
              static addTypeType(builder, typeType) {
                builder.addFieldInt8(2, typeType, org2.apache.arrow.flatbuf.Type.NONE);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset typeOffset
               */
              static addType(builder, typeOffset) {
                builder.addFieldOffset(3, typeOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset dictionaryOffset
               */
              static addDictionary(builder, dictionaryOffset) {
                builder.addFieldOffset(4, dictionaryOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset childrenOffset
               */
              static addChildren(builder, childrenOffset) {
                builder.addFieldOffset(5, childrenOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createChildrenVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startChildrenVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset customMetadataOffset
               */
              static addCustomMetadata(builder, customMetadataOffset) {
                builder.addFieldOffset(6, customMetadataOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createCustomMetadataVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startCustomMetadataVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endField(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createField(builder, nameOffset, nullable, typeType, typeOffset, dictionaryOffset, childrenOffset, customMetadataOffset) {
                Field2.startField(builder);
                Field2.addName(builder, nameOffset);
                Field2.addNullable(builder, nullable);
                Field2.addTypeType(builder, typeType);
                Field2.addType(builder, typeOffset);
                Field2.addDictionary(builder, dictionaryOffset);
                Field2.addChildren(builder, childrenOffset);
                Field2.addCustomMetadata(builder, customMetadataOffset);
                return Field2.endField(builder);
              }
            }
            flatbuf2.Field = Field2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Buffer2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Buffer
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * The relative offset into the shared memory page where the bytes for this
               * buffer starts
               *
               * @returns flatbuffers.Long
               */
              offset() {
                return this.bb.readInt64(this.bb_pos);
              }
              /**
               * The absolute length (in bytes) of the memory buffer. The memory is found
               * from offset (inclusive) to offset + length (non-inclusive).
               *
               * @returns flatbuffers.Long
               */
              length() {
                return this.bb.readInt64(this.bb_pos + 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long offset
               * @param flatbuffers.Long length
               * @returns flatbuffers.Offset
               */
              static createBuffer(builder, offset, length) {
                builder.prep(8, 16);
                builder.writeInt64(length);
                builder.writeInt64(offset);
                return builder.offset();
              }
            }
            flatbuf2.Buffer = Buffer2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Schema2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Schema
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Schema= obj
               * @returns Schema
               */
              static getRootAsSchema(bb, obj) {
                return (obj || new Schema2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * endianness of the buffer
               * it is Little Endian by default
               * if endianness doesn't match the underlying system then the vectors need to be converted
               *
               * @returns org.apache.arrow.flatbuf.Endianness
               */
              endianness() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt16(this.bb_pos + offset)
                ) : org2.apache.arrow.flatbuf.Endianness.Little;
              }
              /**
               * @param number index
               * @param org.apache.arrow.flatbuf.Field= obj
               * @returns org.apache.arrow.flatbuf.Field
               */
              fields(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new org2.apache.arrow.flatbuf.Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
              }
              /**
               * @returns number
               */
              fieldsLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param org.apache.arrow.flatbuf.KeyValue= obj
               * @returns org.apache.arrow.flatbuf.KeyValue
               */
              customMetadata(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new org2.apache.arrow.flatbuf.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
              }
              /**
               * @returns number
               */
              customMetadataLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startSchema(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param org.apache.arrow.flatbuf.Endianness endianness
               */
              static addEndianness(builder, endianness) {
                builder.addFieldInt16(0, endianness, org2.apache.arrow.flatbuf.Endianness.Little);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset fieldsOffset
               */
              static addFields(builder, fieldsOffset) {
                builder.addFieldOffset(1, fieldsOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createFieldsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startFieldsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset customMetadataOffset
               */
              static addCustomMetadata(builder, customMetadataOffset) {
                builder.addFieldOffset(2, customMetadataOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createCustomMetadataVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startCustomMetadataVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endSchema(builder) {
                let offset = builder.endObject();
                return offset;
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset offset
               */
              static finishSchemaBuffer(builder, offset) {
                builder.finish(offset);
              }
              static createSchema(builder, endianness, fieldsOffset, customMetadataOffset) {
                Schema2.startSchema(builder);
                Schema2.addEndianness(builder, endianness);
                Schema2.addFields(builder, fieldsOffset);
                Schema2.addCustomMetadata(builder, customMetadataOffset);
                return Schema2.endSchema(builder);
              }
            }
            flatbuf2.Schema = Schema2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
  }
});

// node_modules/apache-arrow/fb/Message.js
var require_Message = __commonJS({
  "node_modules/apache-arrow/fb/Message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NS7624605610262437867 = require_Schema();
    var org;
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            flatbuf2.Schema = NS7624605610262437867.org.apache.arrow.flatbuf.Schema;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let MessageHeader2;
            (function(MessageHeader3) {
              MessageHeader3[MessageHeader3["NONE"] = 0] = "NONE";
              MessageHeader3[MessageHeader3["Schema"] = 1] = "Schema";
              MessageHeader3[MessageHeader3["DictionaryBatch"] = 2] = "DictionaryBatch";
              MessageHeader3[MessageHeader3["RecordBatch"] = 3] = "RecordBatch";
              MessageHeader3[MessageHeader3["Tensor"] = 4] = "Tensor";
              MessageHeader3[MessageHeader3["SparseTensor"] = 5] = "SparseTensor";
            })(MessageHeader2 = flatbuf2.MessageHeader || (flatbuf2.MessageHeader = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class FieldNode {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns FieldNode
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * The number of value slots in the Arrow array at this level of a nested
               * tree
               *
               * @returns flatbuffers.Long
               */
              length() {
                return this.bb.readInt64(this.bb_pos);
              }
              /**
               * The number of observed nulls. Fields with null_count == 0 may choose not
               * to write their physical validity bitmap out as a materialized buffer,
               * instead setting the length of the bitmap buffer to 0.
               *
               * @returns flatbuffers.Long
               */
              nullCount() {
                return this.bb.readInt64(this.bb_pos + 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long length
               * @param flatbuffers.Long null_count
               * @returns flatbuffers.Offset
               */
              static createFieldNode(builder, length, null_count) {
                builder.prep(8, 16);
                builder.writeInt64(null_count);
                builder.writeInt64(length);
                return builder.offset();
              }
            }
            flatbuf2.FieldNode = FieldNode;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class RecordBatch2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns RecordBatch
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param RecordBatch= obj
               * @returns RecordBatch
               */
              static getRootAsRecordBatch(bb, obj) {
                return (obj || new RecordBatch2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * number of records / rows. The arrays in the batch should all have this
               * length
               *
               * @returns flatbuffers.Long
               */
              length() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              /**
               * Nodes correspond to the pre-ordered flattened logical schema
               *
               * @param number index
               * @param org.apache.arrow.flatbuf.FieldNode= obj
               * @returns org.apache.arrow.flatbuf.FieldNode
               */
              nodes(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new org2.apache.arrow.flatbuf.FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
              }
              /**
               * @returns number
               */
              nodesLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * Buffers correspond to the pre-ordered flattened buffer tree
               *
               * The number of buffers appended to this list depends on the schema. For
               * example, most primitive arrays will have 2 buffers, 1 for the validity
               * bitmap and 1 for the values. For struct arrays, there will only be a
               * single buffer for the validity (nulls) bitmap
               *
               * @param number index
               * @param org.apache.arrow.flatbuf.Buffer= obj
               * @returns org.apache.arrow.flatbuf.Buffer
               */
              buffers(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new NS7624605610262437867.org.apache.arrow.flatbuf.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
              }
              /**
               * @returns number
               */
              buffersLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startRecordBatch(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long length
               */
              static addLength(builder, length) {
                builder.addFieldInt64(0, length, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset nodesOffset
               */
              static addNodes(builder, nodesOffset) {
                builder.addFieldOffset(1, nodesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startNodesVector(builder, numElems) {
                builder.startVector(16, numElems, 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset buffersOffset
               */
              static addBuffers(builder, buffersOffset) {
                builder.addFieldOffset(2, buffersOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startBuffersVector(builder, numElems) {
                builder.startVector(16, numElems, 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endRecordBatch(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createRecordBatch(builder, length, nodesOffset, buffersOffset) {
                RecordBatch2.startRecordBatch(builder);
                RecordBatch2.addLength(builder, length);
                RecordBatch2.addNodes(builder, nodesOffset);
                RecordBatch2.addBuffers(builder, buffersOffset);
                return RecordBatch2.endRecordBatch(builder);
              }
            }
            flatbuf2.RecordBatch = RecordBatch2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class DictionaryBatch {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns DictionaryBatch
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param DictionaryBatch= obj
               * @returns DictionaryBatch
               */
              static getRootAsDictionaryBatch(bb, obj) {
                return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns flatbuffers.Long
               */
              id() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              /**
               * @param org.apache.arrow.flatbuf.RecordBatch= obj
               * @returns org.apache.arrow.flatbuf.RecordBatch|null
               */
              data(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new org2.apache.arrow.flatbuf.RecordBatch()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * If isDelta is true the values in the dictionary are to be appended to a
               * dictionary with the indicated id
               *
               * @returns boolean
               */
              isDelta() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startDictionaryBatch(builder) {
                builder.startObject(3);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long id
               */
              static addId(builder, id) {
                builder.addFieldInt64(0, id, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset dataOffset
               */
              static addData(builder, dataOffset) {
                builder.addFieldOffset(1, dataOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param boolean isDelta
               */
              static addIsDelta(builder, isDelta) {
                builder.addFieldInt8(2, +isDelta, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endDictionaryBatch(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDictionaryBatch(builder, id, dataOffset, isDelta) {
                DictionaryBatch.startDictionaryBatch(builder);
                DictionaryBatch.addId(builder, id);
                DictionaryBatch.addData(builder, dataOffset);
                DictionaryBatch.addIsDelta(builder, isDelta);
                return DictionaryBatch.endDictionaryBatch(builder);
              }
            }
            flatbuf2.DictionaryBatch = DictionaryBatch;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Message2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Message
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Message= obj
               * @returns Message
               */
              static getRootAsMessage(bb, obj) {
                return (obj || new Message2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns org.apache.arrow.flatbuf.MetadataVersion
               */
              version() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt16(this.bb_pos + offset)
                ) : NS7624605610262437867.org.apache.arrow.flatbuf.MetadataVersion.V1;
              }
              /**
               * @returns org.apache.arrow.flatbuf.MessageHeader
               */
              headerType() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (
                  /**  */
                  this.bb.readUint8(this.bb_pos + offset)
                ) : org2.apache.arrow.flatbuf.MessageHeader.NONE;
              }
              /**
               * @param flatbuffers.Table obj
               * @returns ?flatbuffers.Table
               */
              header(obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
              }
              /**
               * @returns flatbuffers.Long
               */
              bodyLength() {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              /**
               * @param number index
               * @param org.apache.arrow.flatbuf.KeyValue= obj
               * @returns org.apache.arrow.flatbuf.KeyValue
               */
              customMetadata(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? (obj || new NS7624605610262437867.org.apache.arrow.flatbuf.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
              }
              /**
               * @returns number
               */
              customMetadataLength() {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startMessage(builder) {
                builder.startObject(5);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param org.apache.arrow.flatbuf.MetadataVersion version
               */
              static addVersion(builder, version) {
                builder.addFieldInt16(0, version, NS7624605610262437867.org.apache.arrow.flatbuf.MetadataVersion.V1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param org.apache.arrow.flatbuf.MessageHeader headerType
               */
              static addHeaderType(builder, headerType) {
                builder.addFieldInt8(1, headerType, org2.apache.arrow.flatbuf.MessageHeader.NONE);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset headerOffset
               */
              static addHeader(builder, headerOffset) {
                builder.addFieldOffset(2, headerOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long bodyLength
               */
              static addBodyLength(builder, bodyLength) {
                builder.addFieldInt64(3, bodyLength, builder.createLong(0, 0));
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset customMetadataOffset
               */
              static addCustomMetadata(builder, customMetadataOffset) {
                builder.addFieldOffset(4, customMetadataOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param Array.<flatbuffers.Offset> data
               * @returns flatbuffers.Offset
               */
              static createCustomMetadataVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startCustomMetadataVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endMessage(builder) {
                let offset = builder.endObject();
                return offset;
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset offset
               */
              static finishMessageBuffer(builder, offset) {
                builder.finish(offset);
              }
              static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
                Message2.startMessage(builder);
                Message2.addVersion(builder, version);
                Message2.addHeaderType(builder, headerType);
                Message2.addHeader(builder, headerOffset);
                Message2.addBodyLength(builder, bodyLength);
                Message2.addCustomMetadata(builder, customMetadataOffset);
                return Message2.endMessage(builder);
              }
            }
            flatbuf2.Message = Message2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
  }
});

// node_modules/apache-arrow/enum.js
var require_enum = __commonJS({
  "node_modules/apache-arrow/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Schema_ = require_Schema();
    var Message_ = require_Message();
    exports.ArrowType = Schema_.org.apache.arrow.flatbuf.Type;
    exports.DateUnit = Schema_.org.apache.arrow.flatbuf.DateUnit;
    exports.TimeUnit = Schema_.org.apache.arrow.flatbuf.TimeUnit;
    exports.Precision = Schema_.org.apache.arrow.flatbuf.Precision;
    exports.UnionMode = Schema_.org.apache.arrow.flatbuf.UnionMode;
    exports.IntervalUnit = Schema_.org.apache.arrow.flatbuf.IntervalUnit;
    exports.MessageHeader = Message_.org.apache.arrow.flatbuf.MessageHeader;
    exports.MetadataVersion = Schema_.org.apache.arrow.flatbuf.MetadataVersion;
    var Type2;
    (function(Type3) {
      Type3[Type3["NONE"] = 0] = "NONE";
      Type3[Type3["Null"] = 1] = "Null";
      Type3[Type3["Int"] = 2] = "Int";
      Type3[Type3["Float"] = 3] = "Float";
      Type3[Type3["Binary"] = 4] = "Binary";
      Type3[Type3["Utf8"] = 5] = "Utf8";
      Type3[Type3["Bool"] = 6] = "Bool";
      Type3[Type3["Decimal"] = 7] = "Decimal";
      Type3[Type3["Date"] = 8] = "Date";
      Type3[Type3["Time"] = 9] = "Time";
      Type3[Type3["Timestamp"] = 10] = "Timestamp";
      Type3[Type3["Interval"] = 11] = "Interval";
      Type3[Type3["List"] = 12] = "List";
      Type3[Type3["Struct"] = 13] = "Struct";
      Type3[Type3["Union"] = 14] = "Union";
      Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
      Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
      Type3[Type3["Map"] = 17] = "Map";
      Type3[Type3["Dictionary"] = -1] = "Dictionary";
      Type3[Type3["Int8"] = -2] = "Int8";
      Type3[Type3["Int16"] = -3] = "Int16";
      Type3[Type3["Int32"] = -4] = "Int32";
      Type3[Type3["Int64"] = -5] = "Int64";
      Type3[Type3["Uint8"] = -6] = "Uint8";
      Type3[Type3["Uint16"] = -7] = "Uint16";
      Type3[Type3["Uint32"] = -8] = "Uint32";
      Type3[Type3["Uint64"] = -9] = "Uint64";
      Type3[Type3["Float16"] = -10] = "Float16";
      Type3[Type3["Float32"] = -11] = "Float32";
      Type3[Type3["Float64"] = -12] = "Float64";
      Type3[Type3["DateDay"] = -13] = "DateDay";
      Type3[Type3["DateMillisecond"] = -14] = "DateMillisecond";
      Type3[Type3["TimestampSecond"] = -15] = "TimestampSecond";
      Type3[Type3["TimestampMillisecond"] = -16] = "TimestampMillisecond";
      Type3[Type3["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
      Type3[Type3["TimestampNanosecond"] = -18] = "TimestampNanosecond";
      Type3[Type3["TimeSecond"] = -19] = "TimeSecond";
      Type3[Type3["TimeMillisecond"] = -20] = "TimeMillisecond";
      Type3[Type3["TimeMicrosecond"] = -21] = "TimeMicrosecond";
      Type3[Type3["TimeNanosecond"] = -22] = "TimeNanosecond";
      Type3[Type3["DenseUnion"] = -23] = "DenseUnion";
      Type3[Type3["SparseUnion"] = -24] = "SparseUnion";
      Type3[Type3["IntervalDayTime"] = -25] = "IntervalDayTime";
      Type3[Type3["IntervalYearMonth"] = -26] = "IntervalYearMonth";
    })(Type2 = exports.Type || (exports.Type = {}));
    var BufferType2;
    (function(BufferType3) {
      BufferType3[BufferType3["OFFSET"] = 0] = "OFFSET";
      BufferType3[BufferType3["DATA"] = 1] = "DATA";
      BufferType3[BufferType3["VALIDITY"] = 2] = "VALIDITY";
      BufferType3[BufferType3["TYPE"] = 3] = "TYPE";
    })(BufferType2 = exports.BufferType || (exports.BufferType = {}));
  }
});

// node_modules/apache-arrow/util/bit.js
var require_bit = __commonJS({
  "node_modules/apache-arrow/util/bit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getBool(_data, _index, byte, bit) {
      return (byte & 1 << bit) !== 0;
    }
    exports.getBool = getBool;
    function getBit(_data, _index, byte, bit) {
      return (byte & 1 << bit) >> bit;
    }
    exports.getBit = getBit;
    function setBool(bytes, index, value) {
      return value ? !!(bytes[index >> 3] |= 1 << index % 8) || true : !(bytes[index >> 3] &= ~(1 << index % 8)) && false;
    }
    exports.setBool = setBool;
    function truncateBitmap(offset, length, bitmap) {
      const alignedSize = bitmap.byteLength + 7 & ~7;
      if (offset > 0 || bitmap.byteLength < alignedSize) {
        const bytes = new Uint8Array(alignedSize);
        bytes.set(offset % 8 === 0 ? bitmap.subarray(offset >> 3) : (
          // Otherwise iterate each bit from the offset and return a new one
          packBools(iterateBits(bitmap, offset, length, null, getBool)).subarray(0, alignedSize)
        ));
        return bytes;
      }
      return bitmap;
    }
    exports.truncateBitmap = truncateBitmap;
    function packBools(values) {
      let xs = [];
      let i = 0, bit = 0, byte = 0;
      for (const value of values) {
        value && (byte |= 1 << bit);
        if (++bit === 8) {
          xs[i++] = byte;
          byte = bit = 0;
        }
      }
      if (i === 0 || bit > 0) {
        xs[i++] = byte;
      }
      let b = new Uint8Array(xs.length + 7 & ~7);
      b.set(xs);
      return b;
    }
    exports.packBools = packBools;
    function* iterateBits(bytes, begin, length, context, get) {
      let bit = begin % 8;
      let byteIndex = begin >> 3;
      let index = 0, remaining = length;
      for (; remaining > 0; bit = 0) {
        let byte = bytes[byteIndex++];
        do {
          yield get(context, index++, byte, bit);
        } while (--remaining > 0 && ++bit < 8);
      }
    }
    exports.iterateBits = iterateBits;
    function popcnt_bit_range(data, lhs, rhs) {
      if (rhs - lhs <= 0) {
        return 0;
      }
      if (rhs - lhs < 8) {
        let sum = 0;
        for (const bit of iterateBits(data, lhs, rhs - lhs, data, getBit)) {
          sum += bit;
        }
        return sum;
      }
      const rhsInside = rhs >> 3 << 3;
      const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
      return (
        // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
        popcnt_bit_range(data, lhs, lhsInside) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
        popcnt_bit_range(data, rhsInside, rhs) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
        popcnt_array(data, lhsInside >> 3, rhsInside - lhsInside >> 3)
      );
    }
    exports.popcnt_bit_range = popcnt_bit_range;
    function popcnt_array(arr, byteOffset, byteLength) {
      let cnt = 0, pos = byteOffset | 0;
      const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;
      while (len - pos >= 4) {
        cnt += popcnt_uint32(view.getUint32(pos));
        pos += 4;
      }
      while (len - pos >= 2) {
        cnt += popcnt_uint32(view.getUint16(pos));
        pos += 2;
      }
      while (len - pos >= 1) {
        cnt += popcnt_uint32(view.getUint8(pos));
        pos += 1;
      }
      return cnt;
    }
    exports.popcnt_array = popcnt_array;
    function popcnt_uint32(uint32) {
      let i = uint32 | 0;
      i = i - (i >>> 1 & 1431655765);
      i = (i & 858993459) + (i >>> 2 & 858993459);
      return (i + (i >>> 4) & 252645135) * 16843009 >>> 24;
    }
    exports.popcnt_uint32 = popcnt_uint32;
  }
});

// node_modules/apache-arrow/visitor.js
var require_visitor = __commonJS({
  "node_modules/apache-arrow/visitor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var vector_1 = require_vector();
    var enum_1 = require_enum();
    var type_1 = require_type();
    var Visitor2 = class {
      visitMany(nodes, ...args) {
        return nodes.map((node, i) => this.visit(node, ...args.map((x) => x[i])));
      }
      visit(...args) {
        return this.getVisitFn(args[0], false).apply(this, args);
      }
      getVisitFn(node, throwIfNotFound = true) {
        return getVisitFn(this, node, throwIfNotFound);
      }
      visitNull(_node, ..._args) {
        return null;
      }
      visitBool(_node, ..._args) {
        return null;
      }
      visitInt(_node, ..._args) {
        return null;
      }
      visitFloat(_node, ..._args) {
        return null;
      }
      visitUtf8(_node, ..._args) {
        return null;
      }
      visitBinary(_node, ..._args) {
        return null;
      }
      visitFixedSizeBinary(_node, ..._args) {
        return null;
      }
      visitDate(_node, ..._args) {
        return null;
      }
      visitTimestamp(_node, ..._args) {
        return null;
      }
      visitTime(_node, ..._args) {
        return null;
      }
      visitDecimal(_node, ..._args) {
        return null;
      }
      visitList(_node, ..._args) {
        return null;
      }
      visitStruct(_node, ..._args) {
        return null;
      }
      visitUnion(_node, ..._args) {
        return null;
      }
      visitDictionary(_node, ..._args) {
        return null;
      }
      visitInterval(_node, ..._args) {
        return null;
      }
      visitFixedSizeList(_node, ..._args) {
        return null;
      }
      visitMap(_node, ..._args) {
        return null;
      }
    };
    exports.Visitor = Visitor2;
    function getVisitFn(visitor, node, throwIfNotFound = true) {
      let fn = null;
      let dtype = enum_1.Type.NONE;
      if (node instanceof data_1.Data) {
        dtype = inferDType(node.type);
      } else if (node instanceof vector_1.Vector) {
        dtype = inferDType(node.type);
      } else if (node instanceof type_1.DataType) {
        dtype = inferDType(node);
      } else if (typeof (dtype = node) !== "number") {
        dtype = enum_1.Type[node];
      }
      switch (dtype) {
        case enum_1.Type.Null:
          fn = visitor.visitNull;
          break;
        case enum_1.Type.Bool:
          fn = visitor.visitBool;
          break;
        case enum_1.Type.Int:
          fn = visitor.visitInt;
          break;
        case enum_1.Type.Int8:
          fn = visitor.visitInt8 || visitor.visitInt;
          break;
        case enum_1.Type.Int16:
          fn = visitor.visitInt16 || visitor.visitInt;
          break;
        case enum_1.Type.Int32:
          fn = visitor.visitInt32 || visitor.visitInt;
          break;
        case enum_1.Type.Int64:
          fn = visitor.visitInt64 || visitor.visitInt;
          break;
        case enum_1.Type.Uint8:
          fn = visitor.visitUint8 || visitor.visitInt;
          break;
        case enum_1.Type.Uint16:
          fn = visitor.visitUint16 || visitor.visitInt;
          break;
        case enum_1.Type.Uint32:
          fn = visitor.visitUint32 || visitor.visitInt;
          break;
        case enum_1.Type.Uint64:
          fn = visitor.visitUint64 || visitor.visitInt;
          break;
        case enum_1.Type.Float:
          fn = visitor.visitFloat;
          break;
        case enum_1.Type.Float16:
          fn = visitor.visitFloat16 || visitor.visitFloat;
          break;
        case enum_1.Type.Float32:
          fn = visitor.visitFloat32 || visitor.visitFloat;
          break;
        case enum_1.Type.Float64:
          fn = visitor.visitFloat64 || visitor.visitFloat;
          break;
        case enum_1.Type.Utf8:
          fn = visitor.visitUtf8;
          break;
        case enum_1.Type.Binary:
          fn = visitor.visitBinary;
          break;
        case enum_1.Type.FixedSizeBinary:
          fn = visitor.visitFixedSizeBinary;
          break;
        case enum_1.Type.Date:
          fn = visitor.visitDate;
          break;
        case enum_1.Type.DateDay:
          fn = visitor.visitDateDay || visitor.visitDate;
          break;
        case enum_1.Type.DateMillisecond:
          fn = visitor.visitDateMillisecond || visitor.visitDate;
          break;
        case enum_1.Type.Timestamp:
          fn = visitor.visitTimestamp;
          break;
        case enum_1.Type.TimestampSecond:
          fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
          break;
        case enum_1.Type.TimestampMillisecond:
          fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
          break;
        case enum_1.Type.TimestampMicrosecond:
          fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
          break;
        case enum_1.Type.TimestampNanosecond:
          fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
          break;
        case enum_1.Type.Time:
          fn = visitor.visitTime;
          break;
        case enum_1.Type.TimeSecond:
          fn = visitor.visitTimeSecond || visitor.visitTime;
          break;
        case enum_1.Type.TimeMillisecond:
          fn = visitor.visitTimeMillisecond || visitor.visitTime;
          break;
        case enum_1.Type.TimeMicrosecond:
          fn = visitor.visitTimeMicrosecond || visitor.visitTime;
          break;
        case enum_1.Type.TimeNanosecond:
          fn = visitor.visitTimeNanosecond || visitor.visitTime;
          break;
        case enum_1.Type.Decimal:
          fn = visitor.visitDecimal;
          break;
        case enum_1.Type.List:
          fn = visitor.visitList;
          break;
        case enum_1.Type.Struct:
          fn = visitor.visitStruct;
          break;
        case enum_1.Type.Union:
          fn = visitor.visitUnion;
          break;
        case enum_1.Type.DenseUnion:
          fn = visitor.visitDenseUnion || visitor.visitUnion;
          break;
        case enum_1.Type.SparseUnion:
          fn = visitor.visitSparseUnion || visitor.visitUnion;
          break;
        case enum_1.Type.Dictionary:
          fn = visitor.visitDictionary;
          break;
        case enum_1.Type.Interval:
          fn = visitor.visitInterval;
          break;
        case enum_1.Type.IntervalDayTime:
          fn = visitor.visitIntervalDayTime || visitor.visitInterval;
          break;
        case enum_1.Type.IntervalYearMonth:
          fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
          break;
        case enum_1.Type.FixedSizeList:
          fn = visitor.visitFixedSizeList;
          break;
        case enum_1.Type.Map:
          fn = visitor.visitMap;
          break;
      }
      if (typeof fn === "function")
        return fn;
      if (!throwIfNotFound)
        return () => null;
      throw new Error(`Unrecognized type '${enum_1.Type[dtype]}'`);
    }
    function inferDType(type) {
      switch (type.typeId) {
        case enum_1.Type.Null:
          return enum_1.Type.Null;
        case enum_1.Type.Int:
          const { bitWidth, isSigned } = type;
          switch (bitWidth) {
            case 8:
              return isSigned ? enum_1.Type.Int8 : enum_1.Type.Uint8;
            case 16:
              return isSigned ? enum_1.Type.Int16 : enum_1.Type.Uint16;
            case 32:
              return isSigned ? enum_1.Type.Int32 : enum_1.Type.Uint32;
            case 64:
              return isSigned ? enum_1.Type.Int64 : enum_1.Type.Uint64;
          }
          return enum_1.Type.Int;
        case enum_1.Type.Float:
          switch (type.precision) {
            case enum_1.Precision.HALF:
              return enum_1.Type.Float16;
            case enum_1.Precision.SINGLE:
              return enum_1.Type.Float32;
            case enum_1.Precision.DOUBLE:
              return enum_1.Type.Float64;
          }
          return enum_1.Type.Float;
        case enum_1.Type.Binary:
          return enum_1.Type.Binary;
        case enum_1.Type.Utf8:
          return enum_1.Type.Utf8;
        case enum_1.Type.Bool:
          return enum_1.Type.Bool;
        case enum_1.Type.Decimal:
          return enum_1.Type.Decimal;
        case enum_1.Type.Time:
          switch (type.unit) {
            case enum_1.TimeUnit.SECOND:
              return enum_1.Type.TimeSecond;
            case enum_1.TimeUnit.MILLISECOND:
              return enum_1.Type.TimeMillisecond;
            case enum_1.TimeUnit.MICROSECOND:
              return enum_1.Type.TimeMicrosecond;
            case enum_1.TimeUnit.NANOSECOND:
              return enum_1.Type.TimeNanosecond;
          }
          return enum_1.Type.Time;
        case enum_1.Type.Timestamp:
          switch (type.unit) {
            case enum_1.TimeUnit.SECOND:
              return enum_1.Type.TimestampSecond;
            case enum_1.TimeUnit.MILLISECOND:
              return enum_1.Type.TimestampMillisecond;
            case enum_1.TimeUnit.MICROSECOND:
              return enum_1.Type.TimestampMicrosecond;
            case enum_1.TimeUnit.NANOSECOND:
              return enum_1.Type.TimestampNanosecond;
          }
          return enum_1.Type.Timestamp;
        case enum_1.Type.Date:
          switch (type.unit) {
            case enum_1.DateUnit.DAY:
              return enum_1.Type.DateDay;
            case enum_1.DateUnit.MILLISECOND:
              return enum_1.Type.DateMillisecond;
          }
          return enum_1.Type.Date;
        case enum_1.Type.Interval:
          switch (type.unit) {
            case enum_1.IntervalUnit.DAY_TIME:
              return enum_1.Type.IntervalDayTime;
            case enum_1.IntervalUnit.YEAR_MONTH:
              return enum_1.Type.IntervalYearMonth;
          }
          return enum_1.Type.Interval;
        case enum_1.Type.Map:
          return enum_1.Type.Map;
        case enum_1.Type.List:
          return enum_1.Type.List;
        case enum_1.Type.Struct:
          return enum_1.Type.Struct;
        case enum_1.Type.Union:
          switch (type.mode) {
            case enum_1.UnionMode.Dense:
              return enum_1.Type.DenseUnion;
            case enum_1.UnionMode.Sparse:
              return enum_1.Type.SparseUnion;
          }
          return enum_1.Type.Union;
        case enum_1.Type.FixedSizeBinary:
          return enum_1.Type.FixedSizeBinary;
        case enum_1.Type.FixedSizeList:
          return enum_1.Type.FixedSizeList;
        case enum_1.Type.Dictionary:
          return enum_1.Type.Dictionary;
      }
      throw new Error(`Unrecognized type '${enum_1.Type[type.typeId]}'`);
    }
    Visitor2.prototype.visitInt8 = null;
    Visitor2.prototype.visitInt16 = null;
    Visitor2.prototype.visitInt32 = null;
    Visitor2.prototype.visitInt64 = null;
    Visitor2.prototype.visitUint8 = null;
    Visitor2.prototype.visitUint16 = null;
    Visitor2.prototype.visitUint32 = null;
    Visitor2.prototype.visitUint64 = null;
    Visitor2.prototype.visitFloat16 = null;
    Visitor2.prototype.visitFloat32 = null;
    Visitor2.prototype.visitFloat64 = null;
    Visitor2.prototype.visitDateDay = null;
    Visitor2.prototype.visitDateMillisecond = null;
    Visitor2.prototype.visitTimestampSecond = null;
    Visitor2.prototype.visitTimestampMillisecond = null;
    Visitor2.prototype.visitTimestampMicrosecond = null;
    Visitor2.prototype.visitTimestampNanosecond = null;
    Visitor2.prototype.visitTimeSecond = null;
    Visitor2.prototype.visitTimeMillisecond = null;
    Visitor2.prototype.visitTimeMicrosecond = null;
    Visitor2.prototype.visitTimeNanosecond = null;
    Visitor2.prototype.visitDenseUnion = null;
    Visitor2.prototype.visitSparseUnion = null;
    Visitor2.prototype.visitIntervalDayTime = null;
    Visitor2.prototype.visitIntervalYearMonth = null;
  }
});

// node_modules/apache-arrow/visitor/typecomparator.js
var require_typecomparator = __commonJS({
  "node_modules/apache-arrow/visitor/typecomparator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var TypeComparator = class extends visitor_1.Visitor {
      compareSchemas(schema, other) {
        return schema === other || other instanceof schema.constructor && exports.instance.compareFields(schema.fields, other.fields);
      }
      compareFields(fields, others) {
        return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i) => exports.instance.compareField(f, others[i]));
      }
      compareField(field, other) {
        return field === other || other instanceof field.constructor && field.name === other.name && field.nullable === other.nullable && exports.instance.visit(field.type, other.type);
      }
    };
    exports.TypeComparator = TypeComparator;
    function compareConstructor(type, other) {
      return other instanceof type.constructor;
    }
    function compareAny(type, other) {
      return type === other || compareConstructor(type, other);
    }
    function compareInt(type, other) {
      return type === other || compareConstructor(type, other) && type.bitWidth === other.bitWidth && type.isSigned === other.isSigned;
    }
    function compareFloat(type, other) {
      return type === other || compareConstructor(type, other) && type.precision === other.precision;
    }
    function compareFixedSizeBinary(type, other) {
      return type === other || compareConstructor(type, other) && type.byteWidth === other.byteWidth;
    }
    function compareDate(type, other) {
      return type === other || compareConstructor(type, other) && type.unit === other.unit;
    }
    function compareTimestamp(type, other) {
      return type === other || compareConstructor(type, other) && type.unit === other.unit && type.timezone === other.timezone;
    }
    function compareTime(type, other) {
      return type === other || compareConstructor(type, other) && type.unit === other.unit && type.bitWidth === other.bitWidth;
    }
    function compareList(type, other) {
      return type === other || compareConstructor(type, other) && type.children.length === other.children.length && exports.instance.compareFields(type.children, other.children);
    }
    function compareStruct(type, other) {
      return type === other || compareConstructor(type, other) && type.children.length === other.children.length && exports.instance.compareFields(type.children, other.children);
    }
    function compareUnion(type, other) {
      return type === other || compareConstructor(type, other) && type.mode === other.mode && type.typeIds.every((x, i) => x === other.typeIds[i]) && exports.instance.compareFields(type.children, other.children);
    }
    function compareDictionary(type, other) {
      return type === other || compareConstructor(type, other) && type.id === other.id && type.isOrdered === other.isOrdered && exports.instance.visit(type.indices, other.indices) && exports.instance.visit(type.dictionary, other.dictionary);
    }
    function compareInterval(type, other) {
      return type === other || compareConstructor(type, other) && type.unit === other.unit;
    }
    function compareFixedSizeList(type, other) {
      return type === other || compareConstructor(type, other) && type.listSize === other.listSize && type.children.length === other.children.length && exports.instance.compareFields(type.children, other.children);
    }
    function compareMap(type, other) {
      return type === other || compareConstructor(type, other) && type.keysSorted === other.keysSorted && type.children.length === other.children.length && exports.instance.compareFields(type.children, other.children);
    }
    TypeComparator.prototype.visitNull = compareAny;
    TypeComparator.prototype.visitBool = compareAny;
    TypeComparator.prototype.visitInt = compareInt;
    TypeComparator.prototype.visitInt8 = compareInt;
    TypeComparator.prototype.visitInt16 = compareInt;
    TypeComparator.prototype.visitInt32 = compareInt;
    TypeComparator.prototype.visitInt64 = compareInt;
    TypeComparator.prototype.visitUint8 = compareInt;
    TypeComparator.prototype.visitUint16 = compareInt;
    TypeComparator.prototype.visitUint32 = compareInt;
    TypeComparator.prototype.visitUint64 = compareInt;
    TypeComparator.prototype.visitFloat = compareFloat;
    TypeComparator.prototype.visitFloat16 = compareFloat;
    TypeComparator.prototype.visitFloat32 = compareFloat;
    TypeComparator.prototype.visitFloat64 = compareFloat;
    TypeComparator.prototype.visitUtf8 = compareAny;
    TypeComparator.prototype.visitBinary = compareAny;
    TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
    TypeComparator.prototype.visitDate = compareDate;
    TypeComparator.prototype.visitDateDay = compareDate;
    TypeComparator.prototype.visitDateMillisecond = compareDate;
    TypeComparator.prototype.visitTimestamp = compareTimestamp;
    TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
    TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
    TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
    TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
    TypeComparator.prototype.visitTime = compareTime;
    TypeComparator.prototype.visitTimeSecond = compareTime;
    TypeComparator.prototype.visitTimeMillisecond = compareTime;
    TypeComparator.prototype.visitTimeMicrosecond = compareTime;
    TypeComparator.prototype.visitTimeNanosecond = compareTime;
    TypeComparator.prototype.visitDecimal = compareAny;
    TypeComparator.prototype.visitList = compareList;
    TypeComparator.prototype.visitStruct = compareStruct;
    TypeComparator.prototype.visitUnion = compareUnion;
    TypeComparator.prototype.visitDenseUnion = compareUnion;
    TypeComparator.prototype.visitSparseUnion = compareUnion;
    TypeComparator.prototype.visitDictionary = compareDictionary;
    TypeComparator.prototype.visitInterval = compareInterval;
    TypeComparator.prototype.visitIntervalDayTime = compareInterval;
    TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
    TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
    TypeComparator.prototype.visitMap = compareMap;
    exports.instance = new TypeComparator();
  }
});

// node_modules/apache-arrow/type.js
var require_type = __commonJS({
  "node_modules/apache-arrow/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typecomparator_1 = require_typecomparator();
    var enum_1 = require_enum();
    var DataType2 = class {
      /** @nocollapse */
      static isNull(x) {
        return x && x.typeId === enum_1.Type.Null;
      }
      /** @nocollapse */
      static isInt(x) {
        return x && x.typeId === enum_1.Type.Int;
      }
      /** @nocollapse */
      static isFloat(x) {
        return x && x.typeId === enum_1.Type.Float;
      }
      /** @nocollapse */
      static isBinary(x) {
        return x && x.typeId === enum_1.Type.Binary;
      }
      /** @nocollapse */
      static isUtf8(x) {
        return x && x.typeId === enum_1.Type.Utf8;
      }
      /** @nocollapse */
      static isBool(x) {
        return x && x.typeId === enum_1.Type.Bool;
      }
      /** @nocollapse */
      static isDecimal(x) {
        return x && x.typeId === enum_1.Type.Decimal;
      }
      /** @nocollapse */
      static isDate(x) {
        return x && x.typeId === enum_1.Type.Date;
      }
      /** @nocollapse */
      static isTime(x) {
        return x && x.typeId === enum_1.Type.Time;
      }
      /** @nocollapse */
      static isTimestamp(x) {
        return x && x.typeId === enum_1.Type.Timestamp;
      }
      /** @nocollapse */
      static isInterval(x) {
        return x && x.typeId === enum_1.Type.Interval;
      }
      /** @nocollapse */
      static isList(x) {
        return x && x.typeId === enum_1.Type.List;
      }
      /** @nocollapse */
      static isStruct(x) {
        return x && x.typeId === enum_1.Type.Struct;
      }
      /** @nocollapse */
      static isUnion(x) {
        return x && x.typeId === enum_1.Type.Union;
      }
      /** @nocollapse */
      static isFixedSizeBinary(x) {
        return x && x.typeId === enum_1.Type.FixedSizeBinary;
      }
      /** @nocollapse */
      static isFixedSizeList(x) {
        return x && x.typeId === enum_1.Type.FixedSizeList;
      }
      /** @nocollapse */
      static isMap(x) {
        return x && x.typeId === enum_1.Type.Map;
      }
      /** @nocollapse */
      static isDictionary(x) {
        return x && x.typeId === enum_1.Type.Dictionary;
      }
      get typeId() {
        return enum_1.Type.NONE;
      }
      compareTo(other) {
        return typecomparator_1.instance.visit(this, other);
      }
    };
    DataType2[Symbol.toStringTag] = ((proto) => {
      proto.children = null;
      proto.ArrayType = Array;
      return proto[Symbol.toStringTag] = "DataType";
    })(DataType2.prototype);
    exports.DataType = DataType2;
    var Null2 = class extends DataType2 {
      toString() {
        return `Null`;
      }
      get typeId() {
        return enum_1.Type.Null;
      }
    };
    Null2[Symbol.toStringTag] = ((proto) => {
      return proto[Symbol.toStringTag] = "Null";
    })(Null2.prototype);
    exports.Null = Null2;
    var Int_ = class extends DataType2 {
      constructor(isSigned, bitWidth) {
        super();
        this.isSigned = isSigned;
        this.bitWidth = bitWidth;
      }
      get typeId() {
        return enum_1.Type.Int;
      }
      get ArrayType() {
        switch (this.bitWidth) {
          case 8:
            return this.isSigned ? Int8Array : Uint8Array;
          case 16:
            return this.isSigned ? Int16Array : Uint16Array;
          case 32:
            return this.isSigned ? Int32Array : Uint32Array;
          case 64:
            return this.isSigned ? Int32Array : Uint32Array;
        }
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
      }
      toString() {
        return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
      }
    };
    Int_[Symbol.toStringTag] = ((proto) => {
      proto.isSigned = null;
      proto.bitWidth = null;
      return proto[Symbol.toStringTag] = "Int";
    })(Int_.prototype);
    exports.Int = Int_;
    var Int82 = class extends Int_ {
      constructor() {
        super(true, 8);
      }
    };
    exports.Int8 = Int82;
    var Int162 = class extends Int_ {
      constructor() {
        super(true, 16);
      }
    };
    exports.Int16 = Int162;
    var Int322 = class extends Int_ {
      constructor() {
        super(true, 32);
      }
    };
    exports.Int32 = Int322;
    var Int642 = class extends Int_ {
      constructor() {
        super(true, 64);
      }
    };
    exports.Int64 = Int642;
    var Uint82 = class extends Int_ {
      constructor() {
        super(false, 8);
      }
    };
    exports.Uint8 = Uint82;
    var Uint162 = class extends Int_ {
      constructor() {
        super(false, 16);
      }
    };
    exports.Uint16 = Uint162;
    var Uint322 = class extends Int_ {
      constructor() {
        super(false, 32);
      }
    };
    exports.Uint32 = Uint322;
    var Uint642 = class extends Int_ {
      constructor() {
        super(false, 64);
      }
    };
    exports.Uint64 = Uint642;
    Object.defineProperty(Int82.prototype, "ArrayType", { value: Int8Array });
    Object.defineProperty(Int162.prototype, "ArrayType", { value: Int16Array });
    Object.defineProperty(Int322.prototype, "ArrayType", { value: Int32Array });
    Object.defineProperty(Int642.prototype, "ArrayType", { value: Int32Array });
    Object.defineProperty(Uint82.prototype, "ArrayType", { value: Uint8Array });
    Object.defineProperty(Uint162.prototype, "ArrayType", { value: Uint16Array });
    Object.defineProperty(Uint322.prototype, "ArrayType", { value: Uint32Array });
    Object.defineProperty(Uint642.prototype, "ArrayType", { value: Uint32Array });
    var Float2 = class extends DataType2 {
      constructor(precision) {
        super();
        this.precision = precision;
      }
      get typeId() {
        return enum_1.Type.Float;
      }
      get ArrayType() {
        switch (this.precision) {
          case enum_1.Precision.HALF:
            return Uint16Array;
          case enum_1.Precision.SINGLE:
            return Float32Array;
          case enum_1.Precision.DOUBLE:
            return Float64Array;
        }
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
      }
      toString() {
        return `Float${this.precision << 5 || 16}`;
      }
    };
    Float2[Symbol.toStringTag] = ((proto) => {
      proto.precision = null;
      return proto[Symbol.toStringTag] = "Float";
    })(Float2.prototype);
    exports.Float = Float2;
    var Float162 = class extends Float2 {
      constructor() {
        super(enum_1.Precision.HALF);
      }
    };
    exports.Float16 = Float162;
    var Float322 = class extends Float2 {
      constructor() {
        super(enum_1.Precision.SINGLE);
      }
    };
    exports.Float32 = Float322;
    var Float642 = class extends Float2 {
      constructor() {
        super(enum_1.Precision.DOUBLE);
      }
    };
    exports.Float64 = Float642;
    Object.defineProperty(Float162.prototype, "ArrayType", { value: Uint16Array });
    Object.defineProperty(Float322.prototype, "ArrayType", { value: Float32Array });
    Object.defineProperty(Float642.prototype, "ArrayType", { value: Float64Array });
    var Binary2 = class extends DataType2 {
      constructor() {
        super();
      }
      get typeId() {
        return enum_1.Type.Binary;
      }
      toString() {
        return `Binary`;
      }
    };
    Binary2[Symbol.toStringTag] = ((proto) => {
      proto.ArrayType = Uint8Array;
      return proto[Symbol.toStringTag] = "Binary";
    })(Binary2.prototype);
    exports.Binary = Binary2;
    var Utf82 = class extends DataType2 {
      constructor() {
        super();
      }
      get typeId() {
        return enum_1.Type.Utf8;
      }
      toString() {
        return `Utf8`;
      }
    };
    Utf82[Symbol.toStringTag] = ((proto) => {
      proto.ArrayType = Uint8Array;
      return proto[Symbol.toStringTag] = "Utf8";
    })(Utf82.prototype);
    exports.Utf8 = Utf82;
    var Bool2 = class extends DataType2 {
      constructor() {
        super();
      }
      get typeId() {
        return enum_1.Type.Bool;
      }
      toString() {
        return `Bool`;
      }
    };
    Bool2[Symbol.toStringTag] = ((proto) => {
      proto.ArrayType = Uint8Array;
      return proto[Symbol.toStringTag] = "Bool";
    })(Bool2.prototype);
    exports.Bool = Bool2;
    var Decimal2 = class extends DataType2 {
      constructor(scale, precision) {
        super();
        this.scale = scale;
        this.precision = precision;
      }
      get typeId() {
        return enum_1.Type.Decimal;
      }
      toString() {
        return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;
      }
    };
    Decimal2[Symbol.toStringTag] = ((proto) => {
      proto.scale = null;
      proto.precision = null;
      proto.ArrayType = Uint32Array;
      return proto[Symbol.toStringTag] = "Decimal";
    })(Decimal2.prototype);
    exports.Decimal = Decimal2;
    var Date_2 = class extends DataType2 {
      constructor(unit) {
        super();
        this.unit = unit;
      }
      get typeId() {
        return enum_1.Type.Date;
      }
      toString() {
        return `Date${(this.unit + 1) * 32}<${enum_1.DateUnit[this.unit]}>`;
      }
    };
    Date_2[Symbol.toStringTag] = ((proto) => {
      proto.unit = null;
      proto.ArrayType = Int32Array;
      return proto[Symbol.toStringTag] = "Date";
    })(Date_2.prototype);
    exports.Date_ = Date_2;
    var DateDay2 = class extends Date_2 {
      constructor() {
        super(enum_1.DateUnit.DAY);
      }
    };
    exports.DateDay = DateDay2;
    var DateMillisecond2 = class extends Date_2 {
      constructor() {
        super(enum_1.DateUnit.MILLISECOND);
      }
    };
    exports.DateMillisecond = DateMillisecond2;
    var Time_ = class extends DataType2 {
      constructor(unit, bitWidth) {
        super();
        this.unit = unit;
        this.bitWidth = bitWidth;
      }
      get typeId() {
        return enum_1.Type.Time;
      }
      toString() {
        return `Time${this.bitWidth}<${enum_1.TimeUnit[this.unit]}>`;
      }
    };
    Time_[Symbol.toStringTag] = ((proto) => {
      proto.unit = null;
      proto.bitWidth = null;
      proto.ArrayType = Int32Array;
      return proto[Symbol.toStringTag] = "Time";
    })(Time_.prototype);
    exports.Time = Time_;
    var TimeSecond2 = class extends Time_ {
      constructor() {
        super(enum_1.TimeUnit.SECOND, 32);
      }
    };
    exports.TimeSecond = TimeSecond2;
    var TimeMillisecond2 = class extends Time_ {
      constructor() {
        super(enum_1.TimeUnit.MILLISECOND, 32);
      }
    };
    exports.TimeMillisecond = TimeMillisecond2;
    var TimeMicrosecond2 = class extends Time_ {
      constructor() {
        super(enum_1.TimeUnit.MICROSECOND, 64);
      }
    };
    exports.TimeMicrosecond = TimeMicrosecond2;
    var TimeNanosecond2 = class extends Time_ {
      constructor() {
        super(enum_1.TimeUnit.NANOSECOND, 64);
      }
    };
    exports.TimeNanosecond = TimeNanosecond2;
    var Timestamp_ = class extends DataType2 {
      constructor(unit, timezone) {
        super();
        this.unit = unit;
        this.timezone = timezone;
      }
      get typeId() {
        return enum_1.Type.Timestamp;
      }
      toString() {
        return `Timestamp<${enum_1.TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
      }
    };
    Timestamp_[Symbol.toStringTag] = ((proto) => {
      proto.unit = null;
      proto.timezone = null;
      proto.ArrayType = Int32Array;
      return proto[Symbol.toStringTag] = "Timestamp";
    })(Timestamp_.prototype);
    exports.Timestamp = Timestamp_;
    var TimestampSecond2 = class extends Timestamp_ {
      constructor(timezone) {
        super(enum_1.TimeUnit.SECOND, timezone);
      }
    };
    exports.TimestampSecond = TimestampSecond2;
    var TimestampMillisecond2 = class extends Timestamp_ {
      constructor(timezone) {
        super(enum_1.TimeUnit.MILLISECOND, timezone);
      }
    };
    exports.TimestampMillisecond = TimestampMillisecond2;
    var TimestampMicrosecond2 = class extends Timestamp_ {
      constructor(timezone) {
        super(enum_1.TimeUnit.MICROSECOND, timezone);
      }
    };
    exports.TimestampMicrosecond = TimestampMicrosecond2;
    var TimestampNanosecond2 = class extends Timestamp_ {
      constructor(timezone) {
        super(enum_1.TimeUnit.NANOSECOND, timezone);
      }
    };
    exports.TimestampNanosecond = TimestampNanosecond2;
    var Interval_ = class extends DataType2 {
      constructor(unit) {
        super();
        this.unit = unit;
      }
      get typeId() {
        return enum_1.Type.Interval;
      }
      toString() {
        return `Interval<${enum_1.IntervalUnit[this.unit]}>`;
      }
    };
    Interval_[Symbol.toStringTag] = ((proto) => {
      proto.unit = null;
      proto.ArrayType = Int32Array;
      return proto[Symbol.toStringTag] = "Interval";
    })(Interval_.prototype);
    exports.Interval = Interval_;
    var IntervalDayTime2 = class extends Interval_ {
      constructor() {
        super(enum_1.IntervalUnit.DAY_TIME);
      }
    };
    exports.IntervalDayTime = IntervalDayTime2;
    var IntervalYearMonth2 = class extends Interval_ {
      constructor() {
        super(enum_1.IntervalUnit.YEAR_MONTH);
      }
    };
    exports.IntervalYearMonth = IntervalYearMonth2;
    var List2 = class extends DataType2 {
      constructor(child) {
        super();
        this.children = [child];
      }
      get typeId() {
        return enum_1.Type.List;
      }
      toString() {
        return `List<${this.valueType}>`;
      }
      get valueType() {
        return this.children[0].type;
      }
      get valueField() {
        return this.children[0];
      }
      get ArrayType() {
        return this.valueType.ArrayType;
      }
    };
    List2[Symbol.toStringTag] = ((proto) => {
      proto.children = null;
      return proto[Symbol.toStringTag] = "List";
    })(List2.prototype);
    exports.List = List2;
    var Struct2 = class extends DataType2 {
      constructor(children) {
        super();
        this.children = children;
      }
      get typeId() {
        return enum_1.Type.Struct;
      }
      toString() {
        return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
      }
    };
    Struct2[Symbol.toStringTag] = ((proto) => {
      proto.children = null;
      return proto[Symbol.toStringTag] = "Struct";
    })(Struct2.prototype);
    exports.Struct = Struct2;
    var Union_ = class extends DataType2 {
      constructor(mode, typeIds, children) {
        super();
        this.mode = mode;
        this.children = children;
        this.typeIds = typeIds = Int32Array.from(typeIds);
        this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => {
          return (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex;
        }, /* @__PURE__ */ Object.create(null));
      }
      get typeId() {
        return enum_1.Type.Union;
      }
      toString() {
        return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;
      }
    };
    Union_[Symbol.toStringTag] = ((proto) => {
      proto.mode = null;
      proto.typeIds = null;
      proto.children = null;
      proto.typeIdToChildIndex = null;
      proto.ArrayType = Int8Array;
      return proto[Symbol.toStringTag] = "Union";
    })(Union_.prototype);
    exports.Union = Union_;
    var DenseUnion2 = class extends Union_ {
      constructor(typeIds, children) {
        super(enum_1.UnionMode.Dense, typeIds, children);
      }
    };
    exports.DenseUnion = DenseUnion2;
    var SparseUnion2 = class extends Union_ {
      constructor(typeIds, children) {
        super(enum_1.UnionMode.Sparse, typeIds, children);
      }
    };
    exports.SparseUnion = SparseUnion2;
    var FixedSizeBinary2 = class extends DataType2 {
      constructor(byteWidth) {
        super();
        this.byteWidth = byteWidth;
      }
      get typeId() {
        return enum_1.Type.FixedSizeBinary;
      }
      toString() {
        return `FixedSizeBinary[${this.byteWidth}]`;
      }
    };
    FixedSizeBinary2[Symbol.toStringTag] = ((proto) => {
      proto.byteWidth = null;
      proto.ArrayType = Uint8Array;
      return proto[Symbol.toStringTag] = "FixedSizeBinary";
    })(FixedSizeBinary2.prototype);
    exports.FixedSizeBinary = FixedSizeBinary2;
    var FixedSizeList2 = class extends DataType2 {
      constructor(listSize, child) {
        super();
        this.listSize = listSize;
        this.children = [child];
      }
      get typeId() {
        return enum_1.Type.FixedSizeList;
      }
      get valueType() {
        return this.children[0].type;
      }
      get valueField() {
        return this.children[0];
      }
      get ArrayType() {
        return this.valueType.ArrayType;
      }
      toString() {
        return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
      }
    };
    FixedSizeList2[Symbol.toStringTag] = ((proto) => {
      proto.children = null;
      proto.listSize = null;
      return proto[Symbol.toStringTag] = "FixedSizeList";
    })(FixedSizeList2.prototype);
    exports.FixedSizeList = FixedSizeList2;
    var Map_2 = class extends DataType2 {
      constructor(child, keysSorted = false) {
        super();
        this.children = [child];
        this.keysSorted = keysSorted;
      }
      get typeId() {
        return enum_1.Type.Map;
      }
      get keyType() {
        return this.children[0].type.children[0].type;
      }
      get valueType() {
        return this.children[0].type.children[1].type;
      }
      toString() {
        return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
      }
    };
    Map_2[Symbol.toStringTag] = ((proto) => {
      proto.children = null;
      proto.keysSorted = null;
      return proto[Symbol.toStringTag] = "Map_";
    })(Map_2.prototype);
    exports.Map_ = Map_2;
    var getId = /* @__PURE__ */ ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
    var Dictionary2 = class extends DataType2 {
      constructor(dictionary, indices, id, isOrdered) {
        super();
        this.indices = indices;
        this.dictionary = dictionary;
        this.isOrdered = isOrdered || false;
        this.id = id == null ? getId() : typeof id === "number" ? id : id.low;
      }
      get typeId() {
        return enum_1.Type.Dictionary;
      }
      get children() {
        return this.dictionary.children;
      }
      get valueType() {
        return this.dictionary;
      }
      get ArrayType() {
        return this.dictionary.ArrayType;
      }
      toString() {
        return `Dictionary<${this.indices}, ${this.dictionary}>`;
      }
    };
    Dictionary2[Symbol.toStringTag] = ((proto) => {
      proto.id = null;
      proto.indices = null;
      proto.isOrdered = null;
      proto.dictionary = null;
      return proto[Symbol.toStringTag] = "Dictionary";
    })(Dictionary2.prototype);
    exports.Dictionary = Dictionary2;
    function strideForType(type) {
      let t = type;
      switch (type.typeId) {
        case enum_1.Type.Decimal:
          return 4;
        case enum_1.Type.Timestamp:
          return 2;
        case enum_1.Type.Date:
          return 1 + t.unit;
        case enum_1.Type.Interval:
          return 1 + t.unit;
        case enum_1.Type.Int:
          return 1 + +(t.bitWidth > 32);
        case enum_1.Type.Time:
          return 1 + +(t.bitWidth > 32);
        case enum_1.Type.FixedSizeList:
          return t.listSize;
        case enum_1.Type.FixedSizeBinary:
          return t.byteWidth;
        default:
          return 1;
      }
    }
    exports.strideForType = strideForType;
  }
});

// node_modules/apache-arrow/data.js
var require_data = __commonJS({
  "node_modules/apache-arrow/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bit_1 = require_bit();
    var bit_2 = require_bit();
    var enum_1 = require_enum();
    var type_1 = require_type();
    var buffer_1 = require_buffer();
    exports.kUnknownNullCount = -1;
    var Data2 = class _Data {
      constructor(type, offset, length, nullCount, buffers, childData, dictionary) {
        this.type = type;
        this.dictionary = dictionary;
        this.offset = Math.floor(Math.max(offset || 0, 0));
        this.length = Math.floor(Math.max(length || 0, 0));
        this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
        this.childData = (childData || []).map((x) => x instanceof _Data ? x : x.data);
        let buffer;
        if (buffers instanceof _Data) {
          this.stride = buffers.stride;
          this.values = buffers.values;
          this.typeIds = buffers.typeIds;
          this.nullBitmap = buffers.nullBitmap;
          this.valueOffsets = buffers.valueOffsets;
        } else {
          this.stride = type_1.strideForType(type);
          if (buffers) {
            (buffer = buffers[0]) && (this.valueOffsets = buffer);
            (buffer = buffers[1]) && (this.values = buffer);
            (buffer = buffers[2]) && (this.nullBitmap = buffer);
            (buffer = buffers[3]) && (this.typeIds = buffer);
          }
        }
      }
      get typeId() {
        return this.type.typeId;
      }
      get ArrayType() {
        return this.type.ArrayType;
      }
      get buffers() {
        return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
      }
      get byteLength() {
        let byteLength = 0;
        let { valueOffsets, values, nullBitmap, typeIds } = this;
        valueOffsets && (byteLength += valueOffsets.byteLength);
        values && (byteLength += values.byteLength);
        nullBitmap && (byteLength += nullBitmap.byteLength);
        typeIds && (byteLength += typeIds.byteLength);
        return this.childData.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);
      }
      get nullCount() {
        let nullCount = this._nullCount;
        let nullBitmap;
        if (nullCount <= exports.kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
          this._nullCount = nullCount = this.length - bit_2.popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);
        }
        return nullCount;
      }
      clone(type, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, childData = this.childData) {
        return new _Data(type, offset, length, nullCount, buffers, childData, this.dictionary);
      }
      slice(offset, length) {
        const { stride, typeId, childData } = this;
        const nullCount = +(this._nullCount === 0) - 1;
        const childStride = typeId === 16 ? stride : 1;
        const buffers = this._sliceBuffers(offset, length, stride, typeId);
        return this.clone(
          this.type,
          this.offset + offset,
          length,
          nullCount,
          buffers,
          // Don't slice children if we have value offsets (the variable-width types)
          !childData.length || this.valueOffsets ? childData : this._sliceChildren(childData, childStride * offset, childStride * length)
        );
      }
      _changeLengthAndBackfillNullBitmap(newLength) {
        if (this.typeId === enum_1.Type.Null) {
          return this.clone(this.type, 0, newLength, 0);
        }
        const { length, nullCount } = this;
        const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length >> 3);
        bitmap[length >> 3] = (1 << length - (length & ~7)) - 1;
        if (nullCount > 0) {
          bitmap.set(bit_1.truncateBitmap(this.offset, length, this.nullBitmap), 0);
        }
        const buffers = this.buffers;
        buffers[enum_1.BufferType.VALIDITY] = bitmap;
        return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);
      }
      _sliceBuffers(offset, length, stride, typeId) {
        let arr, { buffers } = this;
        (arr = buffers[enum_1.BufferType.TYPE]) && (buffers[enum_1.BufferType.TYPE] = arr.subarray(offset, offset + length));
        (arr = buffers[enum_1.BufferType.OFFSET]) && (buffers[enum_1.BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
        (arr = buffers[enum_1.BufferType.DATA]) && (buffers[enum_1.BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));
        return buffers;
      }
      _sliceChildren(childData, offset, length) {
        return childData.map((child) => child.slice(offset, length));
      }
      //
      // Convenience methods for creating Data instances for each of the Arrow Vector types
      //
      /** @nocollapse */
      static new(type, offset, length, nullCount, buffers, childData, dictionary) {
        if (buffers instanceof _Data) {
          buffers = buffers.buffers;
        } else if (!buffers) {
          buffers = [];
        }
        switch (type.typeId) {
          case enum_1.Type.Null:
            return _Data.Null(type, offset, length);
          case enum_1.Type.Int:
            return _Data.Int(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Dictionary:
            return _Data.Dictionary(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || [], dictionary);
          case enum_1.Type.Float:
            return _Data.Float(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Bool:
            return _Data.Bool(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Decimal:
            return _Data.Decimal(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Date:
            return _Data.Date(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Time:
            return _Data.Time(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Timestamp:
            return _Data.Timestamp(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Interval:
            return _Data.Interval(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.FixedSizeBinary:
            return _Data.FixedSizeBinary(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Binary:
            return _Data.Binary(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.OFFSET] || [], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Utf8:
            return _Data.Utf8(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.OFFSET] || [], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.List:
            return _Data.List(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.OFFSET] || [], (childData || [])[0]);
          case enum_1.Type.FixedSizeList:
            return _Data.FixedSizeList(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], (childData || [])[0]);
          case enum_1.Type.Struct:
            return _Data.Struct(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], childData || []);
          case enum_1.Type.Map:
            return _Data.Map(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.OFFSET] || [], (childData || [])[0]);
          case enum_1.Type.Union:
            return _Data.Union(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.TYPE] || [], buffers[enum_1.BufferType.OFFSET] || childData, childData);
        }
        throw new Error(`Unrecognized typeId ${type.typeId}`);
      }
      /** @nocollapse */
      static Null(type, offset, length) {
        return new _Data(type, offset, length, 0);
      }
      /** @nocollapse */
      static Int(type, offset, length, nullCount, nullBitmap, data) {
        return new _Data(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      /** @nocollapse */
      static Dictionary(type, offset, length, nullCount, nullBitmap, data, dictionary) {
        return new _Data(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.indices.ArrayType, data), buffer_1.toUint8Array(nullBitmap)], [], dictionary);
      }
      /** @nocollapse */
      static Float(type, offset, length, nullCount, nullBitmap, data) {
        return new _Data(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      /** @nocollapse */
      static Bool(type, offset, length, nullCount, nullBitmap, data) {
        return new _Data(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      /** @nocollapse */
      static Decimal(type, offset, length, nullCount, nullBitmap, data) {
        return new _Data(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      /** @nocollapse */
      static Date(type, offset, length, nullCount, nullBitmap, data) {
        return new _Data(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      /** @nocollapse */
      static Time(type, offset, length, nullCount, nullBitmap, data) {
        return new _Data(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      /** @nocollapse */
      static Timestamp(type, offset, length, nullCount, nullBitmap, data) {
        return new _Data(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      /** @nocollapse */
      static Interval(type, offset, length, nullCount, nullBitmap, data) {
        return new _Data(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      /** @nocollapse */
      static FixedSizeBinary(type, offset, length, nullCount, nullBitmap, data) {
        return new _Data(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      /** @nocollapse */
      static Binary(type, offset, length, nullCount, nullBitmap, valueOffsets, data) {
        return new _Data(type, offset, length, nullCount, [buffer_1.toInt32Array(valueOffsets), buffer_1.toUint8Array(data), buffer_1.toUint8Array(nullBitmap)]);
      }
      /** @nocollapse */
      static Utf8(type, offset, length, nullCount, nullBitmap, valueOffsets, data) {
        return new _Data(type, offset, length, nullCount, [buffer_1.toInt32Array(valueOffsets), buffer_1.toUint8Array(data), buffer_1.toUint8Array(nullBitmap)]);
      }
      /** @nocollapse */
      static List(type, offset, length, nullCount, nullBitmap, valueOffsets, child) {
        return new _Data(type, offset, length, nullCount, [buffer_1.toInt32Array(valueOffsets), void 0, buffer_1.toUint8Array(nullBitmap)], [child]);
      }
      /** @nocollapse */
      static FixedSizeList(type, offset, length, nullCount, nullBitmap, child) {
        return new _Data(type, offset, length, nullCount, [void 0, void 0, buffer_1.toUint8Array(nullBitmap)], [child]);
      }
      /** @nocollapse */
      static Struct(type, offset, length, nullCount, nullBitmap, children) {
        return new _Data(type, offset, length, nullCount, [void 0, void 0, buffer_1.toUint8Array(nullBitmap)], children);
      }
      /** @nocollapse */
      static Map(type, offset, length, nullCount, nullBitmap, valueOffsets, child) {
        return new _Data(type, offset, length, nullCount, [buffer_1.toInt32Array(valueOffsets), void 0, buffer_1.toUint8Array(nullBitmap)], [child]);
      }
      /** @nocollapse */
      static Union(type, offset, length, nullCount, nullBitmap, typeIds, valueOffsetsOrChildren, children) {
        const buffers = [
          void 0,
          void 0,
          buffer_1.toUint8Array(nullBitmap),
          buffer_1.toArrayBufferView(type.ArrayType, typeIds)
        ];
        if (type.mode === enum_1.UnionMode.Sparse) {
          return new _Data(type, offset, length, nullCount, buffers, valueOffsetsOrChildren);
        }
        buffers[enum_1.BufferType.OFFSET] = buffer_1.toInt32Array(valueOffsetsOrChildren);
        return new _Data(type, offset, length, nullCount, buffers, children);
      }
    };
    exports.Data = Data2;
    Data2.prototype.childData = Object.freeze([]);
  }
});

// node_modules/apache-arrow/util/pretty.js
var require_pretty = __commonJS({
  "node_modules/apache-arrow/util/pretty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var undf = void 0;
    function valueToString(x) {
      if (x === null) {
        return "null";
      }
      if (x === undf) {
        return "undefined";
      }
      switch (typeof x) {
        case "number":
          return `${x}`;
        case "bigint":
          return `${x}`;
        case "string":
          return `"${x}"`;
      }
      if (typeof x[Symbol.toPrimitive] === "function") {
        return x[Symbol.toPrimitive]("string");
      }
      return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x);
    }
    exports.valueToString = valueToString;
  }
});

// node_modules/apache-arrow/builder/valid.js
var require_valid = __commonJS({
  "node_modules/apache-arrow/builder/valid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pretty_1 = require_pretty();
    var compat_1 = require_compat();
    function createIsValidFunction(nullValues) {
      if (!nullValues || nullValues.length <= 0) {
        return function isValid(value) {
          return true;
        };
      }
      let fnBody = "";
      let noNaNs = nullValues.filter((x) => x === x);
      if (noNaNs.length > 0) {
        fnBody = `
    switch (x) {${noNaNs.map((x) => `
        case ${valueToCase(x)}:`).join("")}
            return false;
    }`;
      }
      if (nullValues.length !== noNaNs.length) {
        fnBody = `if (x !== x) return false;
${fnBody}`;
      }
      return new Function(`x`, `${fnBody}
return true;`);
    }
    exports.createIsValidFunction = createIsValidFunction;
    function valueToCase(x) {
      if (typeof x !== "bigint") {
        return pretty_1.valueToString(x);
      } else if (compat_1.BigIntAvailable) {
        return `${pretty_1.valueToString(x)}n`;
      }
      return `"${pretty_1.valueToString(x)}"`;
    }
  }
});

// node_modules/apache-arrow/builder/buffer.js
var require_buffer2 = __commonJS({
  "node_modules/apache-arrow/builder/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    var compat_1 = require_compat();
    var roundLengthUpToNearest64Bytes = (len, BPE) => (len * BPE + 63 & ~63 || 64) / BPE;
    var sliceOrExtendArray = (arr, len = 0) => arr.length >= len ? arr.subarray(0, len) : buffer_1.memcpy(new arr.constructor(len), arr, 0);
    var BufferBuilder = class {
      constructor(buffer, stride = 1) {
        this.buffer = buffer;
        this.stride = stride;
        this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;
        this.ArrayType = buffer.constructor;
        this._resize(this.length = buffer.length / stride | 0);
      }
      get byteLength() {
        return this.length * this.stride * this.BYTES_PER_ELEMENT | 0;
      }
      get reservedLength() {
        return this.buffer.length / this.stride;
      }
      get reservedByteLength() {
        return this.buffer.byteLength;
      }
      // @ts-ignore
      set(index, value) {
        return this;
      }
      append(value) {
        return this.set(this.length, value);
      }
      reserve(extra) {
        if (extra > 0) {
          this.length += extra;
          const stride = this.stride;
          const length = this.length * stride;
          const reserved = this.buffer.length;
          if (length >= reserved) {
            this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length * 2, this.BYTES_PER_ELEMENT));
          }
        }
        return this;
      }
      flush(length = this.length) {
        length = roundLengthUpToNearest64Bytes(length * this.stride, this.BYTES_PER_ELEMENT);
        const array = sliceOrExtendArray(this.buffer, length);
        this.clear();
        return array;
      }
      clear() {
        this.length = 0;
        this._resize(0);
        return this;
      }
      _resize(newLength) {
        return this.buffer = buffer_1.memcpy(new this.ArrayType(newLength), this.buffer);
      }
    };
    exports.BufferBuilder = BufferBuilder;
    BufferBuilder.prototype.offset = 0;
    var DataBufferBuilder = class extends BufferBuilder {
      last() {
        return this.get(this.length - 1);
      }
      get(index) {
        return this.buffer[index];
      }
      set(index, value) {
        this.reserve(index - this.length + 1);
        this.buffer[index * this.stride] = value;
        return this;
      }
    };
    exports.DataBufferBuilder = DataBufferBuilder;
    var BitmapBufferBuilder = class extends DataBufferBuilder {
      constructor(data = new Uint8Array(0)) {
        super(data, 1 / 8);
        this.numValid = 0;
      }
      get numInvalid() {
        return this.length - this.numValid;
      }
      get(idx) {
        return this.buffer[idx >> 3] >> idx % 8 & 1;
      }
      set(idx, val) {
        const { buffer } = this.reserve(idx - this.length + 1);
        const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;
        val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);
        return this;
      }
      clear() {
        this.numValid = 0;
        return super.clear();
      }
    };
    exports.BitmapBufferBuilder = BitmapBufferBuilder;
    var OffsetsBufferBuilder = class extends DataBufferBuilder {
      constructor(data = new Int32Array(1)) {
        super(data, 1);
      }
      append(value) {
        return this.set(this.length - 1, value);
      }
      set(index, value) {
        const offset = this.length - 1;
        const buffer = this.reserve(index - offset + 1).buffer;
        if (offset < index++) {
          buffer.fill(buffer[offset], offset, index);
        }
        buffer[index] = buffer[index - 1] + value;
        return this;
      }
      flush(length = this.length - 1) {
        if (length > this.length) {
          this.set(length - 1, 0);
        }
        return super.flush(length + 1);
      }
    };
    exports.OffsetsBufferBuilder = OffsetsBufferBuilder;
    var WideBufferBuilder = class extends BufferBuilder {
      get ArrayType64() {
        return this._ArrayType64 || (this._ArrayType64 = this.buffer instanceof Int32Array ? compat_1.BigInt64Array : compat_1.BigUint64Array);
      }
      set(index, value) {
        this.reserve(index - this.length + 1);
        switch (typeof value) {
          case "bigint":
            this.buffer64[index] = value;
            break;
          case "number":
            this.buffer[index * this.stride] = value;
            break;
          default:
            this.buffer.set(value, index * this.stride);
        }
        return this;
      }
      _resize(newLength) {
        const data = super._resize(newLength);
        const length = data.byteLength / (this.BYTES_PER_ELEMENT * this.stride);
        if (compat_1.BigIntAvailable) {
          this.buffer64 = new this.ArrayType64(data.buffer, data.byteOffset, length);
        }
        return data;
      }
    };
    exports.WideBufferBuilder = WideBufferBuilder;
  }
});

// node_modules/apache-arrow/builder.js
var require_builder = __commonJS({
  "node_modules/apache-arrow/builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var enum_1 = require_enum();
    var data_1 = require_data();
    var valid_1 = require_valid();
    var buffer_1 = require_buffer2();
    var type_1 = require_type();
    var Builder3 = class {
      /**
       * Construct a builder with the given Arrow DataType with optional null values,
       * which will be interpreted as "null" when set or appended to the `Builder`.
       * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.
       */
      constructor({ "type": type, "nullValues": nulls }) {
        this.length = 0;
        this.finished = false;
        this.type = type;
        this.children = [];
        this.nullValues = nulls;
        this.stride = type_1.strideForType(type);
        this._nulls = new buffer_1.BitmapBufferBuilder();
        if (nulls && nulls.length > 0) {
          this._isValid = valid_1.createIsValidFunction(nulls);
        }
      }
      /**
       * Create a `Builder` instance based on the `type` property of the supplied `options` object.
       * @param {BuilderOptions<T, TNull>} options An object with a required `DataType` instance
       * and other optional parameters to be passed to the `Builder` subclass for the given `type`.
       *
       * @typeparam T The `DataType` of the `Builder` to create.
       * @typeparam TNull The type(s) of values which will be considered null-value sentinels.
       * @nocollapse
       */
      // @ts-ignore
      static new(options) {
      }
      /** @nocollapse */
      // @ts-ignore
      static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
      }
      /** @nocollapse */
      // @ts-ignore
      static throughDOM(options) {
        throw new Error(`"throughDOM" not available in this environment`);
      }
      /**
       * Transform a synchronous `Iterable` of arbitrary JavaScript values into a
       * sequence of Arrow Vector<T> following the chunking semantics defined in
       * the supplied `options` argument.
       *
       * This function returns a function that accepts an `Iterable` of values to
       * transform. When called, this function returns an Iterator of `Vector<T>`.
       *
       * The resulting `Iterator<Vector<T>>` yields Vectors based on the
       * `queueingStrategy` and `highWaterMark` specified in the `options` argument.
       *
       * * If `queueingStrategy` is `"count"` (or omitted), The `Iterator<Vector<T>>`
       *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the
       *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.
       * * If `queueingStrategy` is `"bytes"`, the `Iterator<Vector<T>>` will flush
       *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`
       *   reaches or exceeds the supplied `highWaterMark`.
       *
       * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.
       * @returns A function which accepts a JavaScript `Iterable` of values to
       *          write, and returns an `Iterator` that yields Vectors according
       *          to the chunking semantics defined in the `options` argument.
       * @nocollapse
       */
      static throughIterable(options) {
        return throughIterable(options);
      }
      /**
       * Transform an `AsyncIterable` of arbitrary JavaScript values into a
       * sequence of Arrow Vector<T> following the chunking semantics defined in
       * the supplied `options` argument.
       *
       * This function returns a function that accepts an `AsyncIterable` of values to
       * transform. When called, this function returns an AsyncIterator of `Vector<T>`.
       *
       * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the
       * `queueingStrategy` and `highWaterMark` specified in the `options` argument.
       *
       * * If `queueingStrategy` is `"count"` (or omitted), The `AsyncIterator<Vector<T>>`
       *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the
       *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.
       * * If `queueingStrategy` is `"bytes"`, the `AsyncIterator<Vector<T>>` will flush
       *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`
       *   reaches or exceeds the supplied `highWaterMark`.
       *
       * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.
       * @returns A function which accepts a JavaScript `AsyncIterable` of values
       *          to write, and returns an `AsyncIterator` that yields Vectors
       *          according to the chunking semantics defined in the `options`
       *          argument.
       * @nocollapse
       */
      static throughAsyncIterable(options) {
        return throughAsyncIterable(options);
      }
      /**
       * Flush the `Builder` and return a `Vector<T>`.
       * @returns {Vector<T>} A `Vector<T>` of the flushed values.
       */
      toVector() {
        return vector_1.Vector.new(this.flush());
      }
      get ArrayType() {
        return this.type.ArrayType;
      }
      get nullCount() {
        return this._nulls.numInvalid;
      }
      get numChildren() {
        return this.children.length;
      }
      /**
       * @returns The aggregate length (in bytes) of the values that have been written.
       */
      get byteLength() {
        let size = 0;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        this._typeIds && (size += this._typeIds.byteLength);
        return this.children.reduce((size2, child) => size2 + child.byteLength, size);
      }
      /**
       * @returns The aggregate number of rows that have been reserved to write new values.
       */
      get reservedLength() {
        return this._nulls.reservedLength;
      }
      /**
       * @returns The aggregate length (in bytes) that has been reserved to write new values.
       */
      get reservedByteLength() {
        let size = 0;
        this._offsets && (size += this._offsets.reservedByteLength);
        this._values && (size += this._values.reservedByteLength);
        this._nulls && (size += this._nulls.reservedByteLength);
        this._typeIds && (size += this._typeIds.reservedByteLength);
        return this.children.reduce((size2, child) => size2 + child.reservedByteLength, size);
      }
      get valueOffsets() {
        return this._offsets ? this._offsets.buffer : null;
      }
      get values() {
        return this._values ? this._values.buffer : null;
      }
      get nullBitmap() {
        return this._nulls ? this._nulls.buffer : null;
      }
      get typeIds() {
        return this._typeIds ? this._typeIds.buffer : null;
      }
      /**
       * Appends a value (or null) to this `Builder`.
       * This is equivalent to `builder.set(builder.length, value)`.
       * @param {T['TValue'] | TNull } value The value to append.
       */
      append(value) {
        return this.set(this.length, value);
      }
      /**
       * Validates whether a value is valid (true), or null (false)
       * @param {T['TValue'] | TNull } value The value to compare against null the value representations
       */
      // @ts-ignore
      isValid(value) {
        return this._isValid(value);
      }
      /**
       * Write a value (or null-value sentinel) at the supplied index.
       * If the value matches one of the null-value representations, a 1-bit is
       * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to
       * the null `BitmapBufferBuilder`, and the value is passed to
       * `Builder.prototype.setValue()`.
       * @param {number} index The index of the value to write.
       * @param {T['TValue'] | TNull } value The value to write at the supplied index.
       * @returns {this} The updated `Builder` instance.
       */
      set(index, value) {
        if (this.setValid(index, this.isValid(value))) {
          this.setValue(index, value);
        }
        return this;
      }
      /**
       * Write a value to the underlying buffers at the supplied index, bypassing
       * the null-value check. This is a low-level method that
       * @param {number} index
       * @param {T['TValue'] | TNull } value
       */
      // @ts-ignore
      setValue(index, value) {
        this._setValue(this, index, value);
      }
      setValid(index, valid) {
        this.length = this._nulls.set(index, +valid).length;
        return valid;
      }
      // @ts-ignore
      addChild(child, name = `${this.numChildren}`) {
        throw new Error(`Cannot append children to non-nested type "${this.type}"`);
      }
      /**
       * Retrieve the child `Builder` at the supplied `index`, or null if no child
       * exists at that index.
       * @param {number} index The index of the child `Builder` to retrieve.
       * @returns {Builder | null} The child Builder at the supplied index or null.
       */
      getChildAt(index) {
        return this.children[index] || null;
      }
      /**
       * Commit all the values that have been written to their underlying
       * ArrayBuffers, including any child Builders if applicable, and reset
       * the internal `Builder` state.
       * @returns A `Data<T>` of the buffers and childData representing the values written.
       */
      flush() {
        const buffers = [];
        const values = this._values;
        const offsets = this._offsets;
        const typeIds = this._typeIds;
        const { length, nullCount } = this;
        if (typeIds) {
          buffers[enum_1.BufferType.TYPE] = typeIds.flush(length);
          offsets && (buffers[enum_1.BufferType.OFFSET] = offsets.flush(length));
        } else if (offsets) {
          values && (buffers[enum_1.BufferType.DATA] = values.flush(offsets.last()));
          buffers[enum_1.BufferType.OFFSET] = offsets.flush(length);
        } else if (values) {
          buffers[enum_1.BufferType.DATA] = values.flush(length);
        }
        nullCount > 0 && (buffers[enum_1.BufferType.VALIDITY] = this._nulls.flush(length));
        const data = data_1.Data.new(this.type, 0, length, nullCount, buffers, this.children.map((child) => child.flush()));
        this.clear();
        return data;
      }
      /**
       * Finalize this `Builder`, and child builders if applicable.
       * @returns {this} The finalized `Builder` instance.
       */
      finish() {
        this.finished = true;
        this.children.forEach((child) => child.finish());
        return this;
      }
      /**
       * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.
       * @returns {this} The cleared `Builder` instance.
       */
      clear() {
        this.length = 0;
        this._offsets && this._offsets.clear();
        this._values && this._values.clear();
        this._nulls && this._nulls.clear();
        this._typeIds && this._typeIds.clear();
        this.children.forEach((child) => child.clear());
        return this;
      }
    };
    exports.Builder = Builder3;
    Builder3.prototype.length = 1;
    Builder3.prototype.stride = 1;
    Builder3.prototype.children = null;
    Builder3.prototype.finished = false;
    Builder3.prototype.nullValues = null;
    Builder3.prototype._isValid = () => true;
    var FixedWidthBuilder = class extends Builder3 {
      constructor(opts) {
        super(opts);
        this._values = new buffer_1.DataBufferBuilder(new this.ArrayType(0), this.stride);
      }
      setValue(index, value) {
        const values = this._values;
        values.reserve(index - values.length + 1);
        return super.setValue(index, value);
      }
    };
    exports.FixedWidthBuilder = FixedWidthBuilder;
    var VariableWidthBuilder = class extends Builder3 {
      constructor(opts) {
        super(opts);
        this._pendingLength = 0;
        this._offsets = new buffer_1.OffsetsBufferBuilder();
      }
      setValue(index, value) {
        const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
        const current = pending.get(index);
        current && (this._pendingLength -= current.length);
        this._pendingLength += value.length;
        pending.set(index, value);
      }
      setValid(index, isValid) {
        if (!super.setValid(index, isValid)) {
          (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index, void 0);
          return false;
        }
        return true;
      }
      clear() {
        this._pendingLength = 0;
        this._pending = void 0;
        return super.clear();
      }
      flush() {
        this._flush();
        return super.flush();
      }
      finish() {
        this._flush();
        return super.finish();
      }
      _flush() {
        const pending = this._pending;
        const pendingLength = this._pendingLength;
        this._pendingLength = 0;
        this._pending = void 0;
        if (pending && pending.size > 0) {
          this._flushPending(pending, pendingLength);
        }
        return this;
      }
    };
    exports.VariableWidthBuilder = VariableWidthBuilder;
    function throughIterable(options) {
      const { ["queueingStrategy"]: queueingStrategy = "count" } = options;
      const { ["highWaterMark"]: highWaterMark = queueingStrategy !== "bytes" ? 1e3 : 2 ** 14 } = options;
      const sizeProperty = queueingStrategy !== "bytes" ? "length" : "byteLength";
      return function* (source) {
        let numChunks = 0;
        let builder = Builder3.new(options);
        for (const value of source) {
          if (builder.append(value)[sizeProperty] >= highWaterMark) {
            ++numChunks && (yield builder.toVector());
          }
        }
        if (builder.finish().length > 0 || numChunks === 0) {
          yield builder.toVector();
        }
      };
    }
    function throughAsyncIterable(options) {
      const { ["queueingStrategy"]: queueingStrategy = "count" } = options;
      const { ["highWaterMark"]: highWaterMark = queueingStrategy !== "bytes" ? 1e3 : 2 ** 14 } = options;
      const sizeProperty = queueingStrategy !== "bytes" ? "length" : "byteLength";
      return async function* (source) {
        let numChunks = 0;
        let builder = Builder3.new(options);
        for await (const value of source) {
          if (builder.append(value)[sizeProperty] >= highWaterMark) {
            ++numChunks && (yield builder.toVector());
          }
        }
        if (builder.finish().length > 0 || numChunks === 0) {
          yield builder.toVector();
        }
      };
    }
  }
});

// node_modules/apache-arrow/builder/bool.js
var require_bool = __commonJS({
  "node_modules/apache-arrow/builder/bool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer2();
    var builder_1 = require_builder();
    var BoolBuilder2 = class extends builder_1.Builder {
      constructor(options) {
        super(options);
        this._values = new buffer_1.BitmapBufferBuilder();
      }
      setValue(index, value) {
        this._values.set(index, +value);
      }
    };
    exports.BoolBuilder = BoolBuilder2;
  }
});

// node_modules/apache-arrow/builder/null.js
var require_null = __commonJS({
  "node_modules/apache-arrow/builder/null.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var NullBuilder2 = class extends builder_1.Builder {
      // @ts-ignore
      setValue(index, value) {
      }
      setValid(index, valid) {
        this.length = Math.max(index + 1, this.length);
        return valid;
      }
    };
    exports.NullBuilder = NullBuilder2;
  }
});

// node_modules/apache-arrow/builder/date.js
var require_date = __commonJS({
  "node_modules/apache-arrow/builder/date.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var DateBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.DateBuilder = DateBuilder2;
    var DateDayBuilder2 = class extends DateBuilder2 {
    };
    exports.DateDayBuilder = DateDayBuilder2;
    var DateMillisecondBuilder2 = class extends DateBuilder2 {
    };
    exports.DateMillisecondBuilder = DateMillisecondBuilder2;
  }
});

// node_modules/apache-arrow/builder/decimal.js
var require_decimal = __commonJS({
  "node_modules/apache-arrow/builder/decimal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var DecimalBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.DecimalBuilder = DecimalBuilder2;
  }
});

// node_modules/apache-arrow/builder/dictionary.js
var require_dictionary = __commonJS({
  "node_modules/apache-arrow/builder/dictionary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var type_1 = require_type();
    var builder_1 = require_builder();
    var DictionaryBuilder2 = class extends builder_1.Builder {
      constructor({ "type": type, "nullValues": nulls, "dictionaryHashFunction": hashFn }) {
        super({ type: new type_1.Dictionary(type.dictionary, type.indices, type.id, type.isOrdered) });
        this._nulls = null;
        this._dictionaryOffset = 0;
        this._keysToIndices = /* @__PURE__ */ Object.create(null);
        this.indices = builder_1.Builder.new({ "type": this.type.indices, "nullValues": nulls });
        this.dictionary = builder_1.Builder.new({ "type": this.type.dictionary, "nullValues": null });
        if (typeof hashFn === "function") {
          this.valueToKey = hashFn;
        }
      }
      get values() {
        return this.indices.values;
      }
      get nullCount() {
        return this.indices.nullCount;
      }
      get nullBitmap() {
        return this.indices.nullBitmap;
      }
      get byteLength() {
        return this.indices.byteLength + this.dictionary.byteLength;
      }
      get reservedLength() {
        return this.indices.reservedLength + this.dictionary.reservedLength;
      }
      get reservedByteLength() {
        return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
      }
      isValid(value) {
        return this.indices.isValid(value);
      }
      setValid(index, valid) {
        const indices = this.indices;
        valid = indices.setValid(index, valid);
        this.length = indices.length;
        return valid;
      }
      setValue(index, value) {
        let keysToIndices = this._keysToIndices;
        let key = this.valueToKey(value);
        let idx = keysToIndices[key];
        if (idx === void 0) {
          keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
        }
        return this.indices.setValue(index, idx);
      }
      flush() {
        const type = this.type;
        const prev = this._dictionary;
        const curr = this.dictionary.toVector();
        const data = this.indices.flush().clone(type);
        data.dictionary = prev ? prev.concat(curr) : curr;
        this.finished || (this._dictionaryOffset += curr.length);
        this._dictionary = data.dictionary;
        this.clear();
        return data;
      }
      finish() {
        this.indices.finish();
        this.dictionary.finish();
        this._dictionaryOffset = 0;
        this._keysToIndices = /* @__PURE__ */ Object.create(null);
        return super.finish();
      }
      clear() {
        this.indices.clear();
        this.dictionary.clear();
        return super.clear();
      }
      valueToKey(val) {
        return typeof val === "string" ? val : `${val}`;
      }
    };
    exports.DictionaryBuilder = DictionaryBuilder2;
  }
});

// node_modules/apache-arrow/builder/fixedsizebinary.js
var require_fixedsizebinary = __commonJS({
  "node_modules/apache-arrow/builder/fixedsizebinary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var FixedSizeBinaryBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.FixedSizeBinaryBuilder = FixedSizeBinaryBuilder2;
  }
});

// node_modules/apache-arrow/util/math.js
var require_math = __commonJS({
  "node_modules/apache-arrow/util/math.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var f64 = new Float64Array(1);
    var u32 = new Uint32Array(f64.buffer);
    function uint16ToFloat64(h) {
      let expo = (h & 31744) >> 10;
      let sigf = (h & 1023) / 1024;
      let sign = (-1) ** ((h & 32768) >> 15);
      switch (expo) {
        case 31:
          return sign * (sigf ? NaN : 1 / 0);
        case 0:
          return sign * (sigf ? 6103515625e-14 * sigf : 0);
      }
      return sign * 2 ** (expo - 15) * (1 + sigf);
    }
    exports.uint16ToFloat64 = uint16ToFloat64;
    function float64ToUint16(d) {
      if (d !== d) {
        return 32256;
      }
      f64[0] = d;
      let sign = (u32[1] & 2147483648) >> 16 & 65535;
      let expo = u32[1] & 2146435072, sigf = 0;
      if (expo >= 1089470464) {
        if (u32[0] > 0) {
          expo = 31744;
        } else {
          expo = (expo & 2080374784) >> 16;
          sigf = (u32[1] & 1048575) >> 10;
        }
      } else if (expo <= 1056964608) {
        sigf = 1048576 + (u32[1] & 1048575);
        sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;
        expo = 0;
      } else {
        expo = expo - 1056964608 >> 10;
        sigf = (u32[1] & 1048575) + 512 >> 10;
      }
      return sign | expo | sigf & 65535;
    }
    exports.float64ToUint16 = float64ToUint16;
  }
});

// node_modules/apache-arrow/builder/float.js
var require_float = __commonJS({
  "node_modules/apache-arrow/builder/float.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var math_1 = require_math();
    var builder_1 = require_builder();
    var FloatBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.FloatBuilder = FloatBuilder2;
    var Float16Builder2 = class extends FloatBuilder2 {
      setValue(index, value) {
        this._values.set(index, math_1.float64ToUint16(value));
      }
    };
    exports.Float16Builder = Float16Builder2;
    var Float32Builder2 = class extends FloatBuilder2 {
      setValue(index, value) {
        this._values.set(index, value);
      }
    };
    exports.Float32Builder = Float32Builder2;
    var Float64Builder2 = class extends FloatBuilder2 {
      setValue(index, value) {
        this._values.set(index, value);
      }
    };
    exports.Float64Builder = Float64Builder2;
  }
});

// node_modules/apache-arrow/util/bn.js
var require_bn = __commonJS({
  "node_modules/apache-arrow/util/bn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    var compat_1 = require_compat();
    exports.isArrowBigNumSymbol = Symbol.for("isArrowBigNum");
    function BigNum(x, ...xs) {
      if (xs.length === 0) {
        return Object.setPrototypeOf(buffer_1.toArrayBufferView(this["TypedArray"], x), this.constructor.prototype);
      }
      return Object.setPrototypeOf(new this["TypedArray"](x, ...xs), this.constructor.prototype);
    }
    BigNum.prototype[exports.isArrowBigNumSymbol] = true;
    BigNum.prototype.toJSON = function() {
      return `"${exports.bignumToString(this)}"`;
    };
    BigNum.prototype.valueOf = function() {
      return bignumToNumber(this);
    };
    BigNum.prototype.toString = function() {
      return exports.bignumToString(this);
    };
    BigNum.prototype[Symbol.toPrimitive] = function(hint = "default") {
      switch (hint) {
        case "number":
          return bignumToNumber(this);
        case "string":
          return exports.bignumToString(this);
        case "default":
          return exports.bignumToBigInt(this);
      }
      return exports.bignumToString(this);
    };
    function SignedBigNum(...args) {
      return BigNum.apply(this, args);
    }
    function UnsignedBigNum(...args) {
      return BigNum.apply(this, args);
    }
    function DecimalBigNum(...args) {
      return BigNum.apply(this, args);
    }
    Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
    Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
    Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
    Object.assign(SignedBigNum.prototype, BigNum.prototype, { "constructor": SignedBigNum, "signed": true, "TypedArray": Int32Array, "BigIntArray": compat_1.BigInt64Array });
    Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { "constructor": UnsignedBigNum, "signed": false, "TypedArray": Uint32Array, "BigIntArray": compat_1.BigUint64Array });
    Object.assign(DecimalBigNum.prototype, BigNum.prototype, { "constructor": DecimalBigNum, "signed": true, "TypedArray": Uint32Array, "BigIntArray": compat_1.BigUint64Array });
    function bignumToNumber(bn) {
      let { buffer, byteOffset, length, "signed": signed } = bn;
      let words = new Int32Array(buffer, byteOffset, length);
      let number = 0, i = 0, n = words.length, hi, lo;
      while (i < n) {
        lo = words[i++];
        hi = words[i++];
        signed || (hi = hi >>> 0);
        number += (lo >>> 0) + hi * i ** 32;
      }
      return number;
    }
    if (!compat_1.BigIntAvailable) {
      exports.bignumToString = decimalToString;
      exports.bignumToBigInt = exports.bignumToString;
    } else {
      exports.bignumToBigInt = (a) => a.byteLength === 8 ? new a["BigIntArray"](a.buffer, a.byteOffset, 1)[0] : decimalToString(a);
      exports.bignumToString = (a) => a.byteLength === 8 ? `${new a["BigIntArray"](a.buffer, a.byteOffset, 1)[0]}` : decimalToString(a);
    }
    function decimalToString(a) {
      let digits = "";
      let base64 = new Uint32Array(2);
      let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
      let checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
      let i = -1, n = base32.length - 1;
      do {
        for (base64[0] = base32[i = 0]; i < n; ) {
          base32[i++] = base64[1] = base64[0] / 10;
          base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];
        }
        base32[i] = base64[1] = base64[0] / 10;
        base64[0] = base64[0] - base64[1] * 10;
        digits = `${base64[0]}${digits}`;
      } while (checks[0] || checks[1] || checks[2] || checks[3]);
      return digits ? digits : `0`;
    }
    var BN = class _BN {
      constructor(num, isSigned) {
        return _BN.new(num, isSigned);
      }
      /** @nocollapse */
      static new(num, isSigned) {
        switch (isSigned) {
          case true:
            return new SignedBigNum(num);
          case false:
            return new UnsignedBigNum(num);
        }
        switch (num.constructor) {
          case Int8Array:
          case Int16Array:
          case Int32Array:
          case compat_1.BigInt64Array:
            return new SignedBigNum(num);
        }
        if (num.byteLength === 16) {
          return new DecimalBigNum(num);
        }
        return new UnsignedBigNum(num);
      }
      /** @nocollapse */
      static signed(num) {
        return new SignedBigNum(num);
      }
      /** @nocollapse */
      static unsigned(num) {
        return new UnsignedBigNum(num);
      }
      /** @nocollapse */
      static decimal(num) {
        return new DecimalBigNum(num);
      }
    };
    exports.BN = BN;
  }
});

// node_modules/apache-arrow/builder/int.js
var require_int = __commonJS({
  "node_modules/apache-arrow/builder/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bn_1 = require_bn();
    var buffer_1 = require_buffer2();
    var compat_1 = require_compat();
    var builder_1 = require_builder();
    var IntBuilder2 = class extends builder_1.FixedWidthBuilder {
      setValue(index, value) {
        this._values.set(index, value);
      }
    };
    exports.IntBuilder = IntBuilder2;
    var Int8Builder2 = class extends IntBuilder2 {
    };
    exports.Int8Builder = Int8Builder2;
    var Int16Builder2 = class extends IntBuilder2 {
    };
    exports.Int16Builder = Int16Builder2;
    var Int32Builder2 = class extends IntBuilder2 {
    };
    exports.Int32Builder = Int32Builder2;
    var Int64Builder2 = class extends IntBuilder2 {
      constructor(options) {
        if (options["nullValues"]) {
          options["nullValues"] = options["nullValues"].map(toBigInt);
        }
        super(options);
        this._values = new buffer_1.WideBufferBuilder(new Int32Array(0), 2);
      }
      get values64() {
        return this._values.buffer64;
      }
      isValid(value) {
        return super.isValid(toBigInt(value));
      }
    };
    exports.Int64Builder = Int64Builder2;
    var Uint8Builder2 = class extends IntBuilder2 {
    };
    exports.Uint8Builder = Uint8Builder2;
    var Uint16Builder2 = class extends IntBuilder2 {
    };
    exports.Uint16Builder = Uint16Builder2;
    var Uint32Builder2 = class extends IntBuilder2 {
    };
    exports.Uint32Builder = Uint32Builder2;
    var Uint64Builder2 = class extends IntBuilder2 {
      constructor(options) {
        if (options["nullValues"]) {
          options["nullValues"] = options["nullValues"].map(toBigInt);
        }
        super(options);
        this._values = new buffer_1.WideBufferBuilder(new Uint32Array(0), 2);
      }
      get values64() {
        return this._values.buffer64;
      }
      isValid(value) {
        return super.isValid(toBigInt(value));
      }
    };
    exports.Uint64Builder = Uint64Builder2;
    var toBigInt = /* @__PURE__ */ ((memo) => (value) => {
      if (ArrayBuffer.isView(value)) {
        memo.buffer = value.buffer;
        memo.byteOffset = value.byteOffset;
        memo.byteLength = value.byteLength;
        value = bn_1.bignumToBigInt(memo);
        memo.buffer = null;
      }
      return value;
    })({ "BigIntArray": compat_1.BigInt64Array });
  }
});

// node_modules/apache-arrow/builder/time.js
var require_time = __commonJS({
  "node_modules/apache-arrow/builder/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var TimeBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.TimeBuilder = TimeBuilder2;
    var TimeSecondBuilder2 = class extends TimeBuilder2 {
    };
    exports.TimeSecondBuilder = TimeSecondBuilder2;
    var TimeMillisecondBuilder2 = class extends TimeBuilder2 {
    };
    exports.TimeMillisecondBuilder = TimeMillisecondBuilder2;
    var TimeMicrosecondBuilder2 = class extends TimeBuilder2 {
    };
    exports.TimeMicrosecondBuilder = TimeMicrosecondBuilder2;
    var TimeNanosecondBuilder2 = class extends TimeBuilder2 {
    };
    exports.TimeNanosecondBuilder = TimeNanosecondBuilder2;
  }
});

// node_modules/apache-arrow/builder/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/apache-arrow/builder/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var TimestampBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.TimestampBuilder = TimestampBuilder2;
    var TimestampSecondBuilder2 = class extends TimestampBuilder2 {
    };
    exports.TimestampSecondBuilder = TimestampSecondBuilder2;
    var TimestampMillisecondBuilder2 = class extends TimestampBuilder2 {
    };
    exports.TimestampMillisecondBuilder = TimestampMillisecondBuilder2;
    var TimestampMicrosecondBuilder2 = class extends TimestampBuilder2 {
    };
    exports.TimestampMicrosecondBuilder = TimestampMicrosecondBuilder2;
    var TimestampNanosecondBuilder2 = class extends TimestampBuilder2 {
    };
    exports.TimestampNanosecondBuilder = TimestampNanosecondBuilder2;
  }
});

// node_modules/apache-arrow/builder/interval.js
var require_interval = __commonJS({
  "node_modules/apache-arrow/builder/interval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var IntervalBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.IntervalBuilder = IntervalBuilder2;
    var IntervalDayTimeBuilder2 = class extends IntervalBuilder2 {
    };
    exports.IntervalDayTimeBuilder = IntervalDayTimeBuilder2;
    var IntervalYearMonthBuilder2 = class extends IntervalBuilder2 {
    };
    exports.IntervalYearMonthBuilder = IntervalYearMonthBuilder2;
  }
});

// node_modules/apache-arrow/builder/binary.js
var require_binary = __commonJS({
  "node_modules/apache-arrow/builder/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    var buffer_2 = require_buffer2();
    var builder_1 = require_builder();
    var BinaryBuilder2 = class extends builder_1.VariableWidthBuilder {
      constructor(opts) {
        super(opts);
        this._values = new buffer_2.BufferBuilder(new Uint8Array(0));
      }
      get byteLength() {
        let size = this._pendingLength + this.length * 4;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
      }
      setValue(index, value) {
        return super.setValue(index, buffer_1.toUint8Array(value));
      }
      _flushPending(pending, pendingLength) {
        const offsets = this._offsets;
        const data = this._values.reserve(pendingLength).buffer;
        let index = 0, length = 0, offset = 0, value;
        for ([index, value] of pending) {
          if (value === void 0) {
            offsets.set(index, 0);
          } else {
            length = value.length;
            data.set(value, offset);
            offsets.set(index, length);
            offset += length;
          }
        }
      }
    };
    exports.BinaryBuilder = BinaryBuilder2;
  }
});

// node_modules/apache-arrow/builder/utf8.js
var require_utf82 = __commonJS({
  "node_modules/apache-arrow/builder/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utf8_1 = require_utf8();
    var binary_1 = require_binary();
    var buffer_1 = require_buffer2();
    var builder_1 = require_builder();
    var Utf8Builder2 = class extends builder_1.VariableWidthBuilder {
      constructor(opts) {
        super(opts);
        this._values = new buffer_1.BufferBuilder(new Uint8Array(0));
      }
      get byteLength() {
        let size = this._pendingLength + this.length * 4;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
      }
      setValue(index, value) {
        return super.setValue(index, utf8_1.encodeUtf8(value));
      }
      // @ts-ignore
      _flushPending(pending, pendingLength) {
      }
    };
    exports.Utf8Builder = Utf8Builder2;
    Utf8Builder2.prototype._flushPending = binary_1.BinaryBuilder.prototype._flushPending;
  }
});

// node_modules/apache-arrow/builder/run.js
var require_run = __commonJS({
  "node_modules/apache-arrow/builder/run.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var Run = class {
      get length() {
        return this._values.length;
      }
      get(index) {
        return this._values[index];
      }
      clear() {
        this._values = null;
        return this;
      }
      bind(values) {
        if (values instanceof vector_1.Vector) {
          return values;
        }
        this._values = values;
        return this;
      }
    };
    exports.Run = Run;
  }
});

// node_modules/apache-arrow/vector/row.js
var require_row = __commonJS({
  "node_modules/apache-arrow/vector/row.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pretty_1 = require_pretty();
    var kParent = Symbol.for("parent");
    var kRowIndex = Symbol.for("rowIndex");
    var kKeyToIdx = Symbol.for("keyToIdx");
    var kIdxToVal = Symbol.for("idxToVal");
    var kCustomInspect = Symbol.for("nodejs.util.inspect.custom");
    var Row = class {
      constructor(parent, numKeys) {
        this[kParent] = parent;
        this.size = numKeys;
      }
      entries() {
        return this[Symbol.iterator]();
      }
      has(key) {
        return this.get(key) !== void 0;
      }
      get(key) {
        let val = void 0;
        if (key !== null && key !== void 0) {
          const ktoi = this[kKeyToIdx] || (this[kKeyToIdx] = /* @__PURE__ */ new Map());
          let idx = ktoi.get(key);
          if (idx !== void 0) {
            const itov = this[kIdxToVal] || (this[kIdxToVal] = new Array(this.size));
            (val = itov[idx]) !== void 0 || (itov[idx] = val = this.getValue(idx));
          } else if ((idx = this.getIndex(key)) > -1) {
            ktoi.set(key, idx);
            const itov = this[kIdxToVal] || (this[kIdxToVal] = new Array(this.size));
            (val = itov[idx]) !== void 0 || (itov[idx] = val = this.getValue(idx));
          }
        }
        return val;
      }
      set(key, val) {
        if (key !== null && key !== void 0) {
          const ktoi = this[kKeyToIdx] || (this[kKeyToIdx] = /* @__PURE__ */ new Map());
          let idx = ktoi.get(key);
          if (idx === void 0) {
            ktoi.set(key, idx = this.getIndex(key));
          }
          if (idx > -1) {
            const itov = this[kIdxToVal] || (this[kIdxToVal] = new Array(this.size));
            itov[idx] = this.setValue(idx, val);
          }
        }
        return this;
      }
      clear() {
        throw new Error(`Clearing ${this[Symbol.toStringTag]} not supported.`);
      }
      delete(_) {
        throw new Error(`Deleting ${this[Symbol.toStringTag]} values not supported.`);
      }
      *[Symbol.iterator]() {
        const ki = this.keys();
        const vi = this.values();
        const ktoi = this[kKeyToIdx] || (this[kKeyToIdx] = /* @__PURE__ */ new Map());
        const itov = this[kIdxToVal] || (this[kIdxToVal] = new Array(this.size));
        for (let k, v, i = 0, kr, vr; !((kr = ki.next()).done || (vr = vi.next()).done); ++i) {
          k = kr.value;
          v = vr.value;
          itov[i] = v;
          ktoi.has(k) || ktoi.set(k, i);
          yield [k, v];
        }
      }
      forEach(callbackfn, thisArg) {
        const ki = this.keys();
        const vi = this.values();
        const callback = thisArg === void 0 ? callbackfn : (v, k, m) => callbackfn.call(thisArg, v, k, m);
        const ktoi = this[kKeyToIdx] || (this[kKeyToIdx] = /* @__PURE__ */ new Map());
        const itov = this[kIdxToVal] || (this[kIdxToVal] = new Array(this.size));
        for (let k, v, i = 0, kr, vr; !((kr = ki.next()).done || (vr = vi.next()).done); ++i) {
          k = kr.value;
          v = vr.value;
          itov[i] = v;
          ktoi.has(k) || ktoi.set(k, i);
          callback(v, k, this);
        }
      }
      toArray() {
        return [...this.values()];
      }
      toJSON() {
        const obj = {};
        this.forEach((val, key) => obj[key] = val);
        return obj;
      }
      inspect() {
        return this.toString();
      }
      [kCustomInspect]() {
        return this.toString();
      }
      toString() {
        const str = [];
        this.forEach((val, key) => {
          key = pretty_1.valueToString(key);
          val = pretty_1.valueToString(val);
          str.push(`${key}: ${val}`);
        });
        return `{ ${str.join(", ")} }`;
      }
    };
    Row[Symbol.toStringTag] = ((proto) => {
      Object.defineProperties(proto, {
        "size": { writable: true, enumerable: false, configurable: false, value: 0 },
        [kParent]: { writable: true, enumerable: false, configurable: false, value: null },
        [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }
      });
      return proto[Symbol.toStringTag] = "Row";
    })(Row.prototype);
    var MapRow = class extends Row {
      constructor(slice) {
        super(slice, slice.length);
        return createRowProxy(this);
      }
      keys() {
        return this[kParent].getChildAt(0)[Symbol.iterator]();
      }
      values() {
        return this[kParent].getChildAt(1)[Symbol.iterator]();
      }
      getKey(idx) {
        return this[kParent].getChildAt(0).get(idx);
      }
      getIndex(key) {
        return this[kParent].getChildAt(0).indexOf(key);
      }
      getValue(index) {
        return this[kParent].getChildAt(1).get(index);
      }
      setValue(index, value) {
        this[kParent].getChildAt(1).set(index, value);
      }
    };
    exports.MapRow = MapRow;
    var StructRow = class extends Row {
      constructor(parent) {
        super(parent, parent.type.children.length);
        return defineRowProxyProperties(this);
      }
      *keys() {
        for (const field of this[kParent].type.children) {
          yield field.name;
        }
      }
      *values() {
        for (const field of this[kParent].type.children) {
          yield this[field.name];
        }
      }
      getKey(idx) {
        return this[kParent].type.children[idx].name;
      }
      getIndex(key) {
        return this[kParent].type.children.findIndex((f) => f.name === key);
      }
      getValue(index) {
        return this[kParent].getChildAt(index).get(this[kRowIndex]);
      }
      setValue(index, value) {
        return this[kParent].getChildAt(index).set(this[kRowIndex], value);
      }
    };
    exports.StructRow = StructRow;
    Object.setPrototypeOf(Row.prototype, Map.prototype);
    var defineRowProxyProperties = /* @__PURE__ */ (() => {
      const desc = { enumerable: true, configurable: false, get: null, set: null };
      return (row) => {
        let idx = -1, ktoi = row[kKeyToIdx] || (row[kKeyToIdx] = /* @__PURE__ */ new Map());
        const getter = (key) => function() {
          return this.get(key);
        };
        const setter = (key) => function(val) {
          return this.set(key, val);
        };
        for (const key of row.keys()) {
          ktoi.set(key, ++idx);
          desc.get = getter(key);
          desc.set = setter(key);
          row.hasOwnProperty(key) || (desc.enumerable = true, Object.defineProperty(row, key, desc));
          row.hasOwnProperty(idx) || (desc.enumerable = false, Object.defineProperty(row, idx, desc));
        }
        desc.get = desc.set = null;
        return row;
      };
    })();
    var createRowProxy = (() => {
      if (typeof Proxy === "undefined") {
        return defineRowProxyProperties;
      }
      const has = Row.prototype.has;
      const get = Row.prototype.get;
      const set = Row.prototype.set;
      const getKey = Row.prototype.getKey;
      const RowProxyHandler = {
        isExtensible() {
          return false;
        },
        deleteProperty() {
          return false;
        },
        preventExtensions() {
          return true;
        },
        ownKeys(row) {
          return [...row.keys()].map((x) => `${x}`);
        },
        has(row, key) {
          switch (key) {
            case "getKey":
            case "getIndex":
            case "getValue":
            case "setValue":
            case "toArray":
            case "toJSON":
            case "inspect":
            case "constructor":
            case "isPrototypeOf":
            case "propertyIsEnumerable":
            case "toString":
            case "toLocaleString":
            case "valueOf":
            case "size":
            case "has":
            case "get":
            case "set":
            case "clear":
            case "delete":
            case "keys":
            case "values":
            case "entries":
            case "forEach":
            case "__proto__":
            case "__defineGetter__":
            case "__defineSetter__":
            case "hasOwnProperty":
            case "__lookupGetter__":
            case "__lookupSetter__":
            case Symbol.iterator:
            case Symbol.toStringTag:
            case kParent:
            case kRowIndex:
            case kIdxToVal:
            case kKeyToIdx:
            case kCustomInspect:
              return true;
          }
          if (typeof key === "number" && !row.has(key)) {
            key = row.getKey(key);
          }
          return row.has(key);
        },
        get(row, key, receiver) {
          switch (key) {
            case "getKey":
            case "getIndex":
            case "getValue":
            case "setValue":
            case "toArray":
            case "toJSON":
            case "inspect":
            case "constructor":
            case "isPrototypeOf":
            case "propertyIsEnumerable":
            case "toString":
            case "toLocaleString":
            case "valueOf":
            case "size":
            case "has":
            case "get":
            case "set":
            case "clear":
            case "delete":
            case "keys":
            case "values":
            case "entries":
            case "forEach":
            case "__proto__":
            case "__defineGetter__":
            case "__defineSetter__":
            case "hasOwnProperty":
            case "__lookupGetter__":
            case "__lookupSetter__":
            case Symbol.iterator:
            case Symbol.toStringTag:
            case kParent:
            case kRowIndex:
            case kIdxToVal:
            case kKeyToIdx:
            case kCustomInspect:
              return Reflect.get(row, key, receiver);
          }
          if (typeof key === "number" && !has.call(receiver, key)) {
            key = getKey.call(receiver, key);
          }
          return get.call(receiver, key);
        },
        set(row, key, val, receiver) {
          switch (key) {
            case kParent:
            case kRowIndex:
            case kIdxToVal:
            case kKeyToIdx:
              return Reflect.set(row, key, val, receiver);
            case "getKey":
            case "getIndex":
            case "getValue":
            case "setValue":
            case "toArray":
            case "toJSON":
            case "inspect":
            case "constructor":
            case "isPrototypeOf":
            case "propertyIsEnumerable":
            case "toString":
            case "toLocaleString":
            case "valueOf":
            case "size":
            case "has":
            case "get":
            case "set":
            case "clear":
            case "delete":
            case "keys":
            case "values":
            case "entries":
            case "forEach":
            case "__proto__":
            case "__defineGetter__":
            case "__defineSetter__":
            case "hasOwnProperty":
            case "__lookupGetter__":
            case "__lookupSetter__":
            case Symbol.iterator:
            case Symbol.toStringTag:
              return false;
          }
          if (typeof key === "number" && !has.call(receiver, key)) {
            key = getKey.call(receiver, key);
          }
          return has.call(receiver, key) ? !!set.call(receiver, key, val) : false;
        }
      };
      return (row) => new Proxy(row, RowProxyHandler);
    })();
  }
});

// node_modules/apache-arrow/util/vector.js
var require_vector2 = __commonJS({
  "node_modules/apache-arrow/util/vector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var row_1 = require_row();
    var buffer_1 = require_buffer();
    var compat_1 = require_compat();
    function clampIndex(source, index, then) {
      const length = source.length;
      const adjust = index > -1 ? index : length + index % length;
      return then ? then(source, adjust) : adjust;
    }
    exports.clampIndex = clampIndex;
    var tmp;
    function clampRange(source, begin, end, then) {
      let { length: len = 0 } = source;
      let lhs = typeof begin !== "number" ? 0 : begin;
      let rhs = typeof end !== "number" ? len : end;
      lhs < 0 && (lhs = (lhs % len + len) % len);
      rhs < 0 && (rhs = (rhs % len + len) % len);
      rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);
      rhs > len && (rhs = len);
      return then ? then(source, lhs, rhs) : [lhs, rhs];
    }
    exports.clampRange = clampRange;
    var big0 = compat_1.BigIntAvailable ? compat_1.BigInt(0) : 0;
    var isNaNFast = (value) => value !== value;
    function createElementComparator(search) {
      let typeofSearch = typeof search;
      if (typeofSearch !== "object" || search === null) {
        if (isNaNFast(search)) {
          return isNaNFast;
        }
        return typeofSearch !== "bigint" ? (value) => value === search : (value) => big0 + value === search;
      }
      if (search instanceof Date) {
        const valueOfSearch = search.valueOf();
        return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;
      }
      if (ArrayBuffer.isView(search)) {
        return (value) => value ? buffer_1.compareArrayLike(search, value) : false;
      }
      if (search instanceof Map) {
        return creatMapComparator(search);
      }
      if (Array.isArray(search)) {
        return createArrayLikeComparator(search);
      }
      if (search instanceof vector_1.Vector) {
        return createVectorComparator(search);
      }
      return createObjectComparator(search);
    }
    exports.createElementComparator = createElementComparator;
    function createArrayLikeComparator(lhs) {
      const comparators = [];
      for (let i = -1, n = lhs.length; ++i < n; ) {
        comparators[i] = createElementComparator(lhs[i]);
      }
      return createSubElementsComparator(comparators);
    }
    function creatMapComparator(lhs) {
      let i = -1;
      const comparators = [];
      lhs.forEach((v) => comparators[++i] = createElementComparator(v));
      return createSubElementsComparator(comparators);
    }
    function createVectorComparator(lhs) {
      const comparators = [];
      for (let i = -1, n = lhs.length; ++i < n; ) {
        comparators[i] = createElementComparator(lhs.get(i));
      }
      return createSubElementsComparator(comparators);
    }
    function createObjectComparator(lhs) {
      const keys = Object.keys(lhs);
      if (keys.length === 0) {
        return () => false;
      }
      const comparators = [];
      for (let i = -1, n = keys.length; ++i < n; ) {
        comparators[i] = createElementComparator(lhs[keys[i]]);
      }
      return createSubElementsComparator(comparators, keys);
    }
    function createSubElementsComparator(comparators, keys) {
      return (rhs) => {
        if (!rhs || typeof rhs !== "object") {
          return false;
        }
        switch (rhs.constructor) {
          case Array:
            return compareArray(comparators, rhs);
          case Map:
          case row_1.MapRow:
          case row_1.StructRow:
            return compareObject(comparators, rhs, rhs.keys());
          case Object:
          case void 0:
            return compareObject(comparators, rhs, keys || Object.keys(rhs));
        }
        return rhs instanceof vector_1.Vector ? compareVector(comparators, rhs) : false;
      };
    }
    function compareArray(comparators, arr) {
      const n = comparators.length;
      if (arr.length !== n) {
        return false;
      }
      for (let i = -1; ++i < n; ) {
        if (!comparators[i](arr[i])) {
          return false;
        }
      }
      return true;
    }
    function compareVector(comparators, vec) {
      const n = comparators.length;
      if (vec.length !== n) {
        return false;
      }
      for (let i = -1; ++i < n; ) {
        if (!comparators[i](vec.get(i))) {
          return false;
        }
      }
      return true;
    }
    function compareObject(comparators, obj, keys) {
      const lKeyItr = keys[Symbol.iterator]();
      const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
      const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
      let i = 0;
      let n = comparators.length;
      let rVal = rValItr.next();
      let lKey = lKeyItr.next();
      let rKey = rKeyItr.next();
      for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
        if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {
          break;
        }
      }
      if (i === n && lKey.done && rKey.done && rVal.done) {
        return true;
      }
      lKeyItr.return && lKeyItr.return();
      rKeyItr.return && rKeyItr.return();
      rValItr.return && rValItr.return();
      return false;
    }
  }
});

// node_modules/apache-arrow/vector/chunked.js
var require_chunked = __commonJS({
  "node_modules/apache-arrow/vector/chunked.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector2();
    var type_1 = require_type();
    var args_1 = require_args();
    var vector_2 = require_vector();
    var Chunked2 = class _Chunked extends vector_2.AbstractVector {
      constructor(type, chunks = [], offsets = calculateOffsets(chunks)) {
        super();
        this._nullCount = -1;
        this._type = type;
        this._chunks = chunks;
        this._chunkOffsets = offsets;
        this._length = offsets[offsets.length - 1];
        this._numChildren = (this._type.children || []).length;
      }
      /** @nocollapse */
      static flatten(...vectors) {
        return args_1.selectChunkArgs(vector_2.Vector, vectors);
      }
      /** @nocollapse */
      static concat(...vectors) {
        const chunks = _Chunked.flatten(...vectors);
        return new _Chunked(chunks[0].type, chunks);
      }
      get type() {
        return this._type;
      }
      get length() {
        return this._length;
      }
      get chunks() {
        return this._chunks;
      }
      get typeId() {
        return this._type.typeId;
      }
      get VectorName() {
        return `Chunked<${this._type}>`;
      }
      get data() {
        return this._chunks[0] ? this._chunks[0].data : null;
      }
      get ArrayType() {
        return this._type.ArrayType;
      }
      get numChildren() {
        return this._numChildren;
      }
      get stride() {
        return this._chunks[0] ? this._chunks[0].stride : 1;
      }
      get byteLength() {
        return this._chunks.reduce((byteLength, chunk) => byteLength + chunk.byteLength, 0);
      }
      get nullCount() {
        let nullCount = this._nullCount;
        if (nullCount < 0) {
          this._nullCount = nullCount = this._chunks.reduce((x, { nullCount: nullCount2 }) => x + nullCount2, 0);
        }
        return nullCount;
      }
      get indices() {
        if (type_1.DataType.isDictionary(this._type)) {
          if (!this._indices) {
            const chunks = this._chunks;
            this._indices = chunks.length === 1 ? chunks[0].indices : _Chunked.concat(...chunks.map((x) => x.indices));
          }
          return this._indices;
        }
        return null;
      }
      get dictionary() {
        if (type_1.DataType.isDictionary(this._type)) {
          return this._chunks[this._chunks.length - 1].data.dictionary;
        }
        return null;
      }
      *[Symbol.iterator]() {
        for (const chunk of this._chunks) {
          yield* chunk;
        }
      }
      clone(chunks = this._chunks) {
        return new _Chunked(this._type, chunks);
      }
      concat(...others) {
        return this.clone(_Chunked.flatten(this, ...others));
      }
      slice(begin, end) {
        return vector_1.clampRange(this, begin, end, this._sliceInternal);
      }
      getChildAt(index) {
        if (index < 0 || index >= this._numChildren) {
          return null;
        }
        let columns = this._children || (this._children = []);
        let child, field, chunks;
        if (child = columns[index]) {
          return child;
        }
        if (field = (this._type.children || [])[index]) {
          chunks = this._chunks.map((vector) => vector.getChildAt(index)).filter((vec) => vec != null);
          if (chunks.length > 0) {
            return columns[index] = new _Chunked(field.type, chunks);
          }
        }
        return null;
      }
      search(index, then) {
        let idx = index;
        let offsets = this._chunkOffsets, rhs = offsets.length - 1;
        if (idx < 0) {
          return null;
        }
        if (idx >= offsets[rhs]) {
          return null;
        }
        if (rhs <= 1) {
          return then ? then(this, 0, idx) : [0, idx];
        }
        let lhs = 0, pos = 0, mid = 0;
        do {
          if (lhs + 1 === rhs) {
            return then ? then(this, lhs, idx - pos) : [lhs, idx - pos];
          }
          mid = lhs + (rhs - lhs) / 2 | 0;
          idx >= offsets[mid] ? lhs = mid : rhs = mid;
        } while (idx < offsets[rhs] && idx >= (pos = offsets[lhs]));
        return null;
      }
      isValid(index) {
        return !!this.search(index, this.isValidInternal);
      }
      get(index) {
        return this.search(index, this.getInternal);
      }
      set(index, value) {
        this.search(index, ({ chunks }, i, j) => chunks[i].set(j, value));
      }
      indexOf(element, offset) {
        if (offset && typeof offset === "number") {
          return this.search(offset, (self, i, j) => this.indexOfInternal(self, i, j, element));
        }
        return this.indexOfInternal(this, 0, Math.max(0, offset || 0), element);
      }
      toArray() {
        const { chunks } = this;
        const n = chunks.length;
        let ArrayType = this._type.ArrayType;
        if (n <= 0) {
          return new ArrayType(0);
        }
        if (n <= 1) {
          return chunks[0].toArray();
        }
        let len = 0, src = new Array(n);
        for (let i = -1; ++i < n; ) {
          len += (src[i] = chunks[i].toArray()).length;
        }
        if (ArrayType !== src[0].constructor) {
          ArrayType = src[0].constructor;
        }
        let dst = new ArrayType(len);
        let set = ArrayType === Array ? arraySet : typedSet;
        for (let i = -1, idx = 0; ++i < n; ) {
          idx = set(src[i], dst, idx);
        }
        return dst;
      }
      getInternal({ _chunks }, i, j) {
        return _chunks[i].get(j);
      }
      isValidInternal({ _chunks }, i, j) {
        return _chunks[i].isValid(j);
      }
      indexOfInternal({ _chunks }, chunkIndex, fromIndex, element) {
        let i = chunkIndex - 1, n = _chunks.length;
        let start = fromIndex, offset = 0, found = -1;
        while (++i < n) {
          if (~(found = _chunks[i].indexOf(element, start))) {
            return offset + found;
          }
          start = 0;
          offset += _chunks[i].length;
        }
        return -1;
      }
      _sliceInternal(self, begin, end) {
        const slices = [];
        const { chunks, _chunkOffsets: chunkOffsets } = self;
        for (let i = -1, n = chunks.length; ++i < n; ) {
          const chunk = chunks[i];
          const chunkLength = chunk.length;
          const chunkOffset = chunkOffsets[i];
          if (chunkOffset >= end) {
            break;
          }
          if (begin >= chunkOffset + chunkLength) {
            continue;
          }
          if (chunkOffset >= begin && chunkOffset + chunkLength <= end) {
            slices.push(chunk);
            continue;
          }
          const from = Math.max(0, begin - chunkOffset);
          const to = Math.min(end - chunkOffset, chunkLength);
          slices.push(chunk.slice(from, to));
        }
        return self.clone(slices);
      }
    };
    exports.Chunked = Chunked2;
    function calculateOffsets(vectors) {
      let offsets = new Uint32Array((vectors || []).length + 1);
      let offset = offsets[0] = 0, length = offsets.length;
      for (let index = 0; ++index < length; ) {
        offsets[index] = offset += vectors[index - 1].length;
      }
      return offsets;
    }
    var typedSet = (src, dst, offset) => {
      dst.set(src, offset);
      return offset + src.length;
    };
    var arraySet = (src, dst, offset) => {
      let idx = offset;
      for (let i = -1, n = src.length; ++i < n; ) {
        dst[idx++] = src[i];
      }
      return idx;
    };
  }
});

// node_modules/apache-arrow/column.js
var require_column = __commonJS({
  "node_modules/apache-arrow/column.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var vector_1 = require_vector();
    var chunked_1 = require_chunked();
    var Column2 = class _Column extends chunked_1.Chunked {
      constructor(field, vectors = [], offsets) {
        vectors = chunked_1.Chunked.flatten(...vectors);
        super(field.type, vectors, offsets);
        this._field = field;
        if (vectors.length === 1 && !(this instanceof SingleChunkColumn)) {
          return new SingleChunkColumn(field, vectors[0], this._chunkOffsets);
        }
      }
      /** @nocollapse */
      static new(field, data, ...rest) {
        const chunks = chunked_1.Chunked.flatten(Array.isArray(data) ? [...data, ...rest] : data instanceof vector_1.Vector ? [data, ...rest] : [vector_1.Vector.new(data, ...rest)]);
        if (typeof field === "string") {
          const type = chunks[0].data.type;
          field = new schema_1.Field(field, type, true);
        } else if (!field.nullable && chunks.some(({ nullCount }) => nullCount > 0)) {
          field = field.clone({ nullable: true });
        }
        return new _Column(field, chunks);
      }
      get field() {
        return this._field;
      }
      get name() {
        return this._field.name;
      }
      get nullable() {
        return this._field.nullable;
      }
      get metadata() {
        return this._field.metadata;
      }
      clone(chunks = this._chunks) {
        return new _Column(this._field, chunks);
      }
      getChildAt(index) {
        if (index < 0 || index >= this.numChildren) {
          return null;
        }
        let columns = this._children || (this._children = []);
        let column, field, chunks;
        if (column = columns[index]) {
          return column;
        }
        if (field = (this.type.children || [])[index]) {
          chunks = this._chunks.map((vector) => vector.getChildAt(index)).filter((vec) => vec != null);
          if (chunks.length > 0) {
            return columns[index] = new _Column(field, chunks);
          }
        }
        return null;
      }
    };
    exports.Column = Column2;
    var SingleChunkColumn = class extends Column2 {
      constructor(field, vector, offsets) {
        super(field, [vector], offsets);
        this._chunk = vector;
      }
      search(index, then) {
        return then ? then(this, 0, index) : [0, index];
      }
      isValid(index) {
        return this._chunk.isValid(index);
      }
      get(index) {
        return this._chunk.get(index);
      }
      set(index, value) {
        this._chunk.set(index, value);
      }
      indexOf(element, offset) {
        return this._chunk.indexOf(element, offset);
      }
    };
  }
});

// node_modules/apache-arrow/util/args.js
var require_args = __commonJS({
  "node_modules/apache-arrow/util/args.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var schema_1 = require_schema();
    var column_1 = require_column();
    var vector_1 = require_vector();
    var type_1 = require_type();
    var chunked_1 = require_chunked();
    var isArray = Array.isArray;
    exports.selectArgs = (Ctor, vals) => _selectArgs(Ctor, vals, [], 0);
    exports.selectColumnArgs = (args) => {
      const [fields, values] = _selectFieldArgs(args, [[], []]);
      return values.map((x, i) => x instanceof column_1.Column ? column_1.Column.new(x.field.clone(fields[i]), x) : x instanceof vector_1.Vector ? column_1.Column.new(fields[i], x) : column_1.Column.new(fields[i], []));
    };
    exports.selectFieldArgs = (args) => _selectFieldArgs(args, [[], []]);
    exports.selectChunkArgs = (Ctor, vals) => _selectChunkArgs(Ctor, vals, [], 0);
    exports.selectVectorChildrenArgs = (Ctor, vals) => _selectVectorChildrenArgs(Ctor, vals, [], 0);
    exports.selectColumnChildrenArgs = (Ctor, vals) => _selectColumnChildrenArgs(Ctor, vals, [], 0);
    function _selectArgs(Ctor, vals, res, idx) {
      let value, j = idx;
      let i = -1, n = vals.length;
      while (++i < n) {
        if (isArray(value = vals[i])) {
          j = _selectArgs(Ctor, value, res, j).length;
        } else if (value instanceof Ctor) {
          res[j++] = value;
        }
      }
      return res;
    }
    function _selectChunkArgs(Ctor, vals, res, idx) {
      let value, j = idx;
      let i = -1, n = vals.length;
      while (++i < n) {
        if (isArray(value = vals[i])) {
          j = _selectChunkArgs(Ctor, value, res, j).length;
        } else if (value instanceof chunked_1.Chunked) {
          j = _selectChunkArgs(Ctor, value.chunks, res, j).length;
        } else if (value instanceof Ctor) {
          res[j++] = value;
        }
      }
      return res;
    }
    function _selectVectorChildrenArgs(Ctor, vals, res, idx) {
      let value, j = idx;
      let i = -1, n = vals.length;
      while (++i < n) {
        if (isArray(value = vals[i])) {
          j = _selectVectorChildrenArgs(Ctor, value, res, j).length;
        } else if (value instanceof Ctor) {
          j = _selectArgs(vector_1.Vector, value.schema.fields.map((_, i2) => value.getChildAt(i2)), res, j).length;
        } else if (value instanceof vector_1.Vector) {
          res[j++] = value;
        }
      }
      return res;
    }
    function _selectColumnChildrenArgs(Ctor, vals, res, idx) {
      let value, j = idx;
      let i = -1, n = vals.length;
      while (++i < n) {
        if (isArray(value = vals[i])) {
          j = _selectColumnChildrenArgs(Ctor, value, res, j).length;
        } else if (value instanceof Ctor) {
          j = _selectArgs(column_1.Column, value.schema.fields.map((f, i2) => column_1.Column.new(f, value.getChildAt(i2))), res, j).length;
        } else if (value instanceof column_1.Column) {
          res[j++] = value;
        }
      }
      return res;
    }
    var toKeysAndValues = (xs, [k, v], i) => (xs[0][i] = k, xs[1][i] = v, xs);
    function _selectFieldArgs(vals, ret) {
      let keys, n;
      switch (n = vals.length) {
        case 0:
          return ret;
        case 1:
          keys = ret[0];
          if (!vals[0]) {
            return ret;
          }
          if (isArray(vals[0])) {
            return _selectFieldArgs(vals[0], ret);
          }
          if (!(vals[0] instanceof data_1.Data || vals[0] instanceof vector_1.Vector || vals[0] instanceof type_1.DataType)) {
            [keys, vals] = Object.entries(vals[0]).reduce(toKeysAndValues, ret);
          }
          break;
        default:
          !isArray(keys = vals[n - 1]) ? (vals = isArray(vals[0]) ? vals[0] : vals, keys = []) : vals = isArray(vals[0]) ? vals[0] : vals.slice(0, n - 1);
      }
      let fieldIndex = -1;
      let valueIndex = -1;
      let idx = -1, len = vals.length;
      let field;
      let val;
      let [fields, values] = ret;
      while (++idx < len) {
        val = vals[idx];
        if (val instanceof column_1.Column && (values[++valueIndex] = val)) {
          fields[++fieldIndex] = val.field.clone(keys[idx], val.type, true);
        } else {
          ({ [idx]: field = idx } = keys);
          if (val instanceof type_1.DataType && (values[++valueIndex] = val)) {
            fields[++fieldIndex] = schema_1.Field.new(field, val, true);
          } else if (val && val.type && (values[++valueIndex] = val)) {
            val instanceof data_1.Data && (values[valueIndex] = val = vector_1.Vector.new(val));
            fields[++fieldIndex] = schema_1.Field.new(field, val.type, true);
          }
        }
      }
      return ret;
    }
  }
});

// node_modules/apache-arrow/schema.js
var require_schema = __commonJS({
  "node_modules/apache-arrow/schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var type_1 = require_type();
    var args_1 = require_args();
    var args_2 = require_args();
    var typecomparator_1 = require_typecomparator();
    var Schema2 = class _Schema {
      constructor(fields = [], metadata, dictionaries) {
        this.fields = fields || [];
        this.metadata = metadata || /* @__PURE__ */ new Map();
        if (!dictionaries) {
          dictionaries = generateDictionaryMap(fields);
        }
        this.dictionaries = dictionaries;
      }
      /** @nocollapse */
      static from(...args) {
        return _Schema.new(args[0], args[1]);
      }
      /** @nocollapse */
      static new(...args) {
        return new _Schema(args_2.selectFieldArgs(args)[0]);
      }
      get [Symbol.toStringTag]() {
        return "Schema";
      }
      toString() {
        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(", ")} }>`;
      }
      compareTo(other) {
        return typecomparator_1.instance.compareSchemas(this, other);
      }
      select(...columnNames) {
        const names = columnNames.reduce((xs, x) => (xs[x] = true) && xs, /* @__PURE__ */ Object.create(null));
        return new _Schema(this.fields.filter((f) => names[f.name]), this.metadata);
      }
      selectAt(...columnIndices) {
        return new _Schema(columnIndices.map((i) => this.fields[i]).filter(Boolean), this.metadata);
      }
      assign(...args) {
        const other = args[0] instanceof _Schema ? args[0] : new _Schema(args_1.selectArgs(Field2, args));
        const curFields = [...this.fields];
        const metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), other.metadata);
        const newFields = other.fields.filter((f2) => {
          const i = curFields.findIndex((f) => f.name === f2.name);
          return ~i ? (curFields[i] = f2.clone({
            metadata: mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), curFields[i].metadata), f2.metadata)
          })) && false : true;
        });
        const newDictionaries = generateDictionaryMap(newFields, /* @__PURE__ */ new Map());
        return new _Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
      }
    };
    exports.Schema = Schema2;
    var Field2 = class _Field {
      constructor(name, type, nullable = false, metadata) {
        this.name = name;
        this.type = type;
        this.nullable = nullable;
        this.metadata = metadata || /* @__PURE__ */ new Map();
      }
      /** @nocollapse */
      static new(...args) {
        let [name, type, nullable, metadata] = args;
        if (args[0] && typeof args[0] === "object") {
          ({ name } = args[0]);
          type === void 0 && (type = args[0].type);
          nullable === void 0 && (nullable = args[0].nullable);
          metadata === void 0 && (metadata = args[0].metadata);
        }
        return new _Field(`${name}`, type, nullable, metadata);
      }
      get typeId() {
        return this.type.typeId;
      }
      get [Symbol.toStringTag]() {
        return "Field";
      }
      toString() {
        return `${this.name}: ${this.type}`;
      }
      compareTo(other) {
        return typecomparator_1.instance.compareField(this, other);
      }
      clone(...args) {
        let [name, type, nullable, metadata] = args;
        !args[0] || typeof args[0] !== "object" ? [name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args : { name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0];
        return _Field.new(name, type, nullable, metadata);
      }
    };
    exports.Field = Field2;
    function mergeMaps(m1, m2) {
      return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
    }
    function generateDictionaryMap(fields, dictionaries = /* @__PURE__ */ new Map()) {
      for (let i = -1, n = fields.length; ++i < n; ) {
        const field = fields[i];
        const type = field.type;
        if (type_1.DataType.isDictionary(type)) {
          if (!dictionaries.has(type.id)) {
            dictionaries.set(type.id, type.dictionary);
          } else if (dictionaries.get(type.id) !== type.dictionary) {
            throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
          }
        }
        if (type.children && type.children.length > 0) {
          generateDictionaryMap(type.children, dictionaries);
        }
      }
      return dictionaries;
    }
    Schema2.prototype.fields = null;
    Schema2.prototype.metadata = null;
    Schema2.prototype.dictionaries = null;
    Field2.prototype.type = null;
    Field2.prototype.name = null;
    Field2.prototype.nullable = null;
    Field2.prototype.metadata = null;
  }
});

// node_modules/apache-arrow/builder/list.js
var require_list = __commonJS({
  "node_modules/apache-arrow/builder/list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var run_1 = require_run();
    var schema_1 = require_schema();
    var type_1 = require_type();
    var buffer_1 = require_buffer2();
    var builder_1 = require_builder();
    var ListBuilder2 = class extends builder_1.VariableWidthBuilder {
      constructor(opts) {
        super(opts);
        this._run = new run_1.Run();
        this._offsets = new buffer_1.OffsetsBufferBuilder();
      }
      addChild(child, name = "0") {
        if (this.numChildren > 0) {
          throw new Error("ListBuilder can only have one child.");
        }
        this.children[this.numChildren] = child;
        this.type = new type_1.List(new schema_1.Field(name, child.type, true));
        return this.numChildren - 1;
      }
      clear() {
        this._run.clear();
        return super.clear();
      }
      _flushPending(pending) {
        const run = this._run;
        const offsets = this._offsets;
        const setValue = this._setValue;
        let index = 0, value;
        for ([index, value] of pending) {
          if (value === void 0) {
            offsets.set(index, 0);
          } else {
            offsets.set(index, value.length);
            setValue(this, index, run.bind(value));
          }
        }
      }
    };
    exports.ListBuilder = ListBuilder2;
  }
});

// node_modules/apache-arrow/builder/fixedsizelist.js
var require_fixedsizelist = __commonJS({
  "node_modules/apache-arrow/builder/fixedsizelist.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var run_1 = require_run();
    var schema_1 = require_schema();
    var builder_1 = require_builder();
    var type_1 = require_type();
    var FixedSizeListBuilder2 = class extends builder_1.Builder {
      constructor() {
        super(...arguments);
        this._run = new run_1.Run();
      }
      setValue(index, value) {
        super.setValue(index, this._run.bind(value));
      }
      addChild(child, name = "0") {
        if (this.numChildren > 0) {
          throw new Error("FixedSizeListBuilder can only have one child.");
        }
        const childIndex = this.children.push(child);
        this.type = new type_1.FixedSizeList(this.type.listSize, new schema_1.Field(name, child.type, true));
        return childIndex;
      }
      clear() {
        this._run.clear();
        return super.clear();
      }
    };
    exports.FixedSizeListBuilder = FixedSizeListBuilder2;
  }
});

// node_modules/apache-arrow/builder/map.js
var require_map = __commonJS({
  "node_modules/apache-arrow/builder/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var type_1 = require_type();
    var builder_1 = require_builder();
    var MapBuilder2 = class extends builder_1.VariableWidthBuilder {
      set(index, value) {
        return super.set(index, value);
      }
      setValue(index, value) {
        value = value instanceof Map ? value : new Map(Object.entries(value));
        const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
        const current = pending.get(index);
        current && (this._pendingLength -= current.size);
        this._pendingLength += value.size;
        pending.set(index, value);
      }
      addChild(child, name = `${this.numChildren}`) {
        if (this.numChildren > 0) {
          throw new Error("ListBuilder can only have one child.");
        }
        this.children[this.numChildren] = child;
        this.type = new type_1.Map_(new schema_1.Field(name, child.type, true), this.type.keysSorted);
        return this.numChildren - 1;
      }
      _flushPending(pending) {
        const offsets = this._offsets;
        const setValue = this._setValue;
        pending.forEach((value, index) => {
          if (value === void 0) {
            offsets.set(index, 0);
          } else {
            offsets.set(index, value.size);
            setValue(this, index, value);
          }
        });
      }
    };
    exports.MapBuilder = MapBuilder2;
  }
});

// node_modules/apache-arrow/builder/struct.js
var require_struct = __commonJS({
  "node_modules/apache-arrow/builder/struct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var builder_1 = require_builder();
    var type_1 = require_type();
    var StructBuilder2 = class extends builder_1.Builder {
      addChild(child, name = `${this.numChildren}`) {
        const childIndex = this.children.push(child);
        this.type = new type_1.Struct([...this.type.children, new schema_1.Field(name, child.type, true)]);
        return childIndex;
      }
    };
    exports.StructBuilder = StructBuilder2;
  }
});

// node_modules/apache-arrow/builder/union.js
var require_union = __commonJS({
  "node_modules/apache-arrow/builder/union.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var buffer_1 = require_buffer2();
    var builder_1 = require_builder();
    var type_1 = require_type();
    var UnionBuilder2 = class extends builder_1.Builder {
      constructor(options) {
        super(options);
        this._typeIds = new buffer_1.DataBufferBuilder(new Int8Array(0), 1);
        if (typeof options["valueToChildTypeId"] === "function") {
          this._valueToChildTypeId = options["valueToChildTypeId"];
        }
      }
      get typeIdToChildIndex() {
        return this.type.typeIdToChildIndex;
      }
      append(value, childTypeId) {
        return this.set(this.length, value, childTypeId);
      }
      set(index, value, childTypeId) {
        if (childTypeId === void 0) {
          childTypeId = this._valueToChildTypeId(this, value, index);
        }
        if (this.setValid(index, this.isValid(value))) {
          this.setValue(index, value, childTypeId);
        }
        return this;
      }
      // @ts-ignore
      setValue(index, value, childTypeId) {
        this._typeIds.set(index, childTypeId);
        super.setValue(index, value);
      }
      // @ts-ignore
      addChild(child, name = `${this.children.length}`) {
        const childTypeId = this.children.push(child);
        const { type: { children, mode, typeIds } } = this;
        const fields = [...children, new schema_1.Field(name, child.type)];
        this.type = new type_1.Union(mode, [...typeIds, childTypeId], fields);
        return childTypeId;
      }
      /** @ignore */
      // @ts-ignore
      _valueToChildTypeId(builder, value, offset) {
        throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \`childTypeId\` as the second argument to unionBuilder.append(), or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
      }
    };
    exports.UnionBuilder = UnionBuilder2;
    var SparseUnionBuilder2 = class extends UnionBuilder2 {
    };
    exports.SparseUnionBuilder = SparseUnionBuilder2;
    var DenseUnionBuilder2 = class extends UnionBuilder2 {
      constructor(options) {
        super(options);
        this._offsets = new buffer_1.DataBufferBuilder(new Int32Array(0));
      }
      /** @ignore */
      setValue(index, value, childTypeId) {
        const childIndex = this.type.typeIdToChildIndex[childTypeId];
        this._offsets.set(index, this.getChildAt(childIndex).length);
        return super.setValue(index, value, childTypeId);
      }
    };
    exports.DenseUnionBuilder = DenseUnionBuilder2;
  }
});

// node_modules/apache-arrow/visitor/set.js
var require_set = __commonJS({
  "node_modules/apache-arrow/visitor/set.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var visitor_1 = require_visitor();
    var utf8_1 = require_utf8();
    var math_1 = require_math();
    var buffer_1 = require_buffer();
    var enum_1 = require_enum();
    var SetVisitor = class extends visitor_1.Visitor {
    };
    exports.SetVisitor = SetVisitor;
    var setEpochMsToDays = (data, index, epochMs) => {
      data[index] = epochMs / 864e5 | 0;
    };
    var setEpochMsToMillisecondsLong = (data, index, epochMs) => {
      data[index] = epochMs % 4294967296 | 0;
      data[index + 1] = epochMs / 4294967296 | 0;
    };
    var setEpochMsToMicrosecondsLong = (data, index, epochMs) => {
      data[index] = epochMs * 1e3 % 4294967296 | 0;
      data[index + 1] = epochMs * 1e3 / 4294967296 | 0;
    };
    var setEpochMsToNanosecondsLong = (data, index, epochMs) => {
      data[index] = epochMs * 1e6 % 4294967296 | 0;
      data[index + 1] = epochMs * 1e6 / 4294967296 | 0;
    };
    var setVariableWidthBytes = (values, valueOffsets, index, value) => {
      const { [index]: x, [index + 1]: y } = valueOffsets;
      if (x != null && y != null) {
        values.set(value.subarray(0, y - x), x);
      }
    };
    var setBool = ({ offset, values }, index, val) => {
      const idx = offset + index;
      val ? values[idx >> 3] |= 1 << idx % 8 : values[idx >> 3] &= ~(1 << idx % 8);
    };
    var setDateDay = ({ values }, index, value) => {
      setEpochMsToDays(values, index, value.valueOf());
    };
    var setDateMillisecond = ({ values }, index, value) => {
      setEpochMsToMillisecondsLong(values, index * 2, value.valueOf());
    };
    var setNumeric = ({ stride, values }, index, value) => {
      values[stride * index] = value;
    };
    var setFloat16 = ({ stride, values }, index, value) => {
      values[stride * index] = math_1.float64ToUint16(value);
    };
    var setNumericX2 = (vector, index, value) => {
      switch (typeof value) {
        case "bigint":
          vector.values64[index] = value;
          break;
        case "number":
          vector.values[index * vector.stride] = value;
          break;
        default:
          const val = value;
          const { stride, ArrayType } = vector;
          const long = buffer_1.toArrayBufferView(ArrayType, val);
          vector.values.set(long.subarray(0, stride), stride * index);
      }
    };
    var setFixedSizeBinary = ({ stride, values }, index, value) => {
      values.set(value.subarray(0, stride), stride * index);
    };
    var setBinary = ({ values, valueOffsets }, index, value) => setVariableWidthBytes(values, valueOffsets, index, value);
    var setUtf8 = ({ values, valueOffsets }, index, value) => {
      setVariableWidthBytes(values, valueOffsets, index, utf8_1.encodeUtf8(value));
    };
    var setInt = (vector, index, value) => {
      vector.type.bitWidth < 64 ? setNumeric(vector, index, value) : setNumericX2(vector, index, value);
    };
    var setFloat = (vector, index, value) => {
      vector.type.precision !== enum_1.Precision.HALF ? setNumeric(vector, index, value) : setFloat16(vector, index, value);
    };
    var setDate = (vector, index, value) => {
      vector.type.unit === enum_1.DateUnit.DAY ? setDateDay(vector, index, value) : setDateMillisecond(vector, index, value);
    };
    var setTimestampSecond = ({ values }, index, value) => setEpochMsToMillisecondsLong(values, index * 2, value / 1e3);
    var setTimestampMillisecond = ({ values }, index, value) => setEpochMsToMillisecondsLong(values, index * 2, value);
    var setTimestampMicrosecond = ({ values }, index, value) => setEpochMsToMicrosecondsLong(values, index * 2, value);
    var setTimestampNanosecond = ({ values }, index, value) => setEpochMsToNanosecondsLong(values, index * 2, value);
    var setTimestamp = (vector, index, value) => {
      switch (vector.type.unit) {
        case enum_1.TimeUnit.SECOND:
          return setTimestampSecond(vector, index, value);
        case enum_1.TimeUnit.MILLISECOND:
          return setTimestampMillisecond(vector, index, value);
        case enum_1.TimeUnit.MICROSECOND:
          return setTimestampMicrosecond(vector, index, value);
        case enum_1.TimeUnit.NANOSECOND:
          return setTimestampNanosecond(vector, index, value);
      }
    };
    var setTimeSecond = ({ values, stride }, index, value) => {
      values[stride * index] = value;
    };
    var setTimeMillisecond = ({ values, stride }, index, value) => {
      values[stride * index] = value;
    };
    var setTimeMicrosecond = ({ values }, index, value) => {
      values.set(value.subarray(0, 2), 2 * index);
    };
    var setTimeNanosecond = ({ values }, index, value) => {
      values.set(value.subarray(0, 2), 2 * index);
    };
    var setTime = (vector, index, value) => {
      switch (vector.type.unit) {
        case enum_1.TimeUnit.SECOND:
          return setTimeSecond(vector, index, value);
        case enum_1.TimeUnit.MILLISECOND:
          return setTimeMillisecond(vector, index, value);
        case enum_1.TimeUnit.MICROSECOND:
          return setTimeMicrosecond(vector, index, value);
        case enum_1.TimeUnit.NANOSECOND:
          return setTimeNanosecond(vector, index, value);
      }
    };
    var setDecimal = ({ values }, index, value) => {
      values.set(value.subarray(0, 4), 4 * index);
    };
    var setList = (vector, index, value) => {
      const values = vector.getChildAt(0), valueOffsets = vector.valueOffsets;
      for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
        values.set(itr++, value.get(++idx));
      }
    };
    var setMap = (vector, index, value) => {
      const values = vector.getChildAt(0), valueOffsets = vector.valueOffsets;
      const entries = value instanceof Map ? [...value] : Object.entries(value);
      for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
        values.set(itr++, entries[++idx]);
      }
    };
    var _setStructArrayValue = (o, v) => (c, _, i) => c && c.set(o, v[i]);
    var _setStructVectorValue = (o, v) => (c, _, i) => c && c.set(o, v.get(i));
    var _setStructMapValue = (o, v) => (c, f, _) => c && c.set(o, v.get(f.name));
    var _setStructObjectValue = (o, v) => (c, f, _) => c && c.set(o, v[f.name]);
    var setStruct = (vector, index, value) => {
      const setValue = value instanceof Map ? _setStructMapValue(index, value) : value instanceof vector_1.Vector ? _setStructVectorValue(index, value) : Array.isArray(value) ? _setStructArrayValue(index, value) : _setStructObjectValue(index, value);
      vector.type.children.forEach((f, i) => setValue(vector.getChildAt(i), f, i));
    };
    var setUnion = (vector, index, value) => {
      vector.type.mode === enum_1.UnionMode.Dense ? setDenseUnion(vector, index, value) : setSparseUnion(vector, index, value);
    };
    var setDenseUnion = (vector, index, value) => {
      const childIndex = vector.typeIdToChildIndex[vector.typeIds[index]];
      const child = vector.getChildAt(childIndex);
      child && child.set(vector.valueOffsets[index], value);
    };
    var setSparseUnion = (vector, index, value) => {
      const childIndex = vector.typeIdToChildIndex[vector.typeIds[index]];
      const child = vector.getChildAt(childIndex);
      child && child.set(index, value);
    };
    var setDictionary = (vector, index, value) => {
      const key = vector.getKey(index);
      if (key !== null) {
        vector.setValue(key, value);
      }
    };
    var setIntervalValue = (vector, index, value) => {
      vector.type.unit === enum_1.IntervalUnit.DAY_TIME ? setIntervalDayTime(vector, index, value) : setIntervalYearMonth(vector, index, value);
    };
    var setIntervalDayTime = ({ values }, index, value) => {
      values.set(value.subarray(0, 2), 2 * index);
    };
    var setIntervalYearMonth = ({ values }, index, value) => {
      values[index] = value[0] * 12 + value[1] % 12;
    };
    var setFixedSizeList = (vector, index, value) => {
      const child = vector.getChildAt(0), { stride } = vector;
      for (let idx = -1, offset = index * stride; ++idx < stride; ) {
        child.set(offset + idx, value.get(idx));
      }
    };
    SetVisitor.prototype.visitBool = setBool;
    SetVisitor.prototype.visitInt = setInt;
    SetVisitor.prototype.visitInt8 = setNumeric;
    SetVisitor.prototype.visitInt16 = setNumeric;
    SetVisitor.prototype.visitInt32 = setNumeric;
    SetVisitor.prototype.visitInt64 = setNumericX2;
    SetVisitor.prototype.visitUint8 = setNumeric;
    SetVisitor.prototype.visitUint16 = setNumeric;
    SetVisitor.prototype.visitUint32 = setNumeric;
    SetVisitor.prototype.visitUint64 = setNumericX2;
    SetVisitor.prototype.visitFloat = setFloat;
    SetVisitor.prototype.visitFloat16 = setFloat16;
    SetVisitor.prototype.visitFloat32 = setNumeric;
    SetVisitor.prototype.visitFloat64 = setNumeric;
    SetVisitor.prototype.visitUtf8 = setUtf8;
    SetVisitor.prototype.visitBinary = setBinary;
    SetVisitor.prototype.visitFixedSizeBinary = setFixedSizeBinary;
    SetVisitor.prototype.visitDate = setDate;
    SetVisitor.prototype.visitDateDay = setDateDay;
    SetVisitor.prototype.visitDateMillisecond = setDateMillisecond;
    SetVisitor.prototype.visitTimestamp = setTimestamp;
    SetVisitor.prototype.visitTimestampSecond = setTimestampSecond;
    SetVisitor.prototype.visitTimestampMillisecond = setTimestampMillisecond;
    SetVisitor.prototype.visitTimestampMicrosecond = setTimestampMicrosecond;
    SetVisitor.prototype.visitTimestampNanosecond = setTimestampNanosecond;
    SetVisitor.prototype.visitTime = setTime;
    SetVisitor.prototype.visitTimeSecond = setTimeSecond;
    SetVisitor.prototype.visitTimeMillisecond = setTimeMillisecond;
    SetVisitor.prototype.visitTimeMicrosecond = setTimeMicrosecond;
    SetVisitor.prototype.visitTimeNanosecond = setTimeNanosecond;
    SetVisitor.prototype.visitDecimal = setDecimal;
    SetVisitor.prototype.visitList = setList;
    SetVisitor.prototype.visitStruct = setStruct;
    SetVisitor.prototype.visitUnion = setUnion;
    SetVisitor.prototype.visitDenseUnion = setDenseUnion;
    SetVisitor.prototype.visitSparseUnion = setSparseUnion;
    SetVisitor.prototype.visitDictionary = setDictionary;
    SetVisitor.prototype.visitInterval = setIntervalValue;
    SetVisitor.prototype.visitIntervalDayTime = setIntervalDayTime;
    SetVisitor.prototype.visitIntervalYearMonth = setIntervalYearMonth;
    SetVisitor.prototype.visitFixedSizeList = setFixedSizeList;
    SetVisitor.prototype.visitMap = setMap;
    exports.instance = new SetVisitor();
  }
});

// node_modules/apache-arrow/visitor/builderctor.js
var require_builderctor = __commonJS({
  "node_modules/apache-arrow/visitor/builderctor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var binary_1 = require_binary();
    var bool_1 = require_bool();
    var date_1 = require_date();
    var decimal_1 = require_decimal();
    var dictionary_1 = require_dictionary();
    var fixedsizebinary_1 = require_fixedsizebinary();
    var fixedsizelist_1 = require_fixedsizelist();
    var float_1 = require_float();
    var interval_1 = require_interval();
    var int_1 = require_int();
    var list_1 = require_list();
    var map_1 = require_map();
    var null_1 = require_null();
    var struct_1 = require_struct();
    var timestamp_1 = require_timestamp();
    var time_1 = require_time();
    var union_1 = require_union();
    var utf8_1 = require_utf82();
    var GetBuilderCtor = class extends visitor_1.Visitor {
      visitNull() {
        return null_1.NullBuilder;
      }
      visitBool() {
        return bool_1.BoolBuilder;
      }
      visitInt() {
        return int_1.IntBuilder;
      }
      visitInt8() {
        return int_1.Int8Builder;
      }
      visitInt16() {
        return int_1.Int16Builder;
      }
      visitInt32() {
        return int_1.Int32Builder;
      }
      visitInt64() {
        return int_1.Int64Builder;
      }
      visitUint8() {
        return int_1.Uint8Builder;
      }
      visitUint16() {
        return int_1.Uint16Builder;
      }
      visitUint32() {
        return int_1.Uint32Builder;
      }
      visitUint64() {
        return int_1.Uint64Builder;
      }
      visitFloat() {
        return float_1.FloatBuilder;
      }
      visitFloat16() {
        return float_1.Float16Builder;
      }
      visitFloat32() {
        return float_1.Float32Builder;
      }
      visitFloat64() {
        return float_1.Float64Builder;
      }
      visitUtf8() {
        return utf8_1.Utf8Builder;
      }
      visitBinary() {
        return binary_1.BinaryBuilder;
      }
      visitFixedSizeBinary() {
        return fixedsizebinary_1.FixedSizeBinaryBuilder;
      }
      visitDate() {
        return date_1.DateBuilder;
      }
      visitDateDay() {
        return date_1.DateDayBuilder;
      }
      visitDateMillisecond() {
        return date_1.DateMillisecondBuilder;
      }
      visitTimestamp() {
        return timestamp_1.TimestampBuilder;
      }
      visitTimestampSecond() {
        return timestamp_1.TimestampSecondBuilder;
      }
      visitTimestampMillisecond() {
        return timestamp_1.TimestampMillisecondBuilder;
      }
      visitTimestampMicrosecond() {
        return timestamp_1.TimestampMicrosecondBuilder;
      }
      visitTimestampNanosecond() {
        return timestamp_1.TimestampNanosecondBuilder;
      }
      visitTime() {
        return time_1.TimeBuilder;
      }
      visitTimeSecond() {
        return time_1.TimeSecondBuilder;
      }
      visitTimeMillisecond() {
        return time_1.TimeMillisecondBuilder;
      }
      visitTimeMicrosecond() {
        return time_1.TimeMicrosecondBuilder;
      }
      visitTimeNanosecond() {
        return time_1.TimeNanosecondBuilder;
      }
      visitDecimal() {
        return decimal_1.DecimalBuilder;
      }
      visitList() {
        return list_1.ListBuilder;
      }
      visitStruct() {
        return struct_1.StructBuilder;
      }
      visitUnion() {
        return union_1.UnionBuilder;
      }
      visitDenseUnion() {
        return union_1.DenseUnionBuilder;
      }
      visitSparseUnion() {
        return union_1.SparseUnionBuilder;
      }
      visitDictionary() {
        return dictionary_1.DictionaryBuilder;
      }
      visitInterval() {
        return interval_1.IntervalBuilder;
      }
      visitIntervalDayTime() {
        return interval_1.IntervalDayTimeBuilder;
      }
      visitIntervalYearMonth() {
        return interval_1.IntervalYearMonthBuilder;
      }
      visitFixedSizeList() {
        return fixedsizelist_1.FixedSizeListBuilder;
      }
      visitMap() {
        return map_1.MapBuilder;
      }
    };
    exports.GetBuilderCtor = GetBuilderCtor;
    exports.instance = new GetBuilderCtor();
  }
});

// node_modules/apache-arrow/builder/index.js
var require_builder2 = __commonJS({
  "node_modules/apache-arrow/builder/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    exports.Builder = builder_1.Builder;
    var bool_1 = require_bool();
    exports.BoolBuilder = bool_1.BoolBuilder;
    var null_1 = require_null();
    exports.NullBuilder = null_1.NullBuilder;
    var date_1 = require_date();
    exports.DateBuilder = date_1.DateBuilder;
    exports.DateDayBuilder = date_1.DateDayBuilder;
    exports.DateMillisecondBuilder = date_1.DateMillisecondBuilder;
    var decimal_1 = require_decimal();
    exports.DecimalBuilder = decimal_1.DecimalBuilder;
    var dictionary_1 = require_dictionary();
    exports.DictionaryBuilder = dictionary_1.DictionaryBuilder;
    var fixedsizebinary_1 = require_fixedsizebinary();
    exports.FixedSizeBinaryBuilder = fixedsizebinary_1.FixedSizeBinaryBuilder;
    var float_1 = require_float();
    exports.FloatBuilder = float_1.FloatBuilder;
    exports.Float16Builder = float_1.Float16Builder;
    exports.Float32Builder = float_1.Float32Builder;
    exports.Float64Builder = float_1.Float64Builder;
    var int_1 = require_int();
    exports.IntBuilder = int_1.IntBuilder;
    exports.Int8Builder = int_1.Int8Builder;
    exports.Int16Builder = int_1.Int16Builder;
    exports.Int32Builder = int_1.Int32Builder;
    exports.Int64Builder = int_1.Int64Builder;
    exports.Uint8Builder = int_1.Uint8Builder;
    exports.Uint16Builder = int_1.Uint16Builder;
    exports.Uint32Builder = int_1.Uint32Builder;
    exports.Uint64Builder = int_1.Uint64Builder;
    var time_1 = require_time();
    exports.TimeBuilder = time_1.TimeBuilder;
    exports.TimeSecondBuilder = time_1.TimeSecondBuilder;
    exports.TimeMillisecondBuilder = time_1.TimeMillisecondBuilder;
    exports.TimeMicrosecondBuilder = time_1.TimeMicrosecondBuilder;
    exports.TimeNanosecondBuilder = time_1.TimeNanosecondBuilder;
    var timestamp_1 = require_timestamp();
    exports.TimestampBuilder = timestamp_1.TimestampBuilder;
    exports.TimestampSecondBuilder = timestamp_1.TimestampSecondBuilder;
    exports.TimestampMillisecondBuilder = timestamp_1.TimestampMillisecondBuilder;
    exports.TimestampMicrosecondBuilder = timestamp_1.TimestampMicrosecondBuilder;
    exports.TimestampNanosecondBuilder = timestamp_1.TimestampNanosecondBuilder;
    var interval_1 = require_interval();
    exports.IntervalBuilder = interval_1.IntervalBuilder;
    exports.IntervalDayTimeBuilder = interval_1.IntervalDayTimeBuilder;
    exports.IntervalYearMonthBuilder = interval_1.IntervalYearMonthBuilder;
    var utf8_1 = require_utf82();
    exports.Utf8Builder = utf8_1.Utf8Builder;
    var binary_1 = require_binary();
    exports.BinaryBuilder = binary_1.BinaryBuilder;
    var list_1 = require_list();
    exports.ListBuilder = list_1.ListBuilder;
    var fixedsizelist_1 = require_fixedsizelist();
    exports.FixedSizeListBuilder = fixedsizelist_1.FixedSizeListBuilder;
    var map_1 = require_map();
    exports.MapBuilder = map_1.MapBuilder;
    var struct_1 = require_struct();
    exports.StructBuilder = struct_1.StructBuilder;
    var union_1 = require_union();
    exports.UnionBuilder = union_1.UnionBuilder;
    exports.SparseUnionBuilder = union_1.SparseUnionBuilder;
    exports.DenseUnionBuilder = union_1.DenseUnionBuilder;
    var enum_1 = require_enum();
    var utf8_2 = require_utf82();
    var builder_2 = require_builder();
    var set_1 = require_set();
    var builderctor_1 = require_builderctor();
    builder_2.Builder.new = newBuilder;
    function newBuilder(options) {
      const type = options.type;
      const builder = new (builderctor_1.instance.getVisitFn(type)())(options);
      if (type.children && type.children.length > 0) {
        const children = options["children"] || [];
        const defaultOptions = { "nullValues": options["nullValues"] };
        const getChildOptions = Array.isArray(children) ? (_, i) => children[i] || defaultOptions : ({ name }) => children[name] || defaultOptions;
        type.children.forEach((field, index) => {
          const { type: type2 } = field;
          const opts = getChildOptions(field, index);
          builder.children.push(newBuilder({ ...opts, type: type2 }));
        });
      }
      return builder;
    }
    Object.keys(enum_1.Type).map((T) => enum_1.Type[T]).filter((T) => typeof T === "number" && T !== enum_1.Type.NONE).forEach((typeId) => {
      const BuilderCtor = builderctor_1.instance.visit(typeId);
      BuilderCtor.prototype._setValue = set_1.instance.getVisitFn(typeId);
    });
    utf8_2.Utf8Builder.prototype._setValue = set_1.instance.visitBinary;
  }
});

// node_modules/apache-arrow/fb/File.js
var require_File = __commonJS({
  "node_modules/apache-arrow/fb/File.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NS7624605610262437867 = require_Schema();
    var org;
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Footer {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Footer
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * @param flatbuffers.ByteBuffer bb
               * @param Footer= obj
               * @returns Footer
               */
              static getRootAsFooter(bb, obj) {
                return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              /**
               * @returns org.apache.arrow.flatbuf.MetadataVersion
               */
              version() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? (
                  /**  */
                  this.bb.readInt16(this.bb_pos + offset)
                ) : NS7624605610262437867.org.apache.arrow.flatbuf.MetadataVersion.V1;
              }
              /**
               * @param org.apache.arrow.flatbuf.Schema= obj
               * @returns org.apache.arrow.flatbuf.Schema|null
               */
              schema(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new NS7624605610262437867.org.apache.arrow.flatbuf.Schema()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              /**
               * @param number index
               * @param org.apache.arrow.flatbuf.Block= obj
               * @returns org.apache.arrow.flatbuf.Block
               */
              dictionaries(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new org2.apache.arrow.flatbuf.Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
              }
              /**
               * @returns number
               */
              dictionariesLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param number index
               * @param org.apache.arrow.flatbuf.Block= obj
               * @returns org.apache.arrow.flatbuf.Block
               */
              recordBatches(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? (obj || new org2.apache.arrow.flatbuf.Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
              }
              /**
               * @returns number
               */
              recordBatchesLength() {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              /**
               * @param flatbuffers.Builder builder
               */
              static startFooter(builder) {
                builder.startObject(4);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param org.apache.arrow.flatbuf.MetadataVersion version
               */
              static addVersion(builder, version) {
                builder.addFieldInt16(0, version, NS7624605610262437867.org.apache.arrow.flatbuf.MetadataVersion.V1);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset schemaOffset
               */
              static addSchema(builder, schemaOffset) {
                builder.addFieldOffset(1, schemaOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset dictionariesOffset
               */
              static addDictionaries(builder, dictionariesOffset) {
                builder.addFieldOffset(2, dictionariesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startDictionariesVector(builder, numElems) {
                builder.startVector(24, numElems, 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset recordBatchesOffset
               */
              static addRecordBatches(builder, recordBatchesOffset) {
                builder.addFieldOffset(3, recordBatchesOffset, 0);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param number numElems
               */
              static startRecordBatchesVector(builder, numElems) {
                builder.startVector(24, numElems, 8);
              }
              /**
               * @param flatbuffers.Builder builder
               * @returns flatbuffers.Offset
               */
              static endFooter(builder) {
                let offset = builder.endObject();
                return offset;
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Offset offset
               */
              static finishFooterBuffer(builder, offset) {
                builder.finish(offset);
              }
              static createFooter(builder, version, schemaOffset, dictionariesOffset, recordBatchesOffset) {
                Footer.startFooter(builder);
                Footer.addVersion(builder, version);
                Footer.addSchema(builder, schemaOffset);
                Footer.addDictionaries(builder, dictionariesOffset);
                Footer.addRecordBatches(builder, recordBatchesOffset);
                return Footer.endFooter(builder);
              }
            }
            flatbuf2.Footer = Footer;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Block {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              /**
               * @param number i
               * @param flatbuffers.ByteBuffer bb
               * @returns Block
               */
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              /**
               * Index to the start of the RecordBlock (note this is past the Message header)
               *
               * @returns flatbuffers.Long
               */
              offset() {
                return this.bb.readInt64(this.bb_pos);
              }
              /**
               * Length of the metadata
               *
               * @returns number
               */
              metaDataLength() {
                return this.bb.readInt32(this.bb_pos + 8);
              }
              /**
               * Length of the data (this is aligned so there can be a gap between this and
               * the metatdata).
               *
               * @returns flatbuffers.Long
               */
              bodyLength() {
                return this.bb.readInt64(this.bb_pos + 16);
              }
              /**
               * @param flatbuffers.Builder builder
               * @param flatbuffers.Long offset
               * @param number metaDataLength
               * @param flatbuffers.Long bodyLength
               * @returns flatbuffers.Offset
               */
              static createBlock(builder, offset, metaDataLength, bodyLength) {
                builder.prep(8, 24);
                builder.writeInt64(bodyLength);
                builder.pad(4);
                builder.writeInt32(metaDataLength);
                builder.writeInt64(offset);
                return builder.offset();
              }
            }
            flatbuf2.Block = Block;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
  }
});

// node_modules/apache-arrow/ipc/metadata/file.js
var require_file = __commonJS({
  "node_modules/apache-arrow/ipc/metadata/file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var File_ = require_File();
    var flatbuffers_1 = (init_flatbuffers(), __toCommonJS(flatbuffers_exports));
    var Long = flatbuffers_1.flatbuffers.Long;
    var Builder3 = flatbuffers_1.flatbuffers.Builder;
    var ByteBuffer = flatbuffers_1.flatbuffers.ByteBuffer;
    var _Block = File_.org.apache.arrow.flatbuf.Block;
    var _Footer = File_.org.apache.arrow.flatbuf.Footer;
    var schema_1 = require_schema();
    var enum_1 = require_enum();
    var buffer_1 = require_buffer();
    var Footer_ = class {
      constructor(schema, version = enum_1.MetadataVersion.V4, recordBatches, dictionaryBatches) {
        this.schema = schema;
        this.version = version;
        recordBatches && (this._recordBatches = recordBatches);
        dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
      }
      /** @nocollapse */
      static decode(buf) {
        buf = new ByteBuffer(buffer_1.toUint8Array(buf));
        const footer = _Footer.getRootAsFooter(buf);
        const schema = schema_1.Schema.decode(footer.schema());
        return new OffHeapFooter(schema, footer);
      }
      /** @nocollapse */
      static encode(footer) {
        const b = new Builder3();
        const schemaOffset = schema_1.Schema.encode(b, footer.schema);
        _Footer.startRecordBatchesVector(b, footer.numRecordBatches);
        [...footer.recordBatches()].slice().reverse().forEach((rb) => FileBlock.encode(b, rb));
        const recordBatchesOffset = b.endVector();
        _Footer.startDictionariesVector(b, footer.numDictionaries);
        [...footer.dictionaryBatches()].slice().reverse().forEach((db) => FileBlock.encode(b, db));
        const dictionaryBatchesOffset = b.endVector();
        _Footer.startFooter(b);
        _Footer.addSchema(b, schemaOffset);
        _Footer.addVersion(b, enum_1.MetadataVersion.V4);
        _Footer.addRecordBatches(b, recordBatchesOffset);
        _Footer.addDictionaries(b, dictionaryBatchesOffset);
        _Footer.finishFooterBuffer(b, _Footer.endFooter(b));
        return b.asUint8Array();
      }
      get numRecordBatches() {
        return this._recordBatches.length;
      }
      get numDictionaries() {
        return this._dictionaryBatches.length;
      }
      *recordBatches() {
        for (let block, i = -1, n = this.numRecordBatches; ++i < n; ) {
          if (block = this.getRecordBatch(i)) {
            yield block;
          }
        }
      }
      *dictionaryBatches() {
        for (let block, i = -1, n = this.numDictionaries; ++i < n; ) {
          if (block = this.getDictionaryBatch(i)) {
            yield block;
          }
        }
      }
      getRecordBatch(index) {
        return index >= 0 && index < this.numRecordBatches && this._recordBatches[index] || null;
      }
      getDictionaryBatch(index) {
        return index >= 0 && index < this.numDictionaries && this._dictionaryBatches[index] || null;
      }
    };
    exports.Footer = Footer_;
    var OffHeapFooter = class extends Footer_ {
      constructor(schema, _footer) {
        super(schema, _footer.version());
        this._footer = _footer;
      }
      get numRecordBatches() {
        return this._footer.recordBatchesLength();
      }
      get numDictionaries() {
        return this._footer.dictionariesLength();
      }
      getRecordBatch(index) {
        if (index >= 0 && index < this.numRecordBatches) {
          const fileBlock = this._footer.recordBatches(index);
          if (fileBlock) {
            return FileBlock.decode(fileBlock);
          }
        }
        return null;
      }
      getDictionaryBatch(index) {
        if (index >= 0 && index < this.numDictionaries) {
          const fileBlock = this._footer.dictionaries(index);
          if (fileBlock) {
            return FileBlock.decode(fileBlock);
          }
        }
        return null;
      }
    };
    var FileBlock = class _FileBlock {
      /** @nocollapse */
      static decode(block) {
        return new _FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
      }
      /** @nocollapse */
      static encode(b, fileBlock) {
        const { metaDataLength } = fileBlock;
        const offset = new Long(fileBlock.offset, 0);
        const bodyLength = new Long(fileBlock.bodyLength, 0);
        return _Block.createBlock(b, offset, metaDataLength, bodyLength);
      }
      constructor(metaDataLength, bodyLength, offset) {
        this.metaDataLength = metaDataLength;
        this.offset = typeof offset === "number" ? offset : offset.low;
        this.bodyLength = typeof bodyLength === "number" ? bodyLength : bodyLength.low;
      }
    };
    exports.FileBlock = FileBlock;
  }
});

// node_modules/apache-arrow/io/stream.js
var require_stream = __commonJS({
  "node_modules/apache-arrow/io/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var adapters_1 = require_adapters();
    var utf8_1 = require_utf8();
    var interfaces_1 = require_interfaces();
    var buffer_1 = require_buffer();
    var compat_1 = require_compat();
    var AsyncByteQueue2 = class extends interfaces_1.AsyncQueue {
      write(value) {
        if ((value = buffer_1.toUint8Array(value)).byteLength > 0) {
          return super.write(value);
        }
      }
      toString(sync = false) {
        return sync ? utf8_1.decodeUtf8(this.toUint8Array(true)) : this.toUint8Array(false).then(utf8_1.decodeUtf8);
      }
      toUint8Array(sync = false) {
        return sync ? buffer_1.joinUint8Arrays(this._values)[0] : (async () => {
          let buffers = [], byteLength = 0;
          for await (const chunk of this) {
            buffers.push(chunk);
            byteLength += chunk.byteLength;
          }
          return buffer_1.joinUint8Arrays(buffers, byteLength)[0];
        })();
      }
    };
    exports.AsyncByteQueue = AsyncByteQueue2;
    var ByteStream2 = class {
      constructor(source) {
        if (source) {
          this.source = new ByteStreamSource(adapters_1.default.fromIterable(source));
        }
      }
      [Symbol.iterator]() {
        return this;
      }
      next(value) {
        return this.source.next(value);
      }
      throw(value) {
        return this.source.throw(value);
      }
      return(value) {
        return this.source.return(value);
      }
      peek(size) {
        return this.source.peek(size);
      }
      read(size) {
        return this.source.read(size);
      }
    };
    exports.ByteStream = ByteStream2;
    var AsyncByteStream2 = class _AsyncByteStream {
      constructor(source) {
        if (source instanceof _AsyncByteStream) {
          this.source = source.source;
        } else if (source instanceof AsyncByteQueue2) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromAsyncIterable(source));
        } else if (compat_1.isReadableNodeStream(source)) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromNodeStream(source));
        } else if (compat_1.isReadableDOMStream(source)) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromDOMStream(source));
        } else if (compat_1.isFetchResponse(source)) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromDOMStream(source.body));
        } else if (compat_1.isIterable(source)) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromIterable(source));
        } else if (compat_1.isPromise(source)) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromAsyncIterable(source));
        } else if (compat_1.isAsyncIterable(source)) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromAsyncIterable(source));
        }
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      next(value) {
        return this.source.next(value);
      }
      throw(value) {
        return this.source.throw(value);
      }
      return(value) {
        return this.source.return(value);
      }
      get closed() {
        return this.source.closed;
      }
      cancel(reason) {
        return this.source.cancel(reason);
      }
      peek(size) {
        return this.source.peek(size);
      }
      read(size) {
        return this.source.read(size);
      }
    };
    exports.AsyncByteStream = AsyncByteStream2;
    var ByteStreamSource = class {
      constructor(source) {
        this.source = source;
      }
      cancel(reason) {
        this.return(reason);
      }
      peek(size) {
        return this.next(size, "peek").value;
      }
      read(size) {
        return this.next(size, "read").value;
      }
      next(size, cmd = "read") {
        return this.source.next({ cmd, size });
      }
      throw(value) {
        return Object.create(this.source.throw && this.source.throw(value) || interfaces_1.ITERATOR_DONE);
      }
      return(value) {
        return Object.create(this.source.return && this.source.return(value) || interfaces_1.ITERATOR_DONE);
      }
    };
    var AsyncByteStreamSource = class {
      constructor(source) {
        this.source = source;
        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
      }
      async cancel(reason) {
        await this.return(reason);
      }
      get closed() {
        return this._closedPromise;
      }
      async read(size) {
        return (await this.next(size, "read")).value;
      }
      async peek(size) {
        return (await this.next(size, "peek")).value;
      }
      async next(size, cmd = "read") {
        return await this.source.next({ cmd, size });
      }
      async throw(value) {
        const result = this.source.throw && await this.source.throw(value) || interfaces_1.ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
        return Object.create(result);
      }
      async return(value) {
        const result = this.source.return && await this.source.return(value) || interfaces_1.ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
        return Object.create(result);
      }
    };
  }
});

// node_modules/apache-arrow/io/file.js
var require_file2 = __commonJS({
  "node_modules/apache-arrow/io/file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require_stream();
    var buffer_1 = require_buffer();
    var RandomAccessFile = class extends stream_1.ByteStream {
      constructor(buffer, byteLength) {
        super();
        this.position = 0;
        this.buffer = buffer_1.toUint8Array(buffer);
        this.size = typeof byteLength === "undefined" ? this.buffer.byteLength : byteLength;
      }
      readInt32(position) {
        const { buffer, byteOffset } = this.readAt(position, 4);
        return new DataView(buffer, byteOffset).getInt32(0, true);
      }
      seek(position) {
        this.position = Math.min(position, this.size);
        return position < this.size;
      }
      read(nBytes) {
        const { buffer, size, position } = this;
        if (buffer && position < size) {
          if (typeof nBytes !== "number") {
            nBytes = Infinity;
          }
          this.position = Math.min(size, position + Math.min(size - position, nBytes));
          return buffer.subarray(position, this.position);
        }
        return null;
      }
      readAt(position, nBytes) {
        const buf = this.buffer;
        const end = Math.min(this.size, position + nBytes);
        return buf ? buf.subarray(position, end) : new Uint8Array(nBytes);
      }
      close() {
        this.buffer && (this.buffer = null);
      }
      throw(value) {
        this.close();
        return { done: true, value };
      }
      return(value) {
        this.close();
        return { done: true, value };
      }
    };
    exports.RandomAccessFile = RandomAccessFile;
    var AsyncRandomAccessFile = class extends stream_1.AsyncByteStream {
      constructor(file, byteLength) {
        super();
        this.position = 0;
        this._handle = file;
        if (typeof byteLength === "number") {
          this.size = byteLength;
        } else {
          this._pending = (async () => {
            this.size = (await file.stat()).size;
            delete this._pending;
          })();
        }
      }
      async readInt32(position) {
        const { buffer, byteOffset } = await this.readAt(position, 4);
        return new DataView(buffer, byteOffset).getInt32(0, true);
      }
      async seek(position) {
        this._pending && await this._pending;
        this.position = Math.min(position, this.size);
        return position < this.size;
      }
      async read(nBytes) {
        this._pending && await this._pending;
        const { _handle: file, size, position } = this;
        if (file && position < size) {
          if (typeof nBytes !== "number") {
            nBytes = Infinity;
          }
          let pos = position, offset = 0, bytesRead = 0;
          let end = Math.min(size, pos + Math.min(size - pos, nBytes));
          let buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
          while ((pos += bytesRead) < end && (offset += bytesRead) < buffer.byteLength) {
            ({ bytesRead } = await file.read(buffer, offset, buffer.byteLength - offset, pos));
          }
          return buffer;
        }
        return null;
      }
      async readAt(position, nBytes) {
        this._pending && await this._pending;
        const { _handle: file, size } = this;
        if (file && position + nBytes < size) {
          const end = Math.min(size, position + nBytes);
          const buffer = new Uint8Array(end - position);
          return (await file.read(buffer, 0, nBytes, position)).buffer;
        }
        return new Uint8Array(nBytes);
      }
      async close() {
        const f = this._handle;
        this._handle = null;
        f && await f.close();
      }
      async throw(value) {
        await this.close();
        return { done: true, value };
      }
      async return(value) {
        await this.close();
        return { done: true, value };
      }
    };
    exports.AsyncRandomAccessFile = AsyncRandomAccessFile;
  }
});

// node_modules/apache-arrow/util/int.js
var require_int2 = __commonJS({
  "node_modules/apache-arrow/util/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var carryBit16 = 1 << 16;
    function intAsHex(value) {
      if (value < 0) {
        value = 4294967295 + value + 1;
      }
      return `0x${value.toString(16)}`;
    }
    var kInt32DecimalDigits = 8;
    var kPowersOfTen = [
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8
    ];
    var BaseInt64 = class {
      constructor(buffer) {
        this.buffer = buffer;
      }
      high() {
        return this.buffer[1];
      }
      low() {
        return this.buffer[0];
      }
      _times(other) {
        const L = new Uint32Array([
          this.buffer[1] >>> 16,
          this.buffer[1] & 65535,
          this.buffer[0] >>> 16,
          this.buffer[0] & 65535
        ]);
        const R = new Uint32Array([
          other.buffer[1] >>> 16,
          other.buffer[1] & 65535,
          other.buffer[0] >>> 16,
          other.buffer[0] & 65535
        ]);
        let product = L[3] * R[3];
        this.buffer[0] = product & 65535;
        let sum = product >>> 16;
        product = L[2] * R[3];
        sum += product;
        product = L[3] * R[2] >>> 0;
        sum += product;
        this.buffer[0] += sum << 16;
        this.buffer[1] = sum >>> 0 < product ? carryBit16 : 0;
        this.buffer[1] += sum >>> 16;
        this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
        this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;
        return this;
      }
      _plus(other) {
        const sum = this.buffer[0] + other.buffer[0] >>> 0;
        this.buffer[1] += other.buffer[1];
        if (sum < this.buffer[0] >>> 0) {
          ++this.buffer[1];
        }
        this.buffer[0] = sum;
      }
      lessThan(other) {
        return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
      }
      equals(other) {
        return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
      }
      greaterThan(other) {
        return other.lessThan(this);
      }
      hex() {
        return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
      }
    };
    exports.BaseInt64 = BaseInt64;
    var Uint642 = class _Uint64 extends BaseInt64 {
      times(other) {
        this._times(other);
        return this;
      }
      plus(other) {
        this._plus(other);
        return this;
      }
      /** @nocollapse */
      static from(val, out_buffer = new Uint32Array(2)) {
        return _Uint64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
      }
      /** @nocollapse */
      static fromNumber(num, out_buffer = new Uint32Array(2)) {
        return _Uint64.fromString(num.toString(), out_buffer);
      }
      /** @nocollapse */
      static fromString(str, out_buffer = new Uint32Array(2)) {
        const length = str.length;
        let out = new _Uint64(out_buffer);
        for (let posn = 0; posn < length; ) {
          const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
          const chunk = new _Uint64(new Uint32Array([parseInt(str.substr(posn, group), 10), 0]));
          const multiple = new _Uint64(new Uint32Array([kPowersOfTen[group], 0]));
          out.times(multiple);
          out.plus(chunk);
          posn += group;
        }
        return out;
      }
      /** @nocollapse */
      static convertArray(values) {
        const data = new Uint32Array(values.length * 2);
        for (let i = -1, n = values.length; ++i < n; ) {
          _Uint64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
        }
        return data;
      }
      /** @nocollapse */
      static multiply(left, right) {
        let rtrn = new _Uint64(new Uint32Array(left.buffer));
        return rtrn.times(right);
      }
      /** @nocollapse */
      static add(left, right) {
        let rtrn = new _Uint64(new Uint32Array(left.buffer));
        return rtrn.plus(right);
      }
    };
    exports.Uint64 = Uint642;
    var Int642 = class _Int64 extends BaseInt64 {
      negate() {
        this.buffer[0] = ~this.buffer[0] + 1;
        this.buffer[1] = ~this.buffer[1];
        if (this.buffer[0] == 0) {
          ++this.buffer[1];
        }
        return this;
      }
      times(other) {
        this._times(other);
        return this;
      }
      plus(other) {
        this._plus(other);
        return this;
      }
      lessThan(other) {
        const this_high = this.buffer[1] << 0;
        const other_high = other.buffer[1] << 0;
        return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];
      }
      /** @nocollapse */
      static from(val, out_buffer = new Uint32Array(2)) {
        return _Int64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
      }
      /** @nocollapse */
      static fromNumber(num, out_buffer = new Uint32Array(2)) {
        return _Int64.fromString(num.toString(), out_buffer);
      }
      /** @nocollapse */
      static fromString(str, out_buffer = new Uint32Array(2)) {
        const negate = str.startsWith("-");
        const length = str.length;
        let out = new _Int64(out_buffer);
        for (let posn = negate ? 1 : 0; posn < length; ) {
          const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
          const chunk = new _Int64(new Uint32Array([parseInt(str.substr(posn, group), 10), 0]));
          const multiple = new _Int64(new Uint32Array([kPowersOfTen[group], 0]));
          out.times(multiple);
          out.plus(chunk);
          posn += group;
        }
        return negate ? out.negate() : out;
      }
      /** @nocollapse */
      static convertArray(values) {
        const data = new Uint32Array(values.length * 2);
        for (let i = -1, n = values.length; ++i < n; ) {
          _Int64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
        }
        return data;
      }
      /** @nocollapse */
      static multiply(left, right) {
        let rtrn = new _Int64(new Uint32Array(left.buffer));
        return rtrn.times(right);
      }
      /** @nocollapse */
      static add(left, right) {
        let rtrn = new _Int64(new Uint32Array(left.buffer));
        return rtrn.plus(right);
      }
    };
    exports.Int64 = Int642;
    var Int128 = class _Int128 {
      constructor(buffer) {
        this.buffer = buffer;
      }
      high() {
        return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
      }
      low() {
        return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
      }
      negate() {
        this.buffer[0] = ~this.buffer[0] + 1;
        this.buffer[1] = ~this.buffer[1];
        this.buffer[2] = ~this.buffer[2];
        this.buffer[3] = ~this.buffer[3];
        if (this.buffer[0] == 0) {
          ++this.buffer[1];
        }
        if (this.buffer[1] == 0) {
          ++this.buffer[2];
        }
        if (this.buffer[2] == 0) {
          ++this.buffer[3];
        }
        return this;
      }
      times(other) {
        const L0 = new Uint642(new Uint32Array([this.buffer[3], 0]));
        const L1 = new Uint642(new Uint32Array([this.buffer[2], 0]));
        const L2 = new Uint642(new Uint32Array([this.buffer[1], 0]));
        const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));
        const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));
        const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));
        const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));
        const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));
        let product = Uint642.multiply(L3, R3);
        this.buffer[0] = product.low();
        let sum = new Uint642(new Uint32Array([product.high(), 0]));
        product = Uint642.multiply(L2, R3);
        sum.plus(product);
        product = Uint642.multiply(L3, R2);
        sum.plus(product);
        this.buffer[1] = sum.low();
        this.buffer[3] = sum.lessThan(product) ? 1 : 0;
        this.buffer[2] = sum.high();
        let high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
        high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));
        this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();
        return this;
      }
      plus(other) {
        let sums = new Uint32Array(4);
        sums[3] = this.buffer[3] + other.buffer[3] >>> 0;
        sums[2] = this.buffer[2] + other.buffer[2] >>> 0;
        sums[1] = this.buffer[1] + other.buffer[1] >>> 0;
        sums[0] = this.buffer[0] + other.buffer[0] >>> 0;
        if (sums[0] < this.buffer[0] >>> 0) {
          ++sums[1];
        }
        if (sums[1] < this.buffer[1] >>> 0) {
          ++sums[2];
        }
        if (sums[2] < this.buffer[2] >>> 0) {
          ++sums[3];
        }
        this.buffer[3] = sums[3];
        this.buffer[2] = sums[2];
        this.buffer[1] = sums[1];
        this.buffer[0] = sums[0];
        return this;
      }
      hex() {
        return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
      }
      /** @nocollapse */
      static multiply(left, right) {
        let rtrn = new _Int128(new Uint32Array(left.buffer));
        return rtrn.times(right);
      }
      /** @nocollapse */
      static add(left, right) {
        let rtrn = new _Int128(new Uint32Array(left.buffer));
        return rtrn.plus(right);
      }
      /** @nocollapse */
      static from(val, out_buffer = new Uint32Array(4)) {
        return _Int128.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
      }
      /** @nocollapse */
      static fromNumber(num, out_buffer = new Uint32Array(4)) {
        return _Int128.fromString(num.toString(), out_buffer);
      }
      /** @nocollapse */
      static fromString(str, out_buffer = new Uint32Array(4)) {
        const negate = str.startsWith("-");
        const length = str.length;
        let out = new _Int128(out_buffer);
        for (let posn = negate ? 1 : 0; posn < length; ) {
          const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
          const chunk = new _Int128(new Uint32Array([parseInt(str.substr(posn, group), 10), 0, 0, 0]));
          const multiple = new _Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));
          out.times(multiple);
          out.plus(chunk);
          posn += group;
        }
        return negate ? out.negate() : out;
      }
      /** @nocollapse */
      static convertArray(values) {
        const data = new Uint32Array(values.length * 4);
        for (let i = -1, n = values.length; ++i < n; ) {
          _Int128.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
        }
        return data;
      }
    };
    exports.Int128 = Int128;
  }
});

// node_modules/apache-arrow/visitor/vectorloader.js
var require_vectorloader = __commonJS({
  "node_modules/apache-arrow/visitor/vectorloader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var schema_1 = require_schema();
    var type_1 = require_type();
    var visitor_1 = require_visitor();
    var bit_1 = require_bit();
    var utf8_1 = require_utf8();
    var int_1 = require_int2();
    var enum_1 = require_enum();
    var buffer_1 = require_buffer();
    var VectorLoader = class extends visitor_1.Visitor {
      constructor(bytes, nodes, buffers, dictionaries) {
        super();
        this.nodesIndex = -1;
        this.buffersIndex = -1;
        this.bytes = bytes;
        this.nodes = nodes;
        this.buffers = buffers;
        this.dictionaries = dictionaries;
      }
      visit(node) {
        return super.visit(node instanceof schema_1.Field ? node.type : node);
      }
      visitNull(type, { length } = this.nextFieldNode()) {
        return data_1.Data.Null(type, 0, length);
      }
      visitBool(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Bool(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitInt(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Int(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitFloat(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Float(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitUtf8(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Utf8(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readOffsets(type), this.readData(type));
      }
      visitBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Binary(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readOffsets(type), this.readData(type));
      }
      visitFixedSizeBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.FixedSizeBinary(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitDate(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Date(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitTimestamp(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Timestamp(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitTime(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Time(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitDecimal(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Decimal(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitList(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.List(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readOffsets(type), this.visit(type.children[0]));
      }
      visitStruct(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Struct(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.visitMany(type.children));
      }
      visitUnion(type) {
        return type.mode === enum_1.UnionMode.Sparse ? this.visitSparseUnion(type) : this.visitDenseUnion(type);
      }
      visitDenseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Union(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readTypeIds(type), this.readOffsets(type), this.visitMany(type.children));
      }
      visitSparseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Union(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readTypeIds(type), this.visitMany(type.children));
      }
      visitDictionary(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Dictionary(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type.indices), this.readDictionary(type));
      }
      visitInterval(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Interval(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitFixedSizeList(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.FixedSizeList(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.visit(type.children[0]));
      }
      visitMap(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Map(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readOffsets(type), this.visit(type.children[0]));
      }
      nextFieldNode() {
        return this.nodes[++this.nodesIndex];
      }
      nextBufferRange() {
        return this.buffers[++this.buffersIndex];
      }
      readNullBitmap(type, nullCount, buffer = this.nextBufferRange()) {
        return nullCount > 0 && this.readData(type, buffer) || new Uint8Array(0);
      }
      readOffsets(type, buffer) {
        return this.readData(type, buffer);
      }
      readTypeIds(type, buffer) {
        return this.readData(type, buffer);
      }
      readData(_type, { length, offset } = this.nextBufferRange()) {
        return this.bytes.subarray(offset, offset + length);
      }
      readDictionary(type) {
        return this.dictionaries.get(type.id);
      }
    };
    exports.VectorLoader = VectorLoader;
    var JSONVectorLoader = class extends VectorLoader {
      constructor(sources, nodes, buffers, dictionaries) {
        super(new Uint8Array(0), nodes, buffers, dictionaries);
        this.sources = sources;
      }
      readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {
        return nullCount <= 0 ? new Uint8Array(0) : bit_1.packBools(this.sources[offset]);
      }
      readOffsets(_type, { offset } = this.nextBufferRange()) {
        return buffer_1.toArrayBufferView(Uint8Array, buffer_1.toArrayBufferView(Int32Array, this.sources[offset]));
      }
      readTypeIds(type, { offset } = this.nextBufferRange()) {
        return buffer_1.toArrayBufferView(Uint8Array, buffer_1.toArrayBufferView(type.ArrayType, this.sources[offset]));
      }
      readData(type, { offset } = this.nextBufferRange()) {
        const { sources } = this;
        if (type_1.DataType.isTimestamp(type)) {
          return buffer_1.toArrayBufferView(Uint8Array, int_1.Int64.convertArray(sources[offset]));
        } else if ((type_1.DataType.isInt(type) || type_1.DataType.isTime(type)) && type.bitWidth === 64) {
          return buffer_1.toArrayBufferView(Uint8Array, int_1.Int64.convertArray(sources[offset]));
        } else if (type_1.DataType.isDate(type) && type.unit === enum_1.DateUnit.MILLISECOND) {
          return buffer_1.toArrayBufferView(Uint8Array, int_1.Int64.convertArray(sources[offset]));
        } else if (type_1.DataType.isDecimal(type)) {
          return buffer_1.toArrayBufferView(Uint8Array, int_1.Int128.convertArray(sources[offset]));
        } else if (type_1.DataType.isBinary(type) || type_1.DataType.isFixedSizeBinary(type)) {
          return binaryDataFromJSON(sources[offset]);
        } else if (type_1.DataType.isBool(type)) {
          return bit_1.packBools(sources[offset]);
        } else if (type_1.DataType.isUtf8(type)) {
          return utf8_1.encodeUtf8(sources[offset].join(""));
        }
        return buffer_1.toArrayBufferView(Uint8Array, buffer_1.toArrayBufferView(type.ArrayType, sources[offset].map((x) => +x)));
      }
    };
    exports.JSONVectorLoader = JSONVectorLoader;
    function binaryDataFromJSON(values) {
      const joined = values.join("");
      const data = new Uint8Array(joined.length / 2);
      for (let i = 0; i < joined.length; i += 2) {
        data[i >> 1] = parseInt(joined.substr(i, 2), 16);
      }
      return data;
    }
  }
});

// node_modules/apache-arrow/visitor/typeassembler.js
var require_typeassembler = __commonJS({
  "node_modules/apache-arrow/visitor/typeassembler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var flatbuffers_1 = (init_flatbuffers(), __toCommonJS(flatbuffers_exports));
    var Long = flatbuffers_1.flatbuffers.Long;
    var Schema_ = require_Schema();
    var visitor_1 = require_visitor();
    var Null2 = Schema_.org.apache.arrow.flatbuf.Null;
    var Int2 = Schema_.org.apache.arrow.flatbuf.Int;
    var FloatingPoint = Schema_.org.apache.arrow.flatbuf.FloatingPoint;
    var Binary2 = Schema_.org.apache.arrow.flatbuf.Binary;
    var Bool2 = Schema_.org.apache.arrow.flatbuf.Bool;
    var Utf82 = Schema_.org.apache.arrow.flatbuf.Utf8;
    var Decimal2 = Schema_.org.apache.arrow.flatbuf.Decimal;
    var Date2 = Schema_.org.apache.arrow.flatbuf.Date;
    var Time2 = Schema_.org.apache.arrow.flatbuf.Time;
    var Timestamp2 = Schema_.org.apache.arrow.flatbuf.Timestamp;
    var Interval2 = Schema_.org.apache.arrow.flatbuf.Interval;
    var List2 = Schema_.org.apache.arrow.flatbuf.List;
    var Struct2 = Schema_.org.apache.arrow.flatbuf.Struct_;
    var Union2 = Schema_.org.apache.arrow.flatbuf.Union;
    var DictionaryEncoding = Schema_.org.apache.arrow.flatbuf.DictionaryEncoding;
    var FixedSizeBinary2 = Schema_.org.apache.arrow.flatbuf.FixedSizeBinary;
    var FixedSizeList2 = Schema_.org.apache.arrow.flatbuf.FixedSizeList;
    var Map_2 = Schema_.org.apache.arrow.flatbuf.Map;
    var TypeAssembler = class extends visitor_1.Visitor {
      visit(node, builder) {
        return node == null || builder == null ? void 0 : super.visit(node, builder);
      }
      visitNull(_node, b) {
        Null2.startNull(b);
        return Null2.endNull(b);
      }
      visitInt(node, b) {
        Int2.startInt(b);
        Int2.addBitWidth(b, node.bitWidth);
        Int2.addIsSigned(b, node.isSigned);
        return Int2.endInt(b);
      }
      visitFloat(node, b) {
        FloatingPoint.startFloatingPoint(b);
        FloatingPoint.addPrecision(b, node.precision);
        return FloatingPoint.endFloatingPoint(b);
      }
      visitBinary(_node, b) {
        Binary2.startBinary(b);
        return Binary2.endBinary(b);
      }
      visitBool(_node, b) {
        Bool2.startBool(b);
        return Bool2.endBool(b);
      }
      visitUtf8(_node, b) {
        Utf82.startUtf8(b);
        return Utf82.endUtf8(b);
      }
      visitDecimal(node, b) {
        Decimal2.startDecimal(b);
        Decimal2.addScale(b, node.scale);
        Decimal2.addPrecision(b, node.precision);
        return Decimal2.endDecimal(b);
      }
      visitDate(node, b) {
        Date2.startDate(b);
        Date2.addUnit(b, node.unit);
        return Date2.endDate(b);
      }
      visitTime(node, b) {
        Time2.startTime(b);
        Time2.addUnit(b, node.unit);
        Time2.addBitWidth(b, node.bitWidth);
        return Time2.endTime(b);
      }
      visitTimestamp(node, b) {
        const timezone = node.timezone && b.createString(node.timezone) || void 0;
        Timestamp2.startTimestamp(b);
        Timestamp2.addUnit(b, node.unit);
        if (timezone !== void 0) {
          Timestamp2.addTimezone(b, timezone);
        }
        return Timestamp2.endTimestamp(b);
      }
      visitInterval(node, b) {
        Interval2.startInterval(b);
        Interval2.addUnit(b, node.unit);
        return Interval2.endInterval(b);
      }
      visitList(_node, b) {
        List2.startList(b);
        return List2.endList(b);
      }
      visitStruct(_node, b) {
        Struct2.startStruct_(b);
        return Struct2.endStruct_(b);
      }
      visitUnion(node, b) {
        Union2.startTypeIdsVector(b, node.typeIds.length);
        const typeIds = Union2.createTypeIdsVector(b, node.typeIds);
        Union2.startUnion(b);
        Union2.addMode(b, node.mode);
        Union2.addTypeIds(b, typeIds);
        return Union2.endUnion(b);
      }
      visitDictionary(node, b) {
        const indexType = this.visit(node.indices, b);
        DictionaryEncoding.startDictionaryEncoding(b);
        DictionaryEncoding.addId(b, new Long(node.id, 0));
        DictionaryEncoding.addIsOrdered(b, node.isOrdered);
        if (indexType !== void 0) {
          DictionaryEncoding.addIndexType(b, indexType);
        }
        return DictionaryEncoding.endDictionaryEncoding(b);
      }
      visitFixedSizeBinary(node, b) {
        FixedSizeBinary2.startFixedSizeBinary(b);
        FixedSizeBinary2.addByteWidth(b, node.byteWidth);
        return FixedSizeBinary2.endFixedSizeBinary(b);
      }
      visitFixedSizeList(node, b) {
        FixedSizeList2.startFixedSizeList(b);
        FixedSizeList2.addListSize(b, node.listSize);
        return FixedSizeList2.endFixedSizeList(b);
      }
      visitMap(node, b) {
        Map_2.startMap(b);
        Map_2.addKeysSorted(b, node.keysSorted);
        return Map_2.endMap(b);
      }
    };
    exports.TypeAssembler = TypeAssembler;
    exports.instance = new TypeAssembler();
  }
});

// node_modules/apache-arrow/ipc/metadata/json.js
var require_json = __commonJS({
  "node_modules/apache-arrow/ipc/metadata/json.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var type_1 = require_type();
    var message_1 = require_message();
    var enum_1 = require_enum();
    function schemaFromJSON(_schema, dictionaries = /* @__PURE__ */ new Map()) {
      return new schema_1.Schema(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema["customMetadata"]), dictionaries);
    }
    exports.schemaFromJSON = schemaFromJSON;
    function recordBatchFromJSON(b) {
      return new message_1.RecordBatch(b["count"], fieldNodesFromJSON(b["columns"]), buffersFromJSON(b["columns"]));
    }
    exports.recordBatchFromJSON = recordBatchFromJSON;
    function dictionaryBatchFromJSON(b) {
      return new message_1.DictionaryBatch(recordBatchFromJSON(b["data"]), b["id"], b["isDelta"]);
    }
    exports.dictionaryBatchFromJSON = dictionaryBatchFromJSON;
    function schemaFieldsFromJSON(_schema, dictionaries) {
      return (_schema["fields"] || []).filter(Boolean).map((f) => schema_1.Field.fromJSON(f, dictionaries));
    }
    function fieldChildrenFromJSON(_field, dictionaries) {
      return (_field["children"] || []).filter(Boolean).map((f) => schema_1.Field.fromJSON(f, dictionaries));
    }
    function fieldNodesFromJSON(xs) {
      return (xs || []).reduce((fieldNodes, column) => [
        ...fieldNodes,
        new message_1.FieldNode(column["count"], nullCountFromJSON(column["VALIDITY"])),
        ...fieldNodesFromJSON(column["children"])
      ], []);
    }
    function buffersFromJSON(xs, buffers = []) {
      for (let i = -1, n = (xs || []).length; ++i < n; ) {
        const column = xs[i];
        column["VALIDITY"] && buffers.push(new message_1.BufferRegion(buffers.length, column["VALIDITY"].length));
        column["TYPE"] && buffers.push(new message_1.BufferRegion(buffers.length, column["TYPE"].length));
        column["OFFSET"] && buffers.push(new message_1.BufferRegion(buffers.length, column["OFFSET"].length));
        column["DATA"] && buffers.push(new message_1.BufferRegion(buffers.length, column["DATA"].length));
        buffers = buffersFromJSON(column["children"], buffers);
      }
      return buffers;
    }
    function nullCountFromJSON(validity) {
      return (validity || []).reduce((sum, val) => sum + +(val === 0), 0);
    }
    function fieldFromJSON(_field, dictionaries) {
      let id;
      let keys;
      let field;
      let dictMeta;
      let type;
      let dictType;
      if (!dictionaries || !(dictMeta = _field["dictionary"])) {
        type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
        field = new schema_1.Field(_field["name"], type, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
      } else if (!dictionaries.has(id = dictMeta["id"])) {
        keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new type_1.Int32();
        dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
        dictType = new type_1.Dictionary(type, keys, id, dictMeta["isOrdered"]);
        field = new schema_1.Field(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
      } else {
        keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new type_1.Int32();
        dictType = new type_1.Dictionary(dictionaries.get(id), keys, id, dictMeta["isOrdered"]);
        field = new schema_1.Field(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
      }
      return field || null;
    }
    exports.fieldFromJSON = fieldFromJSON;
    function customMetadataFromJSON(_metadata) {
      return new Map(Object.entries(_metadata || {}));
    }
    function indexTypeFromJSON(_type) {
      return new type_1.Int(_type["isSigned"], _type["bitWidth"]);
    }
    function typeFromJSON(f, children) {
      const typeId = f["type"]["name"];
      switch (typeId) {
        case "NONE":
          return new type_1.Null();
        case "null":
          return new type_1.Null();
        case "binary":
          return new type_1.Binary();
        case "utf8":
          return new type_1.Utf8();
        case "bool":
          return new type_1.Bool();
        case "list":
          return new type_1.List((children || [])[0]);
        case "struct":
          return new type_1.Struct(children || []);
        case "struct_":
          return new type_1.Struct(children || []);
      }
      switch (typeId) {
        case "int": {
          const t = f["type"];
          return new type_1.Int(t["isSigned"], t["bitWidth"]);
        }
        case "floatingpoint": {
          const t = f["type"];
          return new type_1.Float(enum_1.Precision[t["precision"]]);
        }
        case "decimal": {
          const t = f["type"];
          return new type_1.Decimal(t["scale"], t["precision"]);
        }
        case "date": {
          const t = f["type"];
          return new type_1.Date_(enum_1.DateUnit[t["unit"]]);
        }
        case "time": {
          const t = f["type"];
          return new type_1.Time(enum_1.TimeUnit[t["unit"]], t["bitWidth"]);
        }
        case "timestamp": {
          const t = f["type"];
          return new type_1.Timestamp(enum_1.TimeUnit[t["unit"]], t["timezone"]);
        }
        case "interval": {
          const t = f["type"];
          return new type_1.Interval(enum_1.IntervalUnit[t["unit"]]);
        }
        case "union": {
          const t = f["type"];
          return new type_1.Union(enum_1.UnionMode[t["mode"]], t["typeIds"] || [], children || []);
        }
        case "fixedsizebinary": {
          const t = f["type"];
          return new type_1.FixedSizeBinary(t["byteWidth"]);
        }
        case "fixedsizelist": {
          const t = f["type"];
          return new type_1.FixedSizeList(t["listSize"], (children || [])[0]);
        }
        case "map": {
          const t = f["type"];
          return new type_1.Map_((children || [])[0], t["keysSorted"]);
        }
      }
      throw new Error(`Unrecognized type: "${typeId}"`);
    }
  }
});

// node_modules/apache-arrow/ipc/metadata/message.js
var require_message = __commonJS({
  "node_modules/apache-arrow/ipc/metadata/message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var flatbuffers_1 = (init_flatbuffers(), __toCommonJS(flatbuffers_exports));
    var Schema_ = require_Schema();
    var Message_ = require_Message();
    var schema_1 = require_schema();
    var buffer_1 = require_buffer();
    var enum_1 = require_enum();
    var typeassembler_1 = require_typeassembler();
    var json_1 = require_json();
    var Long = flatbuffers_1.flatbuffers.Long;
    var Builder3 = flatbuffers_1.flatbuffers.Builder;
    var ByteBuffer = flatbuffers_1.flatbuffers.ByteBuffer;
    var Type2 = Schema_.org.apache.arrow.flatbuf.Type;
    var _Field = Schema_.org.apache.arrow.flatbuf.Field;
    var _Schema = Schema_.org.apache.arrow.flatbuf.Schema;
    var _Buffer = Schema_.org.apache.arrow.flatbuf.Buffer;
    var _Message = Message_.org.apache.arrow.flatbuf.Message;
    var _KeyValue = Schema_.org.apache.arrow.flatbuf.KeyValue;
    var _FieldNode = Message_.org.apache.arrow.flatbuf.FieldNode;
    var _Endianness = Schema_.org.apache.arrow.flatbuf.Endianness;
    var _RecordBatch = Message_.org.apache.arrow.flatbuf.RecordBatch;
    var _DictionaryBatch = Message_.org.apache.arrow.flatbuf.DictionaryBatch;
    var type_1 = require_type();
    var Message2 = class _Message2 {
      constructor(bodyLength, version, headerType, header) {
        this._version = version;
        this._headerType = headerType;
        this.body = new Uint8Array(0);
        header && (this._createHeader = () => header);
        this._bodyLength = typeof bodyLength === "number" ? bodyLength : bodyLength.low;
      }
      /** @nocollapse */
      static fromJSON(msg, headerType) {
        const message = new _Message2(0, enum_1.MetadataVersion.V4, headerType);
        message._createHeader = messageHeaderFromJSON(msg, headerType);
        return message;
      }
      /** @nocollapse */
      static decode(buf) {
        buf = new ByteBuffer(buffer_1.toUint8Array(buf));
        const _message = _Message.getRootAsMessage(buf);
        const bodyLength = _message.bodyLength();
        const version = _message.version();
        const headerType = _message.headerType();
        const message = new _Message2(bodyLength, version, headerType);
        message._createHeader = decodeMessageHeader(_message, headerType);
        return message;
      }
      /** @nocollapse */
      static encode(message) {
        let b = new Builder3(), headerOffset = -1;
        if (message.isSchema()) {
          headerOffset = schema_1.Schema.encode(b, message.header());
        } else if (message.isRecordBatch()) {
          headerOffset = RecordBatch2.encode(b, message.header());
        } else if (message.isDictionaryBatch()) {
          headerOffset = DictionaryBatch.encode(b, message.header());
        }
        _Message.startMessage(b);
        _Message.addVersion(b, enum_1.MetadataVersion.V4);
        _Message.addHeader(b, headerOffset);
        _Message.addHeaderType(b, message.headerType);
        _Message.addBodyLength(b, new Long(message.bodyLength, 0));
        _Message.finishMessageBuffer(b, _Message.endMessage(b));
        return b.asUint8Array();
      }
      /** @nocollapse */
      static from(header, bodyLength = 0) {
        if (header instanceof schema_1.Schema) {
          return new _Message2(0, enum_1.MetadataVersion.V4, enum_1.MessageHeader.Schema, header);
        }
        if (header instanceof RecordBatch2) {
          return new _Message2(bodyLength, enum_1.MetadataVersion.V4, enum_1.MessageHeader.RecordBatch, header);
        }
        if (header instanceof DictionaryBatch) {
          return new _Message2(bodyLength, enum_1.MetadataVersion.V4, enum_1.MessageHeader.DictionaryBatch, header);
        }
        throw new Error(`Unrecognized Message header: ${header}`);
      }
      get type() {
        return this.headerType;
      }
      get version() {
        return this._version;
      }
      get headerType() {
        return this._headerType;
      }
      get bodyLength() {
        return this._bodyLength;
      }
      header() {
        return this._createHeader();
      }
      isSchema() {
        return this.headerType === enum_1.MessageHeader.Schema;
      }
      isRecordBatch() {
        return this.headerType === enum_1.MessageHeader.RecordBatch;
      }
      isDictionaryBatch() {
        return this.headerType === enum_1.MessageHeader.DictionaryBatch;
      }
    };
    exports.Message = Message2;
    var RecordBatch2 = class {
      get nodes() {
        return this._nodes;
      }
      get length() {
        return this._length;
      }
      get buffers() {
        return this._buffers;
      }
      constructor(length, nodes, buffers) {
        this._nodes = nodes;
        this._buffers = buffers;
        this._length = typeof length === "number" ? length : length.low;
      }
    };
    exports.RecordBatch = RecordBatch2;
    var DictionaryBatch = class {
      get id() {
        return this._id;
      }
      get data() {
        return this._data;
      }
      get isDelta() {
        return this._isDelta;
      }
      get length() {
        return this.data.length;
      }
      get nodes() {
        return this.data.nodes;
      }
      get buffers() {
        return this.data.buffers;
      }
      constructor(data, id, isDelta = false) {
        this._data = data;
        this._isDelta = isDelta;
        this._id = typeof id === "number" ? id : id.low;
      }
    };
    exports.DictionaryBatch = DictionaryBatch;
    var BufferRegion = class {
      constructor(offset, length) {
        this.offset = typeof offset === "number" ? offset : offset.low;
        this.length = typeof length === "number" ? length : length.low;
      }
    };
    exports.BufferRegion = BufferRegion;
    var FieldNode = class {
      constructor(length, nullCount) {
        this.length = typeof length === "number" ? length : length.low;
        this.nullCount = typeof nullCount === "number" ? nullCount : nullCount.low;
      }
    };
    exports.FieldNode = FieldNode;
    function messageHeaderFromJSON(message, type) {
      return () => {
        switch (type) {
          case enum_1.MessageHeader.Schema:
            return schema_1.Schema.fromJSON(message);
          case enum_1.MessageHeader.RecordBatch:
            return RecordBatch2.fromJSON(message);
          case enum_1.MessageHeader.DictionaryBatch:
            return DictionaryBatch.fromJSON(message);
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_1.MessageHeader[type]}, type: ${type} }`);
      };
    }
    function decodeMessageHeader(message, type) {
      return () => {
        switch (type) {
          case enum_1.MessageHeader.Schema:
            return schema_1.Schema.decode(message.header(new _Schema()));
          case enum_1.MessageHeader.RecordBatch:
            return RecordBatch2.decode(message.header(new _RecordBatch()), message.version());
          case enum_1.MessageHeader.DictionaryBatch:
            return DictionaryBatch.decode(message.header(new _DictionaryBatch()), message.version());
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_1.MessageHeader[type]}, type: ${type} }`);
      };
    }
    schema_1.Field["encode"] = encodeField;
    schema_1.Field["decode"] = decodeField;
    schema_1.Field["fromJSON"] = json_1.fieldFromJSON;
    schema_1.Schema["encode"] = encodeSchema;
    schema_1.Schema["decode"] = decodeSchema;
    schema_1.Schema["fromJSON"] = json_1.schemaFromJSON;
    RecordBatch2["encode"] = encodeRecordBatch;
    RecordBatch2["decode"] = decodeRecordBatch;
    RecordBatch2["fromJSON"] = json_1.recordBatchFromJSON;
    DictionaryBatch["encode"] = encodeDictionaryBatch;
    DictionaryBatch["decode"] = decodeDictionaryBatch;
    DictionaryBatch["fromJSON"] = json_1.dictionaryBatchFromJSON;
    FieldNode["encode"] = encodeFieldNode;
    FieldNode["decode"] = decodeFieldNode;
    BufferRegion["encode"] = encodeBufferRegion;
    BufferRegion["decode"] = decodeBufferRegion;
    function decodeSchema(_schema, dictionaries = /* @__PURE__ */ new Map()) {
      const fields = decodeSchemaFields(_schema, dictionaries);
      return new schema_1.Schema(fields, decodeCustomMetadata(_schema), dictionaries);
    }
    function decodeRecordBatch(batch, version = enum_1.MetadataVersion.V4) {
      return new RecordBatch2(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));
    }
    function decodeDictionaryBatch(batch, version = enum_1.MetadataVersion.V4) {
      return new DictionaryBatch(RecordBatch2.decode(batch.data(), version), batch.id(), batch.isDelta());
    }
    function decodeBufferRegion(b) {
      return new BufferRegion(b.offset(), b.length());
    }
    function decodeFieldNode(f) {
      return new FieldNode(f.length(), f.nullCount());
    }
    function decodeFieldNodes(batch) {
      const nodes = [];
      for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n; ) {
        if (f = batch.nodes(i)) {
          nodes[++j] = FieldNode.decode(f);
        }
      }
      return nodes;
    }
    function decodeBuffers(batch, version) {
      const bufferRegions = [];
      for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n; ) {
        if (b = batch.buffers(i)) {
          if (version < enum_1.MetadataVersion.V4) {
            b.bb_pos += 8 * (i + 1);
          }
          bufferRegions[++j] = BufferRegion.decode(b);
        }
      }
      return bufferRegions;
    }
    function decodeSchemaFields(schema, dictionaries) {
      const fields = [];
      for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n; ) {
        if (f = schema.fields(i)) {
          fields[++j] = schema_1.Field.decode(f, dictionaries);
        }
      }
      return fields;
    }
    function decodeFieldChildren(field, dictionaries) {
      const children = [];
      for (let f, i = -1, j = -1, n = field.childrenLength(); ++i < n; ) {
        if (f = field.children(i)) {
          children[++j] = schema_1.Field.decode(f, dictionaries);
        }
      }
      return children;
    }
    function decodeField(f, dictionaries) {
      let id;
      let field;
      let type;
      let keys;
      let dictType;
      let dictMeta;
      if (!dictionaries || !(dictMeta = f.dictionary())) {
        type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
        field = new schema_1.Field(f.name(), type, f.nullable(), decodeCustomMetadata(f));
      } else if (!dictionaries.has(id = dictMeta.id().low)) {
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_1.Int32();
        dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
        dictType = new type_1.Dictionary(type, keys, id, dictMeta.isOrdered());
        field = new schema_1.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
      } else {
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_1.Int32();
        dictType = new type_1.Dictionary(dictionaries.get(id), keys, id, dictMeta.isOrdered());
        field = new schema_1.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
      }
      return field || null;
    }
    function decodeCustomMetadata(parent) {
      const data = /* @__PURE__ */ new Map();
      if (parent) {
        for (let entry, key, i = -1, n = parent.customMetadataLength() | 0; ++i < n; ) {
          if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
            data.set(key, entry.value());
          }
        }
      }
      return data;
    }
    function decodeIndexType(_type) {
      return new type_1.Int(_type.isSigned(), _type.bitWidth());
    }
    function decodeFieldType(f, children) {
      const typeId = f.typeType();
      switch (typeId) {
        case Type2.NONE:
          return new type_1.Null();
        case Type2.Null:
          return new type_1.Null();
        case Type2.Binary:
          return new type_1.Binary();
        case Type2.Utf8:
          return new type_1.Utf8();
        case Type2.Bool:
          return new type_1.Bool();
        case Type2.List:
          return new type_1.List((children || [])[0]);
        case Type2.Struct_:
          return new type_1.Struct(children || []);
      }
      switch (typeId) {
        case Type2.Int: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Int());
          return new type_1.Int(t.isSigned(), t.bitWidth());
        }
        case Type2.FloatingPoint: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.FloatingPoint());
          return new type_1.Float(t.precision());
        }
        case Type2.Decimal: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Decimal());
          return new type_1.Decimal(t.scale(), t.precision());
        }
        case Type2.Date: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Date());
          return new type_1.Date_(t.unit());
        }
        case Type2.Time: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Time());
          return new type_1.Time(t.unit(), t.bitWidth());
        }
        case Type2.Timestamp: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Timestamp());
          return new type_1.Timestamp(t.unit(), t.timezone());
        }
        case Type2.Interval: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Interval());
          return new type_1.Interval(t.unit());
        }
        case Type2.Union: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Union());
          return new type_1.Union(t.mode(), t.typeIdsArray() || [], children || []);
        }
        case Type2.FixedSizeBinary: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.FixedSizeBinary());
          return new type_1.FixedSizeBinary(t.byteWidth());
        }
        case Type2.FixedSizeList: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.FixedSizeList());
          return new type_1.FixedSizeList(t.listSize(), (children || [])[0]);
        }
        case Type2.Map: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Map());
          return new type_1.Map_((children || [])[0], t.keysSorted());
        }
      }
      throw new Error(`Unrecognized type: "${Type2[typeId]}" (${typeId})`);
    }
    function encodeSchema(b, schema) {
      const fieldOffsets = schema.fields.map((f) => schema_1.Field.encode(b, f));
      _Schema.startFieldsVector(b, fieldOffsets.length);
      const fieldsVectorOffset = _Schema.createFieldsVector(b, fieldOffsets);
      const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : _Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {
        const key = b.createString(`${k}`);
        const val = b.createString(`${v}`);
        _KeyValue.startKeyValue(b);
        _KeyValue.addKey(b, key);
        _KeyValue.addValue(b, val);
        return _KeyValue.endKeyValue(b);
      }));
      _Schema.startSchema(b);
      _Schema.addFields(b, fieldsVectorOffset);
      _Schema.addEndianness(b, platformIsLittleEndian ? _Endianness.Little : _Endianness.Big);
      if (metadataOffset !== -1) {
        _Schema.addCustomMetadata(b, metadataOffset);
      }
      return _Schema.endSchema(b);
    }
    function encodeField(b, field) {
      let nameOffset = -1;
      let typeOffset = -1;
      let dictionaryOffset = -1;
      let type = field.type;
      let typeId = field.typeId;
      if (!type_1.DataType.isDictionary(type)) {
        typeOffset = typeassembler_1.instance.visit(type, b);
      } else {
        typeId = type.dictionary.typeId;
        dictionaryOffset = typeassembler_1.instance.visit(type, b);
        typeOffset = typeassembler_1.instance.visit(type.dictionary, b);
      }
      const childOffsets = (type.children || []).map((f) => schema_1.Field.encode(b, f));
      const childrenVectorOffset = _Field.createChildrenVector(b, childOffsets);
      const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 : _Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {
        const key = b.createString(`${k}`);
        const val = b.createString(`${v}`);
        _KeyValue.startKeyValue(b);
        _KeyValue.addKey(b, key);
        _KeyValue.addValue(b, val);
        return _KeyValue.endKeyValue(b);
      }));
      if (field.name) {
        nameOffset = b.createString(field.name);
      }
      _Field.startField(b);
      _Field.addType(b, typeOffset);
      _Field.addTypeType(b, typeId);
      _Field.addChildren(b, childrenVectorOffset);
      _Field.addNullable(b, !!field.nullable);
      if (nameOffset !== -1) {
        _Field.addName(b, nameOffset);
      }
      if (dictionaryOffset !== -1) {
        _Field.addDictionary(b, dictionaryOffset);
      }
      if (metadataOffset !== -1) {
        _Field.addCustomMetadata(b, metadataOffset);
      }
      return _Field.endField(b);
    }
    function encodeRecordBatch(b, recordBatch) {
      const nodes = recordBatch.nodes || [];
      const buffers = recordBatch.buffers || [];
      _RecordBatch.startNodesVector(b, nodes.length);
      nodes.slice().reverse().forEach((n) => FieldNode.encode(b, n));
      const nodesVectorOffset = b.endVector();
      _RecordBatch.startBuffersVector(b, buffers.length);
      buffers.slice().reverse().forEach((b_) => BufferRegion.encode(b, b_));
      const buffersVectorOffset = b.endVector();
      _RecordBatch.startRecordBatch(b);
      _RecordBatch.addLength(b, new Long(recordBatch.length, 0));
      _RecordBatch.addNodes(b, nodesVectorOffset);
      _RecordBatch.addBuffers(b, buffersVectorOffset);
      return _RecordBatch.endRecordBatch(b);
    }
    function encodeDictionaryBatch(b, dictionaryBatch) {
      const dataOffset = RecordBatch2.encode(b, dictionaryBatch.data);
      _DictionaryBatch.startDictionaryBatch(b);
      _DictionaryBatch.addId(b, new Long(dictionaryBatch.id, 0));
      _DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
      _DictionaryBatch.addData(b, dataOffset);
      return _DictionaryBatch.endDictionaryBatch(b);
    }
    function encodeFieldNode(b, node) {
      return _FieldNode.createFieldNode(b, new Long(node.length, 0), new Long(node.nullCount, 0));
    }
    function encodeBufferRegion(b, node) {
      return _Buffer.createBuffer(b, new Long(node.offset, 0), new Long(node.length, 0));
    }
    var platformIsLittleEndian = function() {
      const buffer = new ArrayBuffer(2);
      new DataView(buffer).setInt16(
        0,
        256,
        true
        /* littleEndian */
      );
      return new Int16Array(buffer)[0] === 256;
    }();
  }
});

// node_modules/apache-arrow/ipc/message.js
var require_message2 = __commonJS({
  "node_modules/apache-arrow/ipc/message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var enum_1 = require_enum();
    var flatbuffers_1 = (init_flatbuffers(), __toCommonJS(flatbuffers_exports));
    var ByteBuffer = flatbuffers_1.flatbuffers.ByteBuffer;
    var message_1 = require_message();
    var compat_1 = require_compat();
    var file_1 = require_file2();
    var buffer_1 = require_buffer();
    var stream_1 = require_stream();
    var interfaces_1 = require_interfaces();
    var invalidMessageType = (type) => `Expected ${enum_1.MessageHeader[type]} Message in stream, but was null or length 0.`;
    var nullMessage = (type) => `Header pointer of flatbuffer-encoded ${enum_1.MessageHeader[type]} Message is null or length 0.`;
    var invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
    var invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
    var MessageReader2 = class {
      constructor(source) {
        this.source = source instanceof stream_1.ByteStream ? source : new stream_1.ByteStream(source);
      }
      [Symbol.iterator]() {
        return this;
      }
      next() {
        let r;
        if ((r = this.readMetadataLength()).done) {
          return interfaces_1.ITERATOR_DONE;
        }
        if (r.value === -1 && (r = this.readMetadataLength()).done) {
          return interfaces_1.ITERATOR_DONE;
        }
        if ((r = this.readMetadata(r.value)).done) {
          return interfaces_1.ITERATOR_DONE;
        }
        return r;
      }
      throw(value) {
        return this.source.throw(value);
      }
      return(value) {
        return this.source.return(value);
      }
      readMessage(type) {
        let r;
        if ((r = this.next()).done) {
          return null;
        }
        if (type != null && r.value.headerType !== type) {
          throw new Error(invalidMessageType(type));
        }
        return r.value;
      }
      readMessageBody(bodyLength) {
        if (bodyLength <= 0) {
          return new Uint8Array(0);
        }
        const buf = buffer_1.toUint8Array(this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
          throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        return (
          /* 1. */
          buf.byteOffset % 8 === 0 && /* 2. */
          buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
        );
      }
      readSchema(throwIfNull = false) {
        const type = enum_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message && message.header();
        if (throwIfNull && !schema) {
          throw new Error(nullMessage(type));
        }
        return schema;
      }
      readMetadataLength() {
        const buf = this.source.read(exports.PADDING);
        const bb = buf && new ByteBuffer(buf);
        const len = bb && bb.readInt32(0) || 0;
        return { done: len === 0, value: len };
      }
      readMetadata(metadataLength) {
        const buf = this.source.read(metadataLength);
        if (!buf) {
          return interfaces_1.ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
          throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: message_1.Message.decode(buf) };
      }
    };
    exports.MessageReader = MessageReader2;
    var AsyncMessageReader2 = class {
      constructor(source, byteLength) {
        this.source = source instanceof stream_1.AsyncByteStream ? source : compat_1.isFileHandle(source) ? new file_1.AsyncRandomAccessFile(source, byteLength) : new stream_1.AsyncByteStream(source);
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      async next() {
        let r;
        if ((r = await this.readMetadataLength()).done) {
          return interfaces_1.ITERATOR_DONE;
        }
        if (r.value === -1 && (r = await this.readMetadataLength()).done) {
          return interfaces_1.ITERATOR_DONE;
        }
        if ((r = await this.readMetadata(r.value)).done) {
          return interfaces_1.ITERATOR_DONE;
        }
        return r;
      }
      async throw(value) {
        return await this.source.throw(value);
      }
      async return(value) {
        return await this.source.return(value);
      }
      async readMessage(type) {
        let r;
        if ((r = await this.next()).done) {
          return null;
        }
        if (type != null && r.value.headerType !== type) {
          throw new Error(invalidMessageType(type));
        }
        return r.value;
      }
      async readMessageBody(bodyLength) {
        if (bodyLength <= 0) {
          return new Uint8Array(0);
        }
        const buf = buffer_1.toUint8Array(await this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
          throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        return (
          /* 1. */
          buf.byteOffset % 8 === 0 && /* 2. */
          buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
        );
      }
      async readSchema(throwIfNull = false) {
        const type = enum_1.MessageHeader.Schema;
        const message = await this.readMessage(type);
        const schema = message && message.header();
        if (throwIfNull && !schema) {
          throw new Error(nullMessage(type));
        }
        return schema;
      }
      async readMetadataLength() {
        const buf = await this.source.read(exports.PADDING);
        const bb = buf && new ByteBuffer(buf);
        const len = bb && bb.readInt32(0) || 0;
        return { done: len === 0, value: len };
      }
      async readMetadata(metadataLength) {
        const buf = await this.source.read(metadataLength);
        if (!buf) {
          return interfaces_1.ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
          throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: message_1.Message.decode(buf) };
      }
    };
    exports.AsyncMessageReader = AsyncMessageReader2;
    var JSONMessageReader2 = class extends MessageReader2 {
      constructor(source) {
        super(new Uint8Array(0));
        this._schema = false;
        this._body = [];
        this._batchIndex = 0;
        this._dictionaryIndex = 0;
        this._json = source instanceof interfaces_1.ArrowJSON ? source : new interfaces_1.ArrowJSON(source);
      }
      next() {
        const { _json } = this;
        if (!this._schema) {
          this._schema = true;
          const message = message_1.Message.fromJSON(_json.schema, enum_1.MessageHeader.Schema);
          return { done: false, value: message };
        }
        if (this._dictionaryIndex < _json.dictionaries.length) {
          const batch = _json.dictionaries[this._dictionaryIndex++];
          this._body = batch["data"]["columns"];
          const message = message_1.Message.fromJSON(batch, enum_1.MessageHeader.DictionaryBatch);
          return { done: false, value: message };
        }
        if (this._batchIndex < _json.batches.length) {
          const batch = _json.batches[this._batchIndex++];
          this._body = batch["columns"];
          const message = message_1.Message.fromJSON(batch, enum_1.MessageHeader.RecordBatch);
          return { done: false, value: message };
        }
        this._body = [];
        return interfaces_1.ITERATOR_DONE;
      }
      readMessageBody(_bodyLength) {
        return flattenDataSources(this._body);
        function flattenDataSources(xs) {
          return (xs || []).reduce((buffers, column) => [
            ...buffers,
            ...column["VALIDITY"] && [column["VALIDITY"]] || [],
            ...column["TYPE"] && [column["TYPE"]] || [],
            ...column["OFFSET"] && [column["OFFSET"]] || [],
            ...column["DATA"] && [column["DATA"]] || [],
            ...flattenDataSources(column["children"])
          ], []);
        }
      }
      readMessage(type) {
        let r;
        if ((r = this.next()).done) {
          return null;
        }
        if (type != null && r.value.headerType !== type) {
          throw new Error(invalidMessageType(type));
        }
        return r.value;
      }
      readSchema() {
        const type = enum_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message && message.header();
        if (!message || !schema) {
          throw new Error(nullMessage(type));
        }
        return schema;
      }
    };
    exports.JSONMessageReader = JSONMessageReader2;
    exports.PADDING = 4;
    exports.MAGIC_STR = "ARROW1";
    exports.MAGIC = new Uint8Array(exports.MAGIC_STR.length);
    for (let i = 0; i < exports.MAGIC_STR.length; i += 1 | 0) {
      exports.MAGIC[i] = exports.MAGIC_STR.charCodeAt(i);
    }
    function checkForMagicArrowString(buffer, index = 0) {
      for (let i = -1, n = exports.MAGIC.length; ++i < n; ) {
        if (exports.MAGIC[i] !== buffer[index + i]) {
          return false;
        }
      }
      return true;
    }
    exports.checkForMagicArrowString = checkForMagicArrowString;
    exports.magicLength = exports.MAGIC.length;
    exports.magicAndPadding = exports.magicLength + exports.PADDING;
    exports.magicX2AndPadding = exports.magicLength * 2 + exports.PADDING;
  }
});

// node_modules/apache-arrow/visitor/vectorassembler.js
var require_vectorassembler = __commonJS({
  "node_modules/apache-arrow/visitor/vectorassembler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var enum_1 = require_enum();
    var recordbatch_1 = require_recordbatch2();
    var buffer_1 = require_buffer();
    var bit_1 = require_bit();
    var args_1 = require_args();
    var message_1 = require_message();
    var type_1 = require_type();
    var VectorAssembler = class _VectorAssembler extends visitor_1.Visitor {
      constructor() {
        super();
        this._byteLength = 0;
        this._nodes = [];
        this._buffers = [];
        this._bufferRegions = [];
      }
      /** @nocollapse */
      static assemble(...args) {
        const assembler = new _VectorAssembler();
        const vectorChildren = args_1.selectVectorChildrenArgs(recordbatch_1.RecordBatch, args);
        const [assembleResult = assembler] = assembler.visitMany(vectorChildren);
        return assembleResult;
      }
      visit(vector) {
        if (!type_1.DataType.isDictionary(vector.type)) {
          const { data, length, nullCount } = vector;
          if (length > 2147483647) {
            throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
          }
          if (!type_1.DataType.isNull(vector.type)) {
            addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : bit_1.truncateBitmap(data.offset, length, data.nullBitmap));
          }
          this.nodes.push(new message_1.FieldNode(length, nullCount));
        }
        return super.visit(vector);
      }
      visitNull(_nullV) {
        return this;
      }
      visitDictionary(vector) {
        return this.visit(vector.indices);
      }
      get nodes() {
        return this._nodes;
      }
      get buffers() {
        return this._buffers;
      }
      get byteLength() {
        return this._byteLength;
      }
      get bufferRegions() {
        return this._bufferRegions;
      }
    };
    exports.VectorAssembler = VectorAssembler;
    function addBuffer(values) {
      const byteLength = values.byteLength + 7 & ~7;
      this.buffers.push(values);
      this.bufferRegions.push(new message_1.BufferRegion(this._byteLength, byteLength));
      this._byteLength += byteLength;
      return this;
    }
    function assembleUnion(vector) {
      const { type, length, typeIds, valueOffsets } = vector;
      addBuffer.call(this, typeIds);
      if (type.mode === enum_1.UnionMode.Sparse) {
        return assembleNestedVector.call(this, vector);
      } else if (type.mode === enum_1.UnionMode.Dense) {
        if (vector.offset <= 0) {
          addBuffer.call(this, valueOffsets);
          return assembleNestedVector.call(this, vector);
        } else {
          const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);
          const childLengths = new Int32Array(maxChildTypeId + 1);
          const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);
          const shiftedOffsets = new Int32Array(length);
          const unshiftedOffsets = buffer_1.rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);
          for (let typeId, shift, index = -1; ++index < length; ) {
            if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {
              shift = childOffsets[typeId] = unshiftedOffsets[typeId];
            }
            shiftedOffsets[index] = unshiftedOffsets[index] - shift;
            ++childLengths[typeId];
          }
          addBuffer.call(this, shiftedOffsets);
          for (let child, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren; ) {
            if (child = vector.getChildAt(childIndex)) {
              const typeId = type.typeIds[childIndex];
              const childLength = Math.min(length, childLengths[typeId]);
              this.visit(child.slice(childOffsets[typeId], childLength));
            }
          }
        }
      }
      return this;
    }
    function assembleBoolVector(vector) {
      let values;
      if (vector.nullCount >= vector.length) {
        return addBuffer.call(this, new Uint8Array(0));
      } else if ((values = vector.values) instanceof Uint8Array) {
        return addBuffer.call(this, bit_1.truncateBitmap(vector.offset, vector.length, values));
      }
      return addBuffer.call(this, bit_1.packBools(vector));
    }
    function assembleFlatVector(vector) {
      return addBuffer.call(this, vector.values.subarray(0, vector.length * vector.stride));
    }
    function assembleFlatListVector(vector) {
      const { length, values, valueOffsets } = vector;
      const firstOffset = valueOffsets[0];
      const lastOffset = valueOffsets[length];
      const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);
      addBuffer.call(this, buffer_1.rebaseValueOffsets(-valueOffsets[0], length, valueOffsets));
      addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength));
      return this;
    }
    function assembleListVector(vector) {
      const { length, valueOffsets } = vector;
      if (valueOffsets) {
        addBuffer.call(this, buffer_1.rebaseValueOffsets(valueOffsets[0], length, valueOffsets));
      }
      return this.visit(vector.getChildAt(0));
    }
    function assembleNestedVector(vector) {
      return this.visitMany(vector.type.children.map((_, i) => vector.getChildAt(i)).filter(Boolean))[0];
    }
    VectorAssembler.prototype.visitBool = assembleBoolVector;
    VectorAssembler.prototype.visitInt = assembleFlatVector;
    VectorAssembler.prototype.visitFloat = assembleFlatVector;
    VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
    VectorAssembler.prototype.visitBinary = assembleFlatListVector;
    VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
    VectorAssembler.prototype.visitDate = assembleFlatVector;
    VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
    VectorAssembler.prototype.visitTime = assembleFlatVector;
    VectorAssembler.prototype.visitDecimal = assembleFlatVector;
    VectorAssembler.prototype.visitList = assembleListVector;
    VectorAssembler.prototype.visitStruct = assembleNestedVector;
    VectorAssembler.prototype.visitUnion = assembleUnion;
    VectorAssembler.prototype.visitInterval = assembleFlatVector;
    VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
    VectorAssembler.prototype.visitMap = assembleListVector;
  }
});

// node_modules/apache-arrow/visitor/jsontypeassembler.js
var require_jsontypeassembler = __commonJS({
  "node_modules/apache-arrow/visitor/jsontypeassembler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var enum_1 = require_enum();
    var JSONTypeAssembler = class extends visitor_1.Visitor {
      visit(node) {
        return node == null ? void 0 : super.visit(node);
      }
      visitNull({ typeId }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase() };
      }
      visitInt({ typeId, bitWidth, isSigned }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "bitWidth": bitWidth, "isSigned": isSigned };
      }
      visitFloat({ typeId, precision }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "precision": enum_1.Precision[precision] };
      }
      visitBinary({ typeId }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase() };
      }
      visitBool({ typeId }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase() };
      }
      visitUtf8({ typeId }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase() };
      }
      visitDecimal({ typeId, scale, precision }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "scale": scale, "precision": precision };
      }
      visitDate({ typeId, unit }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "unit": enum_1.DateUnit[unit] };
      }
      visitTime({ typeId, unit, bitWidth }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "unit": enum_1.TimeUnit[unit], bitWidth };
      }
      visitTimestamp({ typeId, timezone, unit }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "unit": enum_1.TimeUnit[unit], timezone };
      }
      visitInterval({ typeId, unit }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "unit": enum_1.IntervalUnit[unit] };
      }
      visitList({ typeId }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase() };
      }
      visitStruct({ typeId }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase() };
      }
      visitUnion({ typeId, mode, typeIds }) {
        return {
          "name": enum_1.ArrowType[typeId].toLowerCase(),
          "mode": enum_1.UnionMode[mode],
          "typeIds": [...typeIds]
        };
      }
      visitDictionary(node) {
        return this.visit(node.dictionary);
      }
      visitFixedSizeBinary({ typeId, byteWidth }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "byteWidth": byteWidth };
      }
      visitFixedSizeList({ typeId, listSize }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "listSize": listSize };
      }
      visitMap({ typeId, keysSorted }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "keysSorted": keysSorted };
      }
    };
    exports.JSONTypeAssembler = JSONTypeAssembler;
  }
});

// node_modules/apache-arrow/visitor/jsonvectorassembler.js
var require_jsonvectorassembler = __commonJS({
  "node_modules/apache-arrow/visitor/jsonvectorassembler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bn_1 = require_bn();
    var column_1 = require_column();
    var vector_1 = require_vector();
    var visitor_1 = require_visitor();
    var enum_1 = require_enum();
    var recordbatch_1 = require_recordbatch2();
    var enum_2 = require_enum();
    var bit_1 = require_bit();
    var args_1 = require_args();
    var type_1 = require_type();
    var JSONVectorAssembler = class _JSONVectorAssembler extends visitor_1.Visitor {
      /** @nocollapse */
      static assemble(...args) {
        return new _JSONVectorAssembler().visitMany(args_1.selectColumnChildrenArgs(recordbatch_1.RecordBatch, args));
      }
      visit(column) {
        const { data, name, length } = column;
        const { offset, nullCount, nullBitmap } = data;
        const type = type_1.DataType.isDictionary(column.type) ? column.type.indices : column.type;
        const buffers = Object.assign([], data.buffers, { [enum_1.BufferType.VALIDITY]: void 0 });
        return {
          "name": name,
          "count": length,
          "VALIDITY": type_1.DataType.isNull(type) ? void 0 : nullCount <= 0 ? Array.from({ length }, () => 1) : [...bit_1.iterateBits(nullBitmap, offset, length, null, bit_1.getBit)],
          ...super.visit(vector_1.Vector.new(data.clone(type, offset, length, 0, buffers)))
        };
      }
      visitNull() {
        return {};
      }
      visitBool({ values, offset, length }) {
        return { "DATA": [...bit_1.iterateBits(values, offset, length, null, bit_1.getBool)] };
      }
      visitInt(vector) {
        return {
          "DATA": vector.type.bitWidth < 64 ? [...vector.values] : [...bigNumsToStrings(vector.values, 2)]
        };
      }
      visitFloat(vector) {
        return { "DATA": [...vector.values] };
      }
      visitUtf8(vector) {
        return { "DATA": [...vector], "OFFSET": [...vector.valueOffsets] };
      }
      visitBinary(vector) {
        return { "DATA": [...binaryToString(vector)], OFFSET: [...vector.valueOffsets] };
      }
      visitFixedSizeBinary(vector) {
        return { "DATA": [...binaryToString(vector)] };
      }
      visitDate(vector) {
        return {
          "DATA": vector.type.unit === enum_2.DateUnit.DAY ? [...vector.values] : [...bigNumsToStrings(vector.values, 2)]
        };
      }
      visitTimestamp(vector) {
        return { "DATA": [...bigNumsToStrings(vector.values, 2)] };
      }
      visitTime(vector) {
        return {
          "DATA": vector.type.unit < enum_2.TimeUnit.MICROSECOND ? [...vector.values] : [...bigNumsToStrings(vector.values, 2)]
        };
      }
      visitDecimal(vector) {
        return { "DATA": [...bigNumsToStrings(vector.values, 4)] };
      }
      visitList(vector) {
        return {
          "OFFSET": [...vector.valueOffsets],
          "children": vector.type.children.map((f, i) => this.visit(new column_1.Column(f, [vector.getChildAt(i)])))
        };
      }
      visitStruct(vector) {
        return {
          "children": vector.type.children.map((f, i) => this.visit(new column_1.Column(f, [vector.getChildAt(i)])))
        };
      }
      visitUnion(vector) {
        return {
          "TYPE": [...vector.typeIds],
          "OFFSET": vector.type.mode === enum_2.UnionMode.Dense ? [...vector.valueOffsets] : void 0,
          "children": vector.type.children.map((f, i) => this.visit(new column_1.Column(f, [vector.getChildAt(i)])))
        };
      }
      visitInterval(vector) {
        return { "DATA": [...vector.values] };
      }
      visitFixedSizeList(vector) {
        return {
          "children": vector.type.children.map((f, i) => this.visit(new column_1.Column(f, [vector.getChildAt(i)])))
        };
      }
      visitMap(vector) {
        return {
          "OFFSET": [...vector.valueOffsets],
          "children": vector.type.children.map((f, i) => this.visit(new column_1.Column(f, [vector.getChildAt(i)])))
        };
      }
    };
    exports.JSONVectorAssembler = JSONVectorAssembler;
    function* binaryToString(vector) {
      for (const octets of vector) {
        yield octets.reduce((str, byte) => {
          return `${str}${("0" + (byte & 255).toString(16)).slice(-2)}`;
        }, "").toUpperCase();
      }
    }
    function* bigNumsToStrings(values, stride) {
      for (let i = -1, n = values.length / stride; ++i < n; ) {
        yield `${bn_1.BN.new(values.subarray((i + 0) * stride, (i + 1) * stride), false)}`;
      }
    }
  }
});

// node_modules/apache-arrow/ipc/writer.js
var require_writer = __commonJS({
  "node_modules/apache-arrow/ipc/writer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var table_1 = require_table();
    var message_1 = require_message2();
    var column_1 = require_column();
    var type_1 = require_type();
    var schema_1 = require_schema();
    var message_2 = require_message();
    var metadata = require_message();
    var file_1 = require_file();
    var enum_1 = require_enum();
    var stream_1 = require_stream();
    var vectorassembler_1 = require_vectorassembler();
    var jsontypeassembler_1 = require_jsontypeassembler();
    var jsonvectorassembler_1 = require_jsonvectorassembler();
    var buffer_1 = require_buffer();
    var recordbatch_1 = require_recordbatch2();
    var interfaces_1 = require_interfaces();
    var compat_1 = require_compat();
    var RecordBatchWriter3 = class extends interfaces_1.ReadableInterop {
      constructor(options) {
        super();
        this._position = 0;
        this._started = false;
        this._sink = new stream_1.AsyncByteQueue();
        this._schema = null;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
        compat_1.isObject(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });
        this._autoDestroy = typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
        this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === "boolean" ? options.writeLegacyIpcFormat : false;
      }
      /** @nocollapse */
      // @ts-ignore
      static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
      }
      /** @nocollapse */
      static throughDOM(writableStrategy, readableStrategy) {
        throw new Error(`"throughDOM" not available in this environment`);
      }
      toString(sync = false) {
        return this._sink.toString(sync);
      }
      toUint8Array(sync = false) {
        return this._sink.toUint8Array(sync);
      }
      writeAll(input) {
        if (compat_1.isPromise(input)) {
          return input.then((x) => this.writeAll(x));
        } else if (compat_1.isAsyncIterable(input)) {
          return writeAllAsync(this, input);
        }
        return writeAll(this, input);
      }
      get closed() {
        return this._sink.closed;
      }
      [Symbol.asyncIterator]() {
        return this._sink[Symbol.asyncIterator]();
      }
      toDOMStream(options) {
        return this._sink.toDOMStream(options);
      }
      toNodeStream(options) {
        return this._sink.toNodeStream(options);
      }
      close() {
        return this.reset()._sink.close();
      }
      abort(reason) {
        return this.reset()._sink.abort(reason);
      }
      finish() {
        this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
        return this;
      }
      reset(sink = this._sink, schema = null) {
        if (sink === this._sink || sink instanceof stream_1.AsyncByteQueue) {
          this._sink = sink;
        } else {
          this._sink = new stream_1.AsyncByteQueue();
          if (sink && compat_1.isWritableDOMStream(sink)) {
            this.toDOMStream({ type: "bytes" }).pipeTo(sink);
          } else if (sink && compat_1.isWritableNodeStream(sink)) {
            this.toNodeStream({ objectMode: false }).pipe(sink);
          }
        }
        if (this._started && this._schema) {
          this._writeFooter(this._schema);
        }
        this._started = false;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
        if (!schema || !schema.compareTo(this._schema)) {
          if (schema === null) {
            this._position = 0;
            this._schema = null;
          } else {
            this._started = true;
            this._schema = schema;
            this._writeSchema(schema);
          }
        }
        return this;
      }
      write(payload) {
        let schema = null;
        if (!this._sink) {
          throw new Error(`RecordBatchWriter is closed`);
        } else if (payload === null || payload === void 0) {
          return this.finish() && void 0;
        } else if (payload instanceof table_1.Table && !(schema = payload.schema)) {
          return this.finish() && void 0;
        } else if (payload instanceof recordbatch_1.RecordBatch && !(schema = payload.schema)) {
          return this.finish() && void 0;
        }
        if (schema && !schema.compareTo(this._schema)) {
          if (this._started && this._autoDestroy) {
            return this.close();
          }
          this.reset(this._sink, schema);
        }
        if (payload instanceof recordbatch_1.RecordBatch) {
          if (!(payload instanceof recordbatch_1._InternalEmptyPlaceholderRecordBatch)) {
            this._writeRecordBatch(payload);
          }
        } else if (payload instanceof table_1.Table) {
          this.writeAll(payload.chunks);
        } else if (compat_1.isIterable(payload)) {
          this.writeAll(payload);
        }
      }
      _writeMessage(message, alignment = 8) {
        const a = alignment - 1;
        const buffer = message_2.Message.encode(message);
        const flatbufferSize = buffer.byteLength;
        const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
        const alignedSize = flatbufferSize + prefixSize + a & ~a;
        const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
        if (message.headerType === enum_1.MessageHeader.RecordBatch) {
          this._recordBatchBlocks.push(new file_1.FileBlock(alignedSize, message.bodyLength, this._position));
        } else if (message.headerType === enum_1.MessageHeader.DictionaryBatch) {
          this._dictionaryBlocks.push(new file_1.FileBlock(alignedSize, message.bodyLength, this._position));
        }
        if (!this._writeLegacyIpcFormat) {
          this._write(Int32Array.of(-1));
        }
        this._write(Int32Array.of(alignedSize - prefixSize));
        if (flatbufferSize > 0) {
          this._write(buffer);
        }
        return this._writePadding(nPaddingBytes);
      }
      _write(chunk) {
        if (this._started) {
          const buffer = buffer_1.toUint8Array(chunk);
          if (buffer && buffer.byteLength > 0) {
            this._sink.write(buffer);
            this._position += buffer.byteLength;
          }
        }
        return this;
      }
      _writeSchema(schema) {
        return this._writeMessage(message_2.Message.from(schema));
      }
      // @ts-ignore
      _writeFooter(schema) {
        return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
      }
      _writeMagic() {
        return this._write(message_1.MAGIC);
      }
      _writePadding(nBytes) {
        return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
      }
      _writeRecordBatch(batch) {
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_1.VectorAssembler.assemble(batch);
        const recordBatch = new metadata.RecordBatch(batch.length, nodes, bufferRegions);
        const message = message_2.Message.from(recordBatch, byteLength);
        return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
      }
      _writeDictionaryBatch(dictionary, id, isDelta = false) {
        this._dictionaryDeltaOffsets.set(id, dictionary.length + (this._dictionaryDeltaOffsets.get(id) || 0));
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_1.VectorAssembler.assemble(dictionary);
        const recordBatch = new metadata.RecordBatch(dictionary.length, nodes, bufferRegions);
        const dictionaryBatch = new metadata.DictionaryBatch(recordBatch, id, isDelta);
        const message = message_2.Message.from(dictionaryBatch, byteLength);
        return this._writeMessage(message)._writeBodyBuffers(buffers);
      }
      _writeBodyBuffers(buffers) {
        let buffer;
        let size, padding;
        for (let i = -1, n = buffers.length; ++i < n; ) {
          if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {
            this._write(buffer);
            if ((padding = (size + 7 & ~7) - size) > 0) {
              this._writePadding(padding);
            }
          }
        }
        return this;
      }
      _writeDictionaries(batch) {
        for (let [id, dictionary] of batch.dictionaries) {
          let offset = this._dictionaryDeltaOffsets.get(id) || 0;
          if (offset === 0 || (dictionary = dictionary.slice(offset)).length > 0) {
            const chunks = "chunks" in dictionary ? dictionary.chunks : [dictionary];
            for (const chunk of chunks) {
              this._writeDictionaryBatch(chunk, id, offset > 0);
              offset += chunk.length;
            }
          }
        }
        return this;
      }
    };
    exports.RecordBatchWriter = RecordBatchWriter3;
    var RecordBatchStreamWriter2 = class _RecordBatchStreamWriter extends RecordBatchWriter3 {
      /** @nocollapse */
      static writeAll(input, options) {
        const writer = new _RecordBatchStreamWriter(options);
        if (compat_1.isPromise(input)) {
          return input.then((x) => writer.writeAll(x));
        } else if (compat_1.isAsyncIterable(input)) {
          return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
      }
    };
    exports.RecordBatchStreamWriter = RecordBatchStreamWriter2;
    var RecordBatchFileWriter2 = class _RecordBatchFileWriter extends RecordBatchWriter3 {
      constructor() {
        super();
        this._autoDestroy = true;
      }
      /** @nocollapse */
      static writeAll(input) {
        const writer = new _RecordBatchFileWriter();
        if (compat_1.isPromise(input)) {
          return input.then((x) => writer.writeAll(x));
        } else if (compat_1.isAsyncIterable(input)) {
          return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
      }
      // @ts-ignore
      _writeSchema(schema) {
        return this._writeMagic()._writePadding(2);
      }
      _writeFooter(schema) {
        const buffer = file_1.Footer.encode(new file_1.Footer(schema, enum_1.MetadataVersion.V4, this._recordBatchBlocks, this._dictionaryBlocks));
        return super._writeFooter(schema)._write(buffer)._write(Int32Array.of(buffer.byteLength))._writeMagic();
      }
    };
    exports.RecordBatchFileWriter = RecordBatchFileWriter2;
    var RecordBatchJSONWriter2 = class _RecordBatchJSONWriter extends RecordBatchWriter3 {
      constructor() {
        super();
        this._autoDestroy = true;
        this._recordBatches = [];
        this._dictionaries = [];
      }
      /** @nocollapse */
      static writeAll(input) {
        return new _RecordBatchJSONWriter().writeAll(input);
      }
      _writeMessage() {
        return this;
      }
      // @ts-ignore
      _writeFooter(schema) {
        return this;
      }
      _writeSchema(schema) {
        return this._write(`{
  "schema": ${JSON.stringify({ fields: schema.fields.map(fieldToJSON) }, null, 2)}`);
      }
      _writeDictionaries(batch) {
        if (batch.dictionaries.size > 0) {
          this._dictionaries.push(batch);
        }
        return this;
      }
      _writeDictionaryBatch(dictionary, id, isDelta = false) {
        this._dictionaryDeltaOffsets.set(id, dictionary.length + (this._dictionaryDeltaOffsets.get(id) || 0));
        this._write(this._dictionaryBlocks.length === 0 ? `    ` : `,
    `);
        this._write(`${dictionaryBatchToJSON(dictionary, id, isDelta)}`);
        this._dictionaryBlocks.push(new file_1.FileBlock(0, 0, 0));
        return this;
      }
      _writeRecordBatch(batch) {
        this._writeDictionaries(batch);
        this._recordBatches.push(batch);
        return this;
      }
      close() {
        if (this._dictionaries.length > 0) {
          this._write(`,
  "dictionaries": [
`);
          for (const batch of this._dictionaries) {
            super._writeDictionaries(batch);
          }
          this._write(`
  ]`);
        }
        if (this._recordBatches.length > 0) {
          for (let i = -1, n = this._recordBatches.length; ++i < n; ) {
            this._write(i === 0 ? `,
  "batches": [
    ` : `,
    `);
            this._write(`${recordBatchToJSON(this._recordBatches[i])}`);
            this._recordBatchBlocks.push(new file_1.FileBlock(0, 0, 0));
          }
          this._write(`
  ]`);
        }
        if (this._schema) {
          this._write(`
}`);
        }
        this._dictionaries = [];
        this._recordBatches = [];
        return super.close();
      }
    };
    exports.RecordBatchJSONWriter = RecordBatchJSONWriter2;
    function writeAll(writer, input) {
      let chunks = input;
      if (input instanceof table_1.Table) {
        chunks = input.chunks;
        writer.reset(void 0, input.schema);
      }
      for (const batch of chunks) {
        writer.write(batch);
      }
      return writer.finish();
    }
    async function writeAllAsync(writer, batches) {
      for await (const batch of batches) {
        writer.write(batch);
      }
      return writer.finish();
    }
    function fieldToJSON({ name, type, nullable }) {
      const assembler = new jsontypeassembler_1.JSONTypeAssembler();
      return {
        "name": name,
        "nullable": nullable,
        "type": assembler.visit(type),
        "children": (type.children || []).map(fieldToJSON),
        "dictionary": !type_1.DataType.isDictionary(type) ? void 0 : {
          "id": type.id,
          "isOrdered": type.isOrdered,
          "indexType": assembler.visit(type.indices)
        }
      };
    }
    function dictionaryBatchToJSON(dictionary, id, isDelta = false) {
      const field = new schema_1.Field(`${id}`, dictionary.type, dictionary.nullCount > 0);
      const columns = jsonvectorassembler_1.JSONVectorAssembler.assemble(new column_1.Column(field, [dictionary]));
      return JSON.stringify({
        "id": id,
        "isDelta": isDelta,
        "data": {
          "count": dictionary.length,
          "columns": columns
        }
      }, null, 2);
    }
    function recordBatchToJSON(records) {
      return JSON.stringify({
        "count": records.length,
        "columns": jsonvectorassembler_1.JSONVectorAssembler.assemble(records)
      }, null, 2);
    }
  }
});

// node_modules/apache-arrow/util/recordbatch.js
var require_recordbatch = __commonJS({
  "node_modules/apache-arrow/util/recordbatch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var schema_1 = require_schema();
    var chunked_1 = require_chunked();
    var recordbatch_1 = require_recordbatch2();
    var noopBuf = new Uint8Array(0);
    var nullBufs = (bitmapLength) => [
      noopBuf,
      noopBuf,
      new Uint8Array(bitmapLength),
      noopBuf
    ];
    function ensureSameLengthData(schema, chunks, batchLength = chunks.reduce((l, c) => Math.max(l, c.length), 0)) {
      let data;
      let field;
      let i = -1, n = chunks.length;
      const fields = [...schema.fields];
      const batchData = [];
      const bitmapLength = (batchLength + 63 & ~63) >> 3;
      while (++i < n) {
        if ((data = chunks[i]) && data.length === batchLength) {
          batchData[i] = data;
        } else {
          (field = fields[i]).nullable || (fields[i] = fields[i].clone({ nullable: true }));
          batchData[i] = data ? data._changeLengthAndBackfillNullBitmap(batchLength) : data_1.Data.new(field.type, 0, batchLength, batchLength, nullBufs(bitmapLength));
        }
      }
      return [new schema_1.Schema(fields), batchLength, batchData];
    }
    exports.ensureSameLengthData = ensureSameLengthData;
    function distributeColumnsIntoRecordBatches(columns) {
      return distributeVectorsIntoRecordBatches(new schema_1.Schema(columns.map(({ field }) => field)), columns);
    }
    exports.distributeColumnsIntoRecordBatches = distributeColumnsIntoRecordBatches;
    function distributeVectorsIntoRecordBatches(schema, vecs) {
      return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v) => v instanceof chunked_1.Chunked ? v.chunks.map((c) => c.data) : [v.data]));
    }
    exports.distributeVectorsIntoRecordBatches = distributeVectorsIntoRecordBatches;
    function uniformlyDistributeChunksAcrossRecordBatches(schema, columns) {
      const fields = [...schema.fields];
      const batchArgs = [];
      const memo = { numBatches: columns.reduce((n, c) => Math.max(n, c.length), 0) };
      let numBatches = 0, batchLength = 0;
      let i = -1, numColumns = columns.length;
      let child, childData = [];
      while (memo.numBatches-- > 0) {
        for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns; ) {
          childData[i] = child = columns[i].shift();
          batchLength = Math.min(batchLength, child ? child.length : batchLength);
        }
        if (isFinite(batchLength)) {
          childData = distributeChildData(fields, batchLength, childData, columns, memo);
          if (batchLength > 0) {
            batchArgs[numBatches++] = [batchLength, childData.slice()];
          }
        }
      }
      return [
        schema = new schema_1.Schema(fields, schema.metadata),
        batchArgs.map((xs) => new recordbatch_1.RecordBatch(schema, ...xs))
      ];
    }
    function distributeChildData(fields, batchLength, childData, columns, memo) {
      let data;
      let field;
      let length = 0, i = -1, n = columns.length;
      const bitmapLength = (batchLength + 63 & ~63) >> 3;
      while (++i < n) {
        if ((data = childData[i]) && (length = data.length) >= batchLength) {
          if (length === batchLength) {
            childData[i] = data;
          } else {
            childData[i] = data.slice(0, batchLength);
            data = data.slice(batchLength, length - batchLength);
            memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(data));
          }
        } else {
          (field = fields[i]).nullable || (fields[i] = field.clone({ nullable: true }));
          childData[i] = data ? data._changeLengthAndBackfillNullBitmap(batchLength) : data_1.Data.new(field.type, 0, batchLength, batchLength, nullBufs(bitmapLength));
        }
      }
      return childData;
    }
  }
});

// node_modules/apache-arrow/vector/base.js
var require_base = __commonJS({
  "node_modules/apache-arrow/vector/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var enum_1 = require_enum();
    var chunked_1 = require_chunked();
    var vector_1 = require_vector2();
    var vector_2 = require_vector();
    var BaseVector2 = class extends vector_2.AbstractVector {
      constructor(data, children) {
        super();
        this._children = children;
        this.numChildren = data.childData.length;
        this._bindDataAccessors(this.data = data);
      }
      get type() {
        return this.data.type;
      }
      get typeId() {
        return this.data.typeId;
      }
      get length() {
        return this.data.length;
      }
      get offset() {
        return this.data.offset;
      }
      get stride() {
        return this.data.stride;
      }
      get nullCount() {
        return this.data.nullCount;
      }
      get byteLength() {
        return this.data.byteLength;
      }
      get VectorName() {
        return `${enum_1.Type[this.typeId]}Vector`;
      }
      get ArrayType() {
        return this.type.ArrayType;
      }
      get values() {
        return this.data.values;
      }
      get typeIds() {
        return this.data.typeIds;
      }
      get nullBitmap() {
        return this.data.nullBitmap;
      }
      get valueOffsets() {
        return this.data.valueOffsets;
      }
      get [Symbol.toStringTag]() {
        return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
      }
      clone(data, children = this._children) {
        return vector_2.Vector.new(data, children);
      }
      concat(...others) {
        return chunked_1.Chunked.concat(this, ...others);
      }
      slice(begin, end) {
        return vector_1.clampRange(this, begin, end, this._sliceInternal);
      }
      isValid(index) {
        if (this.nullCount > 0) {
          const idx = this.offset + index;
          const val = this.nullBitmap[idx >> 3];
          const mask = val & 1 << idx % 8;
          return mask !== 0;
        }
        return true;
      }
      getChildAt(index) {
        return index < 0 || index >= this.numChildren ? null : (this._children || (this._children = []))[index] || (this._children[index] = vector_2.Vector.new(this.data.childData[index]));
      }
      toJSON() {
        return [...this];
      }
      _sliceInternal(self, begin, end) {
        return self.clone(self.data.slice(begin, end - begin), null);
      }
      // @ts-ignore
      _bindDataAccessors(data) {
      }
    };
    exports.BaseVector = BaseVector2;
    BaseVector2.prototype[Symbol.isConcatSpreadable] = true;
  }
});

// node_modules/apache-arrow/vector/binary.js
var require_binary2 = __commonJS({
  "node_modules/apache-arrow/vector/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var base_1 = require_base();
    var type_1 = require_type();
    var BinaryVector2 = class extends base_1.BaseVector {
      asUtf8() {
        return vector_1.Vector.new(this.data.clone(new type_1.Utf8()));
      }
    };
    exports.BinaryVector = BinaryVector2;
  }
});

// node_modules/apache-arrow/vector/bool.js
var require_bool2 = __commonJS({
  "node_modules/apache-arrow/vector/bool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var type_1 = require_type();
    var base_1 = require_base();
    var index_1 = require_vector3();
    var BoolVector2 = class extends base_1.BaseVector {
      /** @nocollapse */
      static from(input) {
        return index_1.vectorFromValuesWithType(() => new type_1.Bool(), input);
      }
    };
    exports.BoolVector = BoolVector2;
  }
});

// node_modules/apache-arrow/vector/date.js
var require_date2 = __commonJS({
  "node_modules/apache-arrow/vector/date.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var enum_1 = require_enum();
    var base_1 = require_base();
    var index_1 = require_vector3();
    var type_1 = require_type();
    var DateVector2 = class extends base_1.BaseVector {
      /** @nocollapse */
      static from(...args) {
        if (args.length === 2) {
          return index_1.vectorFromValuesWithType(() => args[1] === enum_1.DateUnit.DAY ? new type_1.DateDay() : new type_1.DateMillisecond(), args[0]);
        }
        return index_1.vectorFromValuesWithType(() => new type_1.DateMillisecond(), args[0]);
      }
    };
    exports.DateVector = DateVector2;
    var DateDayVector2 = class extends DateVector2 {
    };
    exports.DateDayVector = DateDayVector2;
    var DateMillisecondVector2 = class extends DateVector2 {
    };
    exports.DateMillisecondVector = DateMillisecondVector2;
  }
});

// node_modules/apache-arrow/vector/decimal.js
var require_decimal2 = __commonJS({
  "node_modules/apache-arrow/vector/decimal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var DecimalVector2 = class extends base_1.BaseVector {
    };
    exports.DecimalVector = DecimalVector2;
  }
});

// node_modules/apache-arrow/vector/dictionary.js
var require_dictionary2 = __commonJS({
  "node_modules/apache-arrow/vector/dictionary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var vector_1 = require_vector();
    var base_1 = require_base();
    var index_1 = require_vector3();
    var type_1 = require_type();
    var DictionaryVector2 = class extends base_1.BaseVector {
      constructor(data) {
        super(data);
        this.indices = vector_1.Vector.new(data.clone(this.type.indices));
      }
      /** @nocollapse */
      static from(...args) {
        if (args.length === 3) {
          const [values, indices, keys] = args;
          const type = new type_1.Dictionary(values.type, indices, null, null);
          return vector_1.Vector.new(data_1.Data.Dictionary(type, 0, keys.length, 0, null, keys, values));
        }
        return index_1.vectorFromValuesWithType(() => args[0].type, args[0]);
      }
      get dictionary() {
        return this.data.dictionary;
      }
      reverseLookup(value) {
        return this.dictionary.indexOf(value);
      }
      getKey(idx) {
        return this.indices.get(idx);
      }
      getValue(key) {
        return this.dictionary.get(key);
      }
      setKey(idx, key) {
        return this.indices.set(idx, key);
      }
      setValue(key, value) {
        return this.dictionary.set(key, value);
      }
    };
    exports.DictionaryVector = DictionaryVector2;
    DictionaryVector2.prototype.indices = null;
  }
});

// node_modules/apache-arrow/vector/fixedsizebinary.js
var require_fixedsizebinary2 = __commonJS({
  "node_modules/apache-arrow/vector/fixedsizebinary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var FixedSizeBinaryVector2 = class extends base_1.BaseVector {
    };
    exports.FixedSizeBinaryVector = FixedSizeBinaryVector2;
  }
});

// node_modules/apache-arrow/vector/fixedsizelist.js
var require_fixedsizelist2 = __commonJS({
  "node_modules/apache-arrow/vector/fixedsizelist.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var FixedSizeListVector2 = class extends base_1.BaseVector {
    };
    exports.FixedSizeListVector = FixedSizeListVector2;
  }
});

// node_modules/apache-arrow/vector/float.js
var require_float2 = __commonJS({
  "node_modules/apache-arrow/vector/float.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var vector_1 = require_vector();
    var base_1 = require_base();
    var index_1 = require_vector3();
    var type_1 = require_type();
    var FloatVector2 = class extends base_1.BaseVector {
      /** @nocollapse */
      static from(input) {
        let ArrowType2 = vectorTypeToDataType(this);
        if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
          let InputType = arrayTypeToDataType(input.constructor) || ArrowType2;
          if (ArrowType2 === null) {
            ArrowType2 = InputType;
          }
          if (ArrowType2 && ArrowType2 === InputType) {
            let type = new ArrowType2();
            let length = input.byteLength / type.ArrayType.BYTES_PER_ELEMENT;
            if (!convertTo16Bit(ArrowType2, input.constructor)) {
              return vector_1.Vector.new(data_1.Data.Float(type, 0, length, 0, null, input));
            }
          }
        }
        if (ArrowType2) {
          return index_1.vectorFromValuesWithType(() => new ArrowType2(), input);
        }
        if (input instanceof DataView || input instanceof ArrayBuffer) {
          throw new TypeError(`Cannot infer float type from instance of ${input.constructor.name}`);
        }
        throw new TypeError("Unrecognized FloatVector input");
      }
    };
    exports.FloatVector = FloatVector2;
    var Float16Vector2 = class extends FloatVector2 {
      // Since JS doesn't have half floats, `toArray()` returns a zero-copy slice
      // of the underlying Uint16Array data. This behavior ensures we don't incur
      // extra compute or copies if you're calling `toArray()` in order to create
      // a buffer for something like WebGL. Buf if you're using JS and want typed
      // arrays of 4-to-8-byte precision, these methods will enumerate the values
      // and clamp to the desired byte lengths.
      toFloat32Array() {
        return new Float32Array(this);
      }
      toFloat64Array() {
        return new Float64Array(this);
      }
    };
    exports.Float16Vector = Float16Vector2;
    var Float32Vector2 = class extends FloatVector2 {
    };
    exports.Float32Vector = Float32Vector2;
    var Float64Vector2 = class extends FloatVector2 {
    };
    exports.Float64Vector = Float64Vector2;
    var convertTo16Bit = (typeCtor, dataCtor) => {
      return typeCtor === type_1.Float16 && dataCtor !== Uint16Array;
    };
    var arrayTypeToDataType = (ctor) => {
      switch (ctor) {
        case Uint16Array:
          return type_1.Float16;
        case Float32Array:
          return type_1.Float32;
        case Float64Array:
          return type_1.Float64;
        default:
          return null;
      }
    };
    var vectorTypeToDataType = (ctor) => {
      switch (ctor) {
        case Float16Vector2:
          return type_1.Float16;
        case Float32Vector2:
          return type_1.Float32;
        case Float64Vector2:
          return type_1.Float64;
        default:
          return null;
      }
    };
  }
});

// node_modules/apache-arrow/vector/interval.js
var require_interval2 = __commonJS({
  "node_modules/apache-arrow/vector/interval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var IntervalVector2 = class extends base_1.BaseVector {
    };
    exports.IntervalVector = IntervalVector2;
    var IntervalDayTimeVector2 = class extends IntervalVector2 {
    };
    exports.IntervalDayTimeVector = IntervalDayTimeVector2;
    var IntervalYearMonthVector2 = class extends IntervalVector2 {
    };
    exports.IntervalYearMonthVector = IntervalYearMonthVector2;
  }
});

// node_modules/apache-arrow/vector/int.js
var require_int3 = __commonJS({
  "node_modules/apache-arrow/vector/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var vector_1 = require_vector();
    var base_1 = require_base();
    var index_1 = require_vector3();
    var compat_1 = require_compat();
    var buffer_1 = require_buffer();
    var type_1 = require_type();
    var IntVector2 = class extends base_1.BaseVector {
      /** @nocollapse */
      static from(...args) {
        let [input, is64bit = false] = args;
        let ArrowType2 = vectorTypeToDataType(this, is64bit);
        if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
          let InputType = arrayTypeToDataType(input.constructor, is64bit) || ArrowType2;
          if (ArrowType2 === null) {
            ArrowType2 = InputType;
          }
          if (ArrowType2 && ArrowType2 === InputType) {
            let type = new ArrowType2();
            let length = input.byteLength / type.ArrayType.BYTES_PER_ELEMENT;
            if (convert32To64Bit(ArrowType2, input.constructor)) {
              length *= 0.5;
            }
            return vector_1.Vector.new(data_1.Data.Int(type, 0, length, 0, null, input));
          }
        }
        if (ArrowType2) {
          return index_1.vectorFromValuesWithType(() => new ArrowType2(), input);
        }
        if (input instanceof DataView || input instanceof ArrayBuffer) {
          throw new TypeError(`Cannot infer integer type from instance of ${input.constructor.name}`);
        }
        throw new TypeError("Unrecognized IntVector input");
      }
    };
    exports.IntVector = IntVector2;
    var Int8Vector2 = class extends IntVector2 {
    };
    exports.Int8Vector = Int8Vector2;
    var Int16Vector2 = class extends IntVector2 {
    };
    exports.Int16Vector = Int16Vector2;
    var Int32Vector2 = class extends IntVector2 {
    };
    exports.Int32Vector = Int32Vector2;
    var Int64Vector2 = class extends IntVector2 {
      toBigInt64Array() {
        return buffer_1.toBigInt64Array(this.values);
      }
      get values64() {
        return this._values64 || (this._values64 = this.toBigInt64Array());
      }
    };
    exports.Int64Vector = Int64Vector2;
    var Uint8Vector2 = class extends IntVector2 {
    };
    exports.Uint8Vector = Uint8Vector2;
    var Uint16Vector2 = class extends IntVector2 {
    };
    exports.Uint16Vector = Uint16Vector2;
    var Uint32Vector2 = class extends IntVector2 {
    };
    exports.Uint32Vector = Uint32Vector2;
    var Uint64Vector2 = class extends IntVector2 {
      toBigUint64Array() {
        return buffer_1.toBigUint64Array(this.values);
      }
      get values64() {
        return this._values64 || (this._values64 = this.toBigUint64Array());
      }
    };
    exports.Uint64Vector = Uint64Vector2;
    var convert32To64Bit = (typeCtor, dataCtor) => {
      return (typeCtor === type_1.Int64 || typeCtor === type_1.Uint64) && (dataCtor === Int32Array || dataCtor === Uint32Array);
    };
    var arrayTypeToDataType = (ctor, is64bit) => {
      switch (ctor) {
        case Int8Array:
          return type_1.Int8;
        case Int16Array:
          return type_1.Int16;
        case Int32Array:
          return is64bit ? type_1.Int64 : type_1.Int32;
        case compat_1.BigInt64Array:
          return type_1.Int64;
        case Uint8Array:
          return type_1.Uint8;
        case Uint16Array:
          return type_1.Uint16;
        case Uint32Array:
          return is64bit ? type_1.Uint64 : type_1.Uint32;
        case compat_1.BigUint64Array:
          return type_1.Uint64;
        default:
          return null;
      }
    };
    var vectorTypeToDataType = (ctor, is64bit) => {
      switch (ctor) {
        case Int8Vector2:
          return type_1.Int8;
        case Int16Vector2:
          return type_1.Int16;
        case Int32Vector2:
          return is64bit ? type_1.Int64 : type_1.Int32;
        case Int64Vector2:
          return type_1.Int64;
        case Uint8Vector2:
          return type_1.Uint8;
        case Uint16Vector2:
          return type_1.Uint16;
        case Uint32Vector2:
          return is64bit ? type_1.Uint64 : type_1.Uint32;
        case Uint64Vector2:
          return type_1.Uint64;
        default:
          return null;
      }
    };
  }
});

// node_modules/apache-arrow/vector/list.js
var require_list2 = __commonJS({
  "node_modules/apache-arrow/vector/list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var ListVector2 = class extends base_1.BaseVector {
    };
    exports.ListVector = ListVector2;
  }
});

// node_modules/apache-arrow/vector/map.js
var require_map2 = __commonJS({
  "node_modules/apache-arrow/vector/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var row_1 = require_row();
    var vector_1 = require_vector();
    var base_1 = require_base();
    var type_1 = require_type();
    var MapVector2 = class extends base_1.BaseVector {
      asList() {
        const child = this.type.children[0];
        return vector_1.Vector.new(this.data.clone(new type_1.List(child)));
      }
      bind(index) {
        const child = this.getChildAt(0);
        const { [index]: begin, [index + 1]: end } = this.valueOffsets;
        return new row_1.MapRow(child.slice(begin, end));
      }
    };
    exports.MapVector = MapVector2;
  }
});

// node_modules/apache-arrow/vector/null.js
var require_null2 = __commonJS({
  "node_modules/apache-arrow/vector/null.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var NullVector2 = class extends base_1.BaseVector {
    };
    exports.NullVector = NullVector2;
  }
});

// node_modules/apache-arrow/vector/struct.js
var require_struct2 = __commonJS({
  "node_modules/apache-arrow/vector/struct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var row_1 = require_row();
    var base_1 = require_base();
    var kRowIndex = Symbol.for("rowIndex");
    var StructVector2 = class extends base_1.BaseVector {
      bind(index) {
        const proto = this._row || (this._row = new row_1.StructRow(this));
        const bound = Object.create(proto);
        bound[kRowIndex] = index;
        return bound;
      }
    };
    exports.StructVector = StructVector2;
  }
});

// node_modules/apache-arrow/vector/timestamp.js
var require_timestamp2 = __commonJS({
  "node_modules/apache-arrow/vector/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var TimestampVector2 = class extends base_1.BaseVector {
    };
    exports.TimestampVector = TimestampVector2;
    var TimestampSecondVector2 = class extends TimestampVector2 {
    };
    exports.TimestampSecondVector = TimestampSecondVector2;
    var TimestampMillisecondVector2 = class extends TimestampVector2 {
    };
    exports.TimestampMillisecondVector = TimestampMillisecondVector2;
    var TimestampMicrosecondVector2 = class extends TimestampVector2 {
    };
    exports.TimestampMicrosecondVector = TimestampMicrosecondVector2;
    var TimestampNanosecondVector2 = class extends TimestampVector2 {
    };
    exports.TimestampNanosecondVector = TimestampNanosecondVector2;
  }
});

// node_modules/apache-arrow/vector/time.js
var require_time2 = __commonJS({
  "node_modules/apache-arrow/vector/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var TimeVector2 = class extends base_1.BaseVector {
    };
    exports.TimeVector = TimeVector2;
    var TimeSecondVector2 = class extends TimeVector2 {
    };
    exports.TimeSecondVector = TimeSecondVector2;
    var TimeMillisecondVector2 = class extends TimeVector2 {
    };
    exports.TimeMillisecondVector = TimeMillisecondVector2;
    var TimeMicrosecondVector2 = class extends TimeVector2 {
    };
    exports.TimeMicrosecondVector = TimeMicrosecondVector2;
    var TimeNanosecondVector2 = class extends TimeVector2 {
    };
    exports.TimeNanosecondVector = TimeNanosecondVector2;
  }
});

// node_modules/apache-arrow/vector/union.js
var require_union2 = __commonJS({
  "node_modules/apache-arrow/vector/union.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var UnionVector2 = class extends base_1.BaseVector {
      get typeIdToChildIndex() {
        return this.data.type.typeIdToChildIndex;
      }
    };
    exports.UnionVector = UnionVector2;
    var DenseUnionVector2 = class extends UnionVector2 {
      get valueOffsets() {
        return this.data.valueOffsets;
      }
    };
    exports.DenseUnionVector = DenseUnionVector2;
    var SparseUnionVector2 = class extends UnionVector2 {
    };
    exports.SparseUnionVector = SparseUnionVector2;
  }
});

// node_modules/apache-arrow/vector/utf8.js
var require_utf83 = __commonJS({
  "node_modules/apache-arrow/vector/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var base_1 = require_base();
    var type_1 = require_type();
    var index_1 = require_vector3();
    var Utf8Vector2 = class extends base_1.BaseVector {
      /** @nocollapse */
      static from(input) {
        return index_1.vectorFromValuesWithType(() => new type_1.Utf8(), input);
      }
      asBinary() {
        return vector_1.Vector.new(this.data.clone(new type_1.Binary()));
      }
    };
    exports.Utf8Vector = Utf8Vector2;
  }
});

// node_modules/apache-arrow/util/fn.js
var require_fn = __commonJS({
  "node_modules/apache-arrow/util/fn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function partial0(visit) {
      return function() {
        return visit(this);
      };
    }
    exports.partial0 = partial0;
    function partial1(visit) {
      return function(a) {
        return visit(this, a);
      };
    }
    exports.partial1 = partial1;
    function partial2(visit) {
      return function(a, b) {
        return visit(this, a, b);
      };
    }
    exports.partial2 = partial2;
  }
});

// node_modules/apache-arrow/visitor/get.js
var require_get = __commonJS({
  "node_modules/apache-arrow/visitor/get.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bn_1 = require_bn();
    var visitor_1 = require_visitor();
    var utf8_1 = require_utf8();
    var math_1 = require_math();
    var enum_1 = require_enum();
    var GetVisitor = class extends visitor_1.Visitor {
    };
    exports.GetVisitor = GetVisitor;
    var epochDaysToMs = (data, index) => 864e5 * data[index];
    var epochMillisecondsLongToMs = (data, index) => 4294967296 * data[index + 1] + (data[index] >>> 0);
    var epochMicrosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1e3) + (data[index] >>> 0) / 1e3;
    var epochNanosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1e6) + (data[index] >>> 0) / 1e6;
    var epochMillisecondsToDate = (epochMs) => new Date(epochMs);
    var epochDaysToDate = (data, index) => epochMillisecondsToDate(epochDaysToMs(data, index));
    var epochMillisecondsLongToDate = (data, index) => epochMillisecondsToDate(epochMillisecondsLongToMs(data, index));
    var getNull = (_vector, _index) => null;
    var getVariableWidthBytes = (values, valueOffsets, index) => {
      const { [index]: x, [index + 1]: y } = valueOffsets;
      return x != null && y != null ? values.subarray(x, y) : null;
    };
    var getBool = ({ offset, values }, index) => {
      const idx = offset + index;
      const byte = values[idx >> 3];
      return (byte & 1 << idx % 8) !== 0;
    };
    var getDateDay = ({ values }, index) => epochDaysToDate(values, index);
    var getDateMillisecond = ({ values }, index) => epochMillisecondsLongToDate(values, index * 2);
    var getNumeric = ({ stride, values }, index) => values[stride * index];
    var getFloat16 = ({ stride, values }, index) => math_1.uint16ToFloat64(values[stride * index]);
    var getBigInts = ({ stride, values, type }, index) => bn_1.BN.new(values.subarray(stride * index, stride * (index + 1)), type.isSigned);
    var getFixedSizeBinary = ({ stride, values }, index) => values.subarray(stride * index, stride * (index + 1));
    var getBinary = ({ values, valueOffsets }, index) => getVariableWidthBytes(values, valueOffsets, index);
    var getUtf8 = ({ values, valueOffsets }, index) => {
      const bytes = getVariableWidthBytes(values, valueOffsets, index);
      return bytes !== null ? utf8_1.decodeUtf8(bytes) : null;
    };
    var getInt = (vector, index) => vector.type.bitWidth < 64 ? getNumeric(vector, index) : getBigInts(vector, index);
    var getFloat = (vector, index) => vector.type.precision !== enum_1.Precision.HALF ? getNumeric(vector, index) : getFloat16(vector, index);
    var getDate = (vector, index) => vector.type.unit === enum_1.DateUnit.DAY ? getDateDay(vector, index) : getDateMillisecond(vector, index);
    var getTimestampSecond = ({ values }, index) => 1e3 * epochMillisecondsLongToMs(values, index * 2);
    var getTimestampMillisecond = ({ values }, index) => epochMillisecondsLongToMs(values, index * 2);
    var getTimestampMicrosecond = ({ values }, index) => epochMicrosecondsLongToMs(values, index * 2);
    var getTimestampNanosecond = ({ values }, index) => epochNanosecondsLongToMs(values, index * 2);
    var getTimestamp = (vector, index) => {
      switch (vector.type.unit) {
        case enum_1.TimeUnit.SECOND:
          return getTimestampSecond(vector, index);
        case enum_1.TimeUnit.MILLISECOND:
          return getTimestampMillisecond(vector, index);
        case enum_1.TimeUnit.MICROSECOND:
          return getTimestampMicrosecond(vector, index);
        case enum_1.TimeUnit.NANOSECOND:
          return getTimestampNanosecond(vector, index);
      }
    };
    var getTimeSecond = ({ values, stride }, index) => values[stride * index];
    var getTimeMillisecond = ({ values, stride }, index) => values[stride * index];
    var getTimeMicrosecond = ({ values }, index) => bn_1.BN.signed(values.subarray(2 * index, 2 * (index + 1)));
    var getTimeNanosecond = ({ values }, index) => bn_1.BN.signed(values.subarray(2 * index, 2 * (index + 1)));
    var getTime = (vector, index) => {
      switch (vector.type.unit) {
        case enum_1.TimeUnit.SECOND:
          return getTimeSecond(vector, index);
        case enum_1.TimeUnit.MILLISECOND:
          return getTimeMillisecond(vector, index);
        case enum_1.TimeUnit.MICROSECOND:
          return getTimeMicrosecond(vector, index);
        case enum_1.TimeUnit.NANOSECOND:
          return getTimeNanosecond(vector, index);
      }
    };
    var getDecimal = ({ values }, index) => bn_1.BN.decimal(values.subarray(4 * index, 4 * (index + 1)));
    var getList = (vector, index) => {
      const child = vector.getChildAt(0), { valueOffsets, stride } = vector;
      return child.slice(valueOffsets[index * stride], valueOffsets[index * stride + 1]);
    };
    var getMap = (vector, index) => {
      return vector.bind(index);
    };
    var getStruct = (vector, index) => {
      return vector.bind(index);
    };
    var getUnion = (vector, index) => {
      return vector.type.mode === enum_1.UnionMode.Dense ? getDenseUnion(vector, index) : getSparseUnion(vector, index);
    };
    var getDenseUnion = (vector, index) => {
      const childIndex = vector.typeIdToChildIndex[vector.typeIds[index]];
      const child = vector.getChildAt(childIndex);
      return child ? child.get(vector.valueOffsets[index]) : null;
    };
    var getSparseUnion = (vector, index) => {
      const childIndex = vector.typeIdToChildIndex[vector.typeIds[index]];
      const child = vector.getChildAt(childIndex);
      return child ? child.get(index) : null;
    };
    var getDictionary = (vector, index) => {
      return vector.getValue(vector.getKey(index));
    };
    var getInterval = (vector, index) => vector.type.unit === enum_1.IntervalUnit.DAY_TIME ? getIntervalDayTime(vector, index) : getIntervalYearMonth(vector, index);
    var getIntervalDayTime = ({ values }, index) => values.subarray(2 * index, 2 * (index + 1));
    var getIntervalYearMonth = ({ values }, index) => {
      const interval = values[index];
      const int32s = new Int32Array(2);
      int32s[0] = interval / 12 | 0;
      int32s[1] = interval % 12 | 0;
      return int32s;
    };
    var getFixedSizeList = (vector, index) => {
      const child = vector.getChildAt(0), { stride } = vector;
      return child.slice(index * stride, (index + 1) * stride);
    };
    GetVisitor.prototype.visitNull = getNull;
    GetVisitor.prototype.visitBool = getBool;
    GetVisitor.prototype.visitInt = getInt;
    GetVisitor.prototype.visitInt8 = getNumeric;
    GetVisitor.prototype.visitInt16 = getNumeric;
    GetVisitor.prototype.visitInt32 = getNumeric;
    GetVisitor.prototype.visitInt64 = getBigInts;
    GetVisitor.prototype.visitUint8 = getNumeric;
    GetVisitor.prototype.visitUint16 = getNumeric;
    GetVisitor.prototype.visitUint32 = getNumeric;
    GetVisitor.prototype.visitUint64 = getBigInts;
    GetVisitor.prototype.visitFloat = getFloat;
    GetVisitor.prototype.visitFloat16 = getFloat16;
    GetVisitor.prototype.visitFloat32 = getNumeric;
    GetVisitor.prototype.visitFloat64 = getNumeric;
    GetVisitor.prototype.visitUtf8 = getUtf8;
    GetVisitor.prototype.visitBinary = getBinary;
    GetVisitor.prototype.visitFixedSizeBinary = getFixedSizeBinary;
    GetVisitor.prototype.visitDate = getDate;
    GetVisitor.prototype.visitDateDay = getDateDay;
    GetVisitor.prototype.visitDateMillisecond = getDateMillisecond;
    GetVisitor.prototype.visitTimestamp = getTimestamp;
    GetVisitor.prototype.visitTimestampSecond = getTimestampSecond;
    GetVisitor.prototype.visitTimestampMillisecond = getTimestampMillisecond;
    GetVisitor.prototype.visitTimestampMicrosecond = getTimestampMicrosecond;
    GetVisitor.prototype.visitTimestampNanosecond = getTimestampNanosecond;
    GetVisitor.prototype.visitTime = getTime;
    GetVisitor.prototype.visitTimeSecond = getTimeSecond;
    GetVisitor.prototype.visitTimeMillisecond = getTimeMillisecond;
    GetVisitor.prototype.visitTimeMicrosecond = getTimeMicrosecond;
    GetVisitor.prototype.visitTimeNanosecond = getTimeNanosecond;
    GetVisitor.prototype.visitDecimal = getDecimal;
    GetVisitor.prototype.visitList = getList;
    GetVisitor.prototype.visitStruct = getStruct;
    GetVisitor.prototype.visitUnion = getUnion;
    GetVisitor.prototype.visitDenseUnion = getDenseUnion;
    GetVisitor.prototype.visitSparseUnion = getSparseUnion;
    GetVisitor.prototype.visitDictionary = getDictionary;
    GetVisitor.prototype.visitInterval = getInterval;
    GetVisitor.prototype.visitIntervalDayTime = getIntervalDayTime;
    GetVisitor.prototype.visitIntervalYearMonth = getIntervalYearMonth;
    GetVisitor.prototype.visitFixedSizeList = getFixedSizeList;
    GetVisitor.prototype.visitMap = getMap;
    exports.instance = new GetVisitor();
  }
});

// node_modules/apache-arrow/visitor/indexof.js
var require_indexof = __commonJS({
  "node_modules/apache-arrow/visitor/indexof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var bit_1 = require_bit();
    var vector_1 = require_vector2();
    var IndexOfVisitor = class extends visitor_1.Visitor {
    };
    exports.IndexOfVisitor = IndexOfVisitor;
    function nullIndexOf(vector, searchElement) {
      return searchElement === null && vector.length > 0 ? 0 : -1;
    }
    function indexOfNull(vector, fromIndex) {
      const { nullBitmap } = vector;
      if (!nullBitmap || vector.nullCount <= 0) {
        return -1;
      }
      let i = 0;
      for (const isValid of bit_1.iterateBits(nullBitmap, vector.data.offset + (fromIndex || 0), vector.length, nullBitmap, bit_1.getBool)) {
        if (!isValid) {
          return i;
        }
        ++i;
      }
      return -1;
    }
    function indexOfValue(vector, searchElement, fromIndex) {
      if (searchElement === void 0) {
        return -1;
      }
      if (searchElement === null) {
        return indexOfNull(vector, fromIndex);
      }
      const compare = vector_1.createElementComparator(searchElement);
      for (let i = (fromIndex || 0) - 1, n = vector.length; ++i < n; ) {
        if (compare(vector.get(i))) {
          return i;
        }
      }
      return -1;
    }
    function indexOfUnion(vector, searchElement, fromIndex) {
      const compare = vector_1.createElementComparator(searchElement);
      for (let i = (fromIndex || 0) - 1, n = vector.length; ++i < n; ) {
        if (compare(vector.get(i))) {
          return i;
        }
      }
      return -1;
    }
    IndexOfVisitor.prototype.visitNull = nullIndexOf;
    IndexOfVisitor.prototype.visitBool = indexOfValue;
    IndexOfVisitor.prototype.visitInt = indexOfValue;
    IndexOfVisitor.prototype.visitInt8 = indexOfValue;
    IndexOfVisitor.prototype.visitInt16 = indexOfValue;
    IndexOfVisitor.prototype.visitInt32 = indexOfValue;
    IndexOfVisitor.prototype.visitInt64 = indexOfValue;
    IndexOfVisitor.prototype.visitUint8 = indexOfValue;
    IndexOfVisitor.prototype.visitUint16 = indexOfValue;
    IndexOfVisitor.prototype.visitUint32 = indexOfValue;
    IndexOfVisitor.prototype.visitUint64 = indexOfValue;
    IndexOfVisitor.prototype.visitFloat = indexOfValue;
    IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
    IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
    IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
    IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
    IndexOfVisitor.prototype.visitBinary = indexOfValue;
    IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
    IndexOfVisitor.prototype.visitDate = indexOfValue;
    IndexOfVisitor.prototype.visitDateDay = indexOfValue;
    IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
    IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
    IndexOfVisitor.prototype.visitTime = indexOfValue;
    IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
    IndexOfVisitor.prototype.visitDecimal = indexOfValue;
    IndexOfVisitor.prototype.visitList = indexOfValue;
    IndexOfVisitor.prototype.visitStruct = indexOfValue;
    IndexOfVisitor.prototype.visitUnion = indexOfValue;
    IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
    IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
    IndexOfVisitor.prototype.visitDictionary = indexOfValue;
    IndexOfVisitor.prototype.visitInterval = indexOfValue;
    IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
    IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
    IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
    IndexOfVisitor.prototype.visitMap = indexOfValue;
    exports.instance = new IndexOfVisitor();
  }
});

// node_modules/apache-arrow/visitor/iterator.js
var require_iterator = __commonJS({
  "node_modules/apache-arrow/visitor/iterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var enum_1 = require_enum();
    var visitor_1 = require_visitor();
    var bit_1 = require_bit();
    var get_1 = require_get();
    var IteratorVisitor = class extends visitor_1.Visitor {
    };
    exports.IteratorVisitor = IteratorVisitor;
    function nullableIterator(vector) {
      const getFn = get_1.instance.getVisitFn(vector);
      return bit_1.iterateBits(vector.nullBitmap, vector.offset, vector.length, vector, (vec, idx, nullByte, nullBit) => (nullByte & 1 << nullBit) !== 0 ? getFn(vec, idx) : null);
    }
    function vectorIterator(vector) {
      if (vector.nullCount > 0) {
        return nullableIterator(vector);
      }
      const { type, typeId, length } = vector;
      if (vector.stride === 1 && (typeId === enum_1.Type.Timestamp || typeId === enum_1.Type.Int && type.bitWidth !== 64 || typeId === enum_1.Type.Time && type.bitWidth !== 64 || typeId === enum_1.Type.Float && type.precision > 0)) {
        return vector.values.subarray(0, length)[Symbol.iterator]();
      }
      return function* (getFn) {
        for (let index = -1; ++index < length; ) {
          yield getFn(vector, index);
        }
      }(get_1.instance.getVisitFn(vector));
    }
    IteratorVisitor.prototype.visitNull = vectorIterator;
    IteratorVisitor.prototype.visitBool = vectorIterator;
    IteratorVisitor.prototype.visitInt = vectorIterator;
    IteratorVisitor.prototype.visitInt8 = vectorIterator;
    IteratorVisitor.prototype.visitInt16 = vectorIterator;
    IteratorVisitor.prototype.visitInt32 = vectorIterator;
    IteratorVisitor.prototype.visitInt64 = vectorIterator;
    IteratorVisitor.prototype.visitUint8 = vectorIterator;
    IteratorVisitor.prototype.visitUint16 = vectorIterator;
    IteratorVisitor.prototype.visitUint32 = vectorIterator;
    IteratorVisitor.prototype.visitUint64 = vectorIterator;
    IteratorVisitor.prototype.visitFloat = vectorIterator;
    IteratorVisitor.prototype.visitFloat16 = vectorIterator;
    IteratorVisitor.prototype.visitFloat32 = vectorIterator;
    IteratorVisitor.prototype.visitFloat64 = vectorIterator;
    IteratorVisitor.prototype.visitUtf8 = vectorIterator;
    IteratorVisitor.prototype.visitBinary = vectorIterator;
    IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
    IteratorVisitor.prototype.visitDate = vectorIterator;
    IteratorVisitor.prototype.visitDateDay = vectorIterator;
    IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
    IteratorVisitor.prototype.visitTimestamp = vectorIterator;
    IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
    IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
    IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
    IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
    IteratorVisitor.prototype.visitTime = vectorIterator;
    IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
    IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
    IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
    IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
    IteratorVisitor.prototype.visitDecimal = vectorIterator;
    IteratorVisitor.prototype.visitList = vectorIterator;
    IteratorVisitor.prototype.visitStruct = vectorIterator;
    IteratorVisitor.prototype.visitUnion = vectorIterator;
    IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
    IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
    IteratorVisitor.prototype.visitDictionary = vectorIterator;
    IteratorVisitor.prototype.visitInterval = vectorIterator;
    IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
    IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
    IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
    IteratorVisitor.prototype.visitMap = vectorIterator;
    exports.instance = new IteratorVisitor();
  }
});

// node_modules/apache-arrow/visitor/toarray.js
var require_toarray = __commonJS({
  "node_modules/apache-arrow/visitor/toarray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var enum_1 = require_enum();
    var visitor_1 = require_visitor();
    var iterator_1 = require_iterator();
    var ToArrayVisitor = class extends visitor_1.Visitor {
    };
    exports.ToArrayVisitor = ToArrayVisitor;
    function arrayOfVector(vector) {
      const { type, length, stride } = vector;
      switch (type.typeId) {
        case enum_1.Type.Int:
        case enum_1.Type.Float:
        case enum_1.Type.Decimal:
        case enum_1.Type.Time:
        case enum_1.Type.Timestamp:
          return vector.values.subarray(0, length * stride);
      }
      return [...iterator_1.instance.visit(vector)];
    }
    ToArrayVisitor.prototype.visitNull = arrayOfVector;
    ToArrayVisitor.prototype.visitBool = arrayOfVector;
    ToArrayVisitor.prototype.visitInt = arrayOfVector;
    ToArrayVisitor.prototype.visitInt8 = arrayOfVector;
    ToArrayVisitor.prototype.visitInt16 = arrayOfVector;
    ToArrayVisitor.prototype.visitInt32 = arrayOfVector;
    ToArrayVisitor.prototype.visitInt64 = arrayOfVector;
    ToArrayVisitor.prototype.visitUint8 = arrayOfVector;
    ToArrayVisitor.prototype.visitUint16 = arrayOfVector;
    ToArrayVisitor.prototype.visitUint32 = arrayOfVector;
    ToArrayVisitor.prototype.visitUint64 = arrayOfVector;
    ToArrayVisitor.prototype.visitFloat = arrayOfVector;
    ToArrayVisitor.prototype.visitFloat16 = arrayOfVector;
    ToArrayVisitor.prototype.visitFloat32 = arrayOfVector;
    ToArrayVisitor.prototype.visitFloat64 = arrayOfVector;
    ToArrayVisitor.prototype.visitUtf8 = arrayOfVector;
    ToArrayVisitor.prototype.visitBinary = arrayOfVector;
    ToArrayVisitor.prototype.visitFixedSizeBinary = arrayOfVector;
    ToArrayVisitor.prototype.visitDate = arrayOfVector;
    ToArrayVisitor.prototype.visitDateDay = arrayOfVector;
    ToArrayVisitor.prototype.visitDateMillisecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimestamp = arrayOfVector;
    ToArrayVisitor.prototype.visitTimestampSecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimestampMillisecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimestampMicrosecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimestampNanosecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTime = arrayOfVector;
    ToArrayVisitor.prototype.visitTimeSecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimeMillisecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimeMicrosecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimeNanosecond = arrayOfVector;
    ToArrayVisitor.prototype.visitDecimal = arrayOfVector;
    ToArrayVisitor.prototype.visitList = arrayOfVector;
    ToArrayVisitor.prototype.visitStruct = arrayOfVector;
    ToArrayVisitor.prototype.visitUnion = arrayOfVector;
    ToArrayVisitor.prototype.visitDenseUnion = arrayOfVector;
    ToArrayVisitor.prototype.visitSparseUnion = arrayOfVector;
    ToArrayVisitor.prototype.visitDictionary = arrayOfVector;
    ToArrayVisitor.prototype.visitInterval = arrayOfVector;
    ToArrayVisitor.prototype.visitIntervalDayTime = arrayOfVector;
    ToArrayVisitor.prototype.visitIntervalYearMonth = arrayOfVector;
    ToArrayVisitor.prototype.visitFixedSizeList = arrayOfVector;
    ToArrayVisitor.prototype.visitMap = arrayOfVector;
    exports.instance = new ToArrayVisitor();
  }
});

// node_modules/apache-arrow/visitor/bytewidth.js
var require_bytewidth = __commonJS({
  "node_modules/apache-arrow/visitor/bytewidth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var enum_1 = require_enum();
    var sum = (x, y) => x + y;
    var variableWidthColumnErrorMessage = (type) => `Cannot compute the byte width of variable-width column ${type}`;
    var ByteWidthVisitor = class extends visitor_1.Visitor {
      visitNull(____) {
        return 0;
      }
      visitInt(type) {
        return type.bitWidth / 8;
      }
      visitFloat(type) {
        return type.ArrayType.BYTES_PER_ELEMENT;
      }
      visitBinary(type) {
        throw new Error(variableWidthColumnErrorMessage(type));
      }
      visitUtf8(type) {
        throw new Error(variableWidthColumnErrorMessage(type));
      }
      visitBool(____) {
        return 1 / 8;
      }
      visitDecimal(____) {
        return 16;
      }
      visitDate(type) {
        return (type.unit + 1) * 4;
      }
      visitTime(type) {
        return type.bitWidth / 8;
      }
      visitTimestamp(type) {
        return type.unit === enum_1.TimeUnit.SECOND ? 4 : 8;
      }
      visitInterval(type) {
        return (type.unit + 1) * 4;
      }
      visitList(type) {
        throw new Error(variableWidthColumnErrorMessage(type));
      }
      visitStruct(type) {
        return this.visitFields(type.children).reduce(sum, 0);
      }
      visitUnion(type) {
        return this.visitFields(type.children).reduce(sum, 0);
      }
      visitFixedSizeBinary(type) {
        return type.byteWidth;
      }
      visitFixedSizeList(type) {
        return type.listSize * this.visitFields(type.children).reduce(sum, 0);
      }
      visitMap(type) {
        return this.visitFields(type.children).reduce(sum, 0);
      }
      visitDictionary(type) {
        return this.visit(type.indices);
      }
      visitFields(fields) {
        return (fields || []).map((field) => this.visit(field.type));
      }
      visitSchema(schema) {
        return this.visitFields(schema.fields).reduce(sum, 0);
      }
    };
    exports.ByteWidthVisitor = ByteWidthVisitor;
    exports.instance = new ByteWidthVisitor();
  }
});

// node_modules/apache-arrow/visitor/vectorctor.js
var require_vectorctor = __commonJS({
  "node_modules/apache-arrow/visitor/vectorctor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var binary_1 = require_binary2();
    var bool_1 = require_bool2();
    var date_1 = require_date2();
    var decimal_1 = require_decimal2();
    var dictionary_1 = require_dictionary2();
    var fixedsizebinary_1 = require_fixedsizebinary2();
    var fixedsizelist_1 = require_fixedsizelist2();
    var float_1 = require_float2();
    var interval_1 = require_interval2();
    var int_1 = require_int3();
    var list_1 = require_list2();
    var map_1 = require_map2();
    var null_1 = require_null2();
    var struct_1 = require_struct2();
    var timestamp_1 = require_timestamp2();
    var time_1 = require_time2();
    var union_1 = require_union2();
    var utf8_1 = require_utf83();
    var GetVectorConstructor = class extends visitor_1.Visitor {
      visitNull() {
        return null_1.NullVector;
      }
      visitBool() {
        return bool_1.BoolVector;
      }
      visitInt() {
        return int_1.IntVector;
      }
      visitInt8() {
        return int_1.Int8Vector;
      }
      visitInt16() {
        return int_1.Int16Vector;
      }
      visitInt32() {
        return int_1.Int32Vector;
      }
      visitInt64() {
        return int_1.Int64Vector;
      }
      visitUint8() {
        return int_1.Uint8Vector;
      }
      visitUint16() {
        return int_1.Uint16Vector;
      }
      visitUint32() {
        return int_1.Uint32Vector;
      }
      visitUint64() {
        return int_1.Uint64Vector;
      }
      visitFloat() {
        return float_1.FloatVector;
      }
      visitFloat16() {
        return float_1.Float16Vector;
      }
      visitFloat32() {
        return float_1.Float32Vector;
      }
      visitFloat64() {
        return float_1.Float64Vector;
      }
      visitUtf8() {
        return utf8_1.Utf8Vector;
      }
      visitBinary() {
        return binary_1.BinaryVector;
      }
      visitFixedSizeBinary() {
        return fixedsizebinary_1.FixedSizeBinaryVector;
      }
      visitDate() {
        return date_1.DateVector;
      }
      visitDateDay() {
        return date_1.DateDayVector;
      }
      visitDateMillisecond() {
        return date_1.DateMillisecondVector;
      }
      visitTimestamp() {
        return timestamp_1.TimestampVector;
      }
      visitTimestampSecond() {
        return timestamp_1.TimestampSecondVector;
      }
      visitTimestampMillisecond() {
        return timestamp_1.TimestampMillisecondVector;
      }
      visitTimestampMicrosecond() {
        return timestamp_1.TimestampMicrosecondVector;
      }
      visitTimestampNanosecond() {
        return timestamp_1.TimestampNanosecondVector;
      }
      visitTime() {
        return time_1.TimeVector;
      }
      visitTimeSecond() {
        return time_1.TimeSecondVector;
      }
      visitTimeMillisecond() {
        return time_1.TimeMillisecondVector;
      }
      visitTimeMicrosecond() {
        return time_1.TimeMicrosecondVector;
      }
      visitTimeNanosecond() {
        return time_1.TimeNanosecondVector;
      }
      visitDecimal() {
        return decimal_1.DecimalVector;
      }
      visitList() {
        return list_1.ListVector;
      }
      visitStruct() {
        return struct_1.StructVector;
      }
      visitUnion() {
        return union_1.UnionVector;
      }
      visitDenseUnion() {
        return union_1.DenseUnionVector;
      }
      visitSparseUnion() {
        return union_1.SparseUnionVector;
      }
      visitDictionary() {
        return dictionary_1.DictionaryVector;
      }
      visitInterval() {
        return interval_1.IntervalVector;
      }
      visitIntervalDayTime() {
        return interval_1.IntervalDayTimeVector;
      }
      visitIntervalYearMonth() {
        return interval_1.IntervalYearMonthVector;
      }
      visitFixedSizeList() {
        return fixedsizelist_1.FixedSizeListVector;
      }
      visitMap() {
        return map_1.MapVector;
      }
    };
    exports.GetVectorConstructor = GetVectorConstructor;
    exports.instance = new GetVectorConstructor();
  }
});

// node_modules/apache-arrow/vector/index.js
var require_vector3 = __commonJS({
  "node_modules/apache-arrow/vector/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    exports.Vector = vector_1.Vector;
    var base_1 = require_base();
    exports.BaseVector = base_1.BaseVector;
    var binary_1 = require_binary2();
    exports.BinaryVector = binary_1.BinaryVector;
    var bool_1 = require_bool2();
    exports.BoolVector = bool_1.BoolVector;
    var chunked_1 = require_chunked();
    exports.Chunked = chunked_1.Chunked;
    var date_1 = require_date2();
    exports.DateVector = date_1.DateVector;
    exports.DateDayVector = date_1.DateDayVector;
    exports.DateMillisecondVector = date_1.DateMillisecondVector;
    var decimal_1 = require_decimal2();
    exports.DecimalVector = decimal_1.DecimalVector;
    var dictionary_1 = require_dictionary2();
    exports.DictionaryVector = dictionary_1.DictionaryVector;
    var fixedsizebinary_1 = require_fixedsizebinary2();
    exports.FixedSizeBinaryVector = fixedsizebinary_1.FixedSizeBinaryVector;
    var fixedsizelist_1 = require_fixedsizelist2();
    exports.FixedSizeListVector = fixedsizelist_1.FixedSizeListVector;
    var float_1 = require_float2();
    exports.FloatVector = float_1.FloatVector;
    exports.Float16Vector = float_1.Float16Vector;
    exports.Float32Vector = float_1.Float32Vector;
    exports.Float64Vector = float_1.Float64Vector;
    var interval_1 = require_interval2();
    exports.IntervalVector = interval_1.IntervalVector;
    exports.IntervalDayTimeVector = interval_1.IntervalDayTimeVector;
    exports.IntervalYearMonthVector = interval_1.IntervalYearMonthVector;
    var int_1 = require_int3();
    exports.IntVector = int_1.IntVector;
    exports.Int8Vector = int_1.Int8Vector;
    exports.Int16Vector = int_1.Int16Vector;
    exports.Int32Vector = int_1.Int32Vector;
    exports.Int64Vector = int_1.Int64Vector;
    exports.Uint8Vector = int_1.Uint8Vector;
    exports.Uint16Vector = int_1.Uint16Vector;
    exports.Uint32Vector = int_1.Uint32Vector;
    exports.Uint64Vector = int_1.Uint64Vector;
    var list_1 = require_list2();
    exports.ListVector = list_1.ListVector;
    var map_1 = require_map2();
    exports.MapVector = map_1.MapVector;
    var null_1 = require_null2();
    exports.NullVector = null_1.NullVector;
    var struct_1 = require_struct2();
    exports.StructVector = struct_1.StructVector;
    var timestamp_1 = require_timestamp2();
    exports.TimestampVector = timestamp_1.TimestampVector;
    exports.TimestampSecondVector = timestamp_1.TimestampSecondVector;
    exports.TimestampMillisecondVector = timestamp_1.TimestampMillisecondVector;
    exports.TimestampMicrosecondVector = timestamp_1.TimestampMicrosecondVector;
    exports.TimestampNanosecondVector = timestamp_1.TimestampNanosecondVector;
    var time_1 = require_time2();
    exports.TimeVector = time_1.TimeVector;
    exports.TimeSecondVector = time_1.TimeSecondVector;
    exports.TimeMillisecondVector = time_1.TimeMillisecondVector;
    exports.TimeMicrosecondVector = time_1.TimeMicrosecondVector;
    exports.TimeNanosecondVector = time_1.TimeNanosecondVector;
    var union_1 = require_union2();
    exports.UnionVector = union_1.UnionVector;
    exports.DenseUnionVector = union_1.DenseUnionVector;
    exports.SparseUnionVector = union_1.SparseUnionVector;
    var utf8_1 = require_utf83();
    exports.Utf8Vector = utf8_1.Utf8Vector;
    var row_1 = require_row();
    exports.MapRow = row_1.MapRow;
    exports.StructRow = row_1.StructRow;
    var fn = require_fn();
    var enum_1 = require_enum();
    var vector_2 = require_vector();
    var chunked_2 = require_chunked();
    var base_2 = require_base();
    var bit_1 = require_bit();
    var compat_1 = require_compat();
    var builder_1 = require_builder();
    var get_1 = require_get();
    var set_1 = require_set();
    var indexof_1 = require_indexof();
    var toarray_1 = require_toarray();
    var iterator_1 = require_iterator();
    var bytewidth_1 = require_bytewidth();
    var vectorctor_1 = require_vectorctor();
    vector_2.Vector.new = newVector;
    vector_2.Vector.from = vectorFrom;
    function newVector(data, ...args) {
      return new (vectorctor_1.instance.getVisitFn(data)())(data, ...args);
    }
    function vectorFromValuesWithType(newDataType, input) {
      if (compat_1.isIterable(input)) {
        return vector_2.Vector.from({ "nullValues": [null, void 0], type: newDataType(), "values": input });
      } else if (compat_1.isAsyncIterable(input)) {
        return vector_2.Vector.from({ "nullValues": [null, void 0], type: newDataType(), "values": input });
      }
      const { "values": values = [], "type": type = newDataType(), "nullValues": nullValues = [null, void 0] } = { ...input };
      return compat_1.isIterable(values) ? vector_2.Vector.from({ nullValues, ...input, type }) : vector_2.Vector.from({ nullValues, ...input, type });
    }
    exports.vectorFromValuesWithType = vectorFromValuesWithType;
    function vectorFrom(input) {
      const { "values": values = [], ...options } = { "nullValues": [null, void 0], ...input };
      if (compat_1.isIterable(values)) {
        const chunks = [...builder_1.Builder.throughIterable(options)(values)];
        return chunks.length === 1 ? chunks[0] : chunked_2.Chunked.concat(chunks);
      }
      return (async (chunks) => {
        const transform = builder_1.Builder.throughAsyncIterable(options);
        for await (const chunk of transform(values)) {
          chunks.push(chunk);
        }
        return chunks.length === 1 ? chunks[0] : chunked_2.Chunked.concat(chunks);
      })([]);
    }
    base_2.BaseVector.prototype.get = function baseVectorGet(index) {
      return get_1.instance.visit(this, index);
    };
    base_2.BaseVector.prototype.set = function baseVectorSet(index, value) {
      return set_1.instance.visit(this, index, value);
    };
    base_2.BaseVector.prototype.indexOf = function baseVectorIndexOf(value, fromIndex) {
      return indexof_1.instance.visit(this, value, fromIndex);
    };
    base_2.BaseVector.prototype.toArray = function baseVectorToArray() {
      return toarray_1.instance.visit(this);
    };
    base_2.BaseVector.prototype.getByteWidth = function baseVectorGetByteWidth() {
      return bytewidth_1.instance.visit(this.type);
    };
    base_2.BaseVector.prototype[Symbol.iterator] = function baseVectorSymbolIterator() {
      return iterator_1.instance.visit(this);
    };
    base_2.BaseVector.prototype._bindDataAccessors = bindBaseVectorDataAccessors;
    Object.keys(enum_1.Type).map((T) => enum_1.Type[T]).filter((T) => typeof T === "number").filter((typeId) => typeId !== enum_1.Type.NONE).forEach((typeId) => {
      const VectorCtor = vectorctor_1.instance.visit(typeId);
      VectorCtor.prototype["get"] = fn.partial1(get_1.instance.getVisitFn(typeId));
      VectorCtor.prototype["set"] = fn.partial2(set_1.instance.getVisitFn(typeId));
      VectorCtor.prototype["indexOf"] = fn.partial2(indexof_1.instance.getVisitFn(typeId));
      VectorCtor.prototype["toArray"] = fn.partial0(toarray_1.instance.getVisitFn(typeId));
      VectorCtor.prototype["getByteWidth"] = partialType0(bytewidth_1.instance.getVisitFn(typeId));
      VectorCtor.prototype[Symbol.iterator] = fn.partial0(iterator_1.instance.getVisitFn(typeId));
    });
    function partialType0(visit) {
      return function() {
        return visit(this.type);
      };
    }
    function wrapNullableGet(fn2) {
      return function(i) {
        return this.isValid(i) ? fn2.call(this, i) : null;
      };
    }
    function wrapNullableSet(fn2) {
      return function(i, a) {
        if (bit_1.setBool(this.nullBitmap, this.offset + i, !(a === null || a === void 0))) {
          fn2.call(this, i, a);
        }
      };
    }
    function bindBaseVectorDataAccessors() {
      const nullBitmap = this.nullBitmap;
      if (nullBitmap && nullBitmap.byteLength > 0) {
        this.get = wrapNullableGet(this.get);
        this.set = wrapNullableSet(this.set);
      }
    }
  }
});

// node_modules/apache-arrow/table.js
var require_table = __commonJS({
  "node_modules/apache-arrow/table.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var column_1 = require_column();
    var schema_1 = require_schema();
    var recordbatch_1 = require_recordbatch2();
    var reader_1 = require_reader();
    var type_1 = require_type();
    var args_1 = require_args();
    var compat_1 = require_compat();
    var writer_1 = require_writer();
    var recordbatch_2 = require_recordbatch();
    var index_1 = require_vector3();
    var Table2 = class _Table extends index_1.Chunked {
      constructor(...args) {
        let schema = null;
        if (args[0] instanceof schema_1.Schema) {
          schema = args.shift();
        }
        let chunks = args_1.selectArgs(recordbatch_1.RecordBatch, args);
        if (!schema && !(schema = chunks[0] && chunks[0].schema)) {
          throw new TypeError("Table must be initialized with a Schema or at least one RecordBatch");
        }
        chunks[0] || (chunks[0] = new recordbatch_1._InternalEmptyPlaceholderRecordBatch(schema));
        super(new type_1.Struct(schema.fields), chunks);
        this._schema = schema;
        this._chunks = chunks;
      }
      /** @nocollapse */
      static empty(schema = new schema_1.Schema([])) {
        return new _Table(schema, []);
      }
      /** @nocollapse */
      static from(input) {
        if (!input) {
          return _Table.empty();
        }
        if (typeof input === "object") {
          let table = compat_1.isIterable(input["values"]) ? tableFromIterable(input) : compat_1.isAsyncIterable(input["values"]) ? tableFromAsyncIterable(input) : null;
          if (table !== null) {
            return table;
          }
        }
        let reader = reader_1.RecordBatchReader.from(input);
        if (compat_1.isPromise(reader)) {
          return (async () => await _Table.from(await reader))();
        }
        if (reader.isSync() && (reader = reader.open())) {
          return !reader.schema ? _Table.empty() : new _Table(reader.schema, [...reader]);
        }
        return (async (opening) => {
          const reader2 = await opening;
          const schema = reader2.schema;
          const batches = [];
          if (schema) {
            for await (let batch of reader2) {
              batches.push(batch);
            }
            return new _Table(schema, batches);
          }
          return _Table.empty();
        })(reader.open());
      }
      /** @nocollapse */
      static async fromAsync(source) {
        return await _Table.from(source);
      }
      /** @nocollapse */
      static fromStruct(vector) {
        return _Table.new(vector.data.childData, vector.type.children);
      }
      /** @nocollapse */
      static new(...cols) {
        return new _Table(...recordbatch_2.distributeColumnsIntoRecordBatches(args_1.selectColumnArgs(cols)));
      }
      get schema() {
        return this._schema;
      }
      get length() {
        return this._length;
      }
      get chunks() {
        return this._chunks;
      }
      get numCols() {
        return this._numChildren;
      }
      clone(chunks = this._chunks) {
        return new _Table(this._schema, chunks);
      }
      getColumn(name) {
        return this.getColumnAt(this.getColumnIndex(name));
      }
      getColumnAt(index) {
        return this.getChildAt(index);
      }
      getColumnIndex(name) {
        return this._schema.fields.findIndex((f) => f.name === name);
      }
      getChildAt(index) {
        if (index < 0 || index >= this.numChildren) {
          return null;
        }
        let field, child;
        const fields = this._schema.fields;
        const columns = this._children || (this._children = []);
        if (child = columns[index]) {
          return child;
        }
        if (field = fields[index]) {
          const chunks = this._chunks.map((chunk) => chunk.getChildAt(index)).filter((vec) => vec != null);
          if (chunks.length > 0) {
            return columns[index] = new column_1.Column(field, chunks);
          }
        }
        return null;
      }
      // @ts-ignore
      serialize(encoding = "binary", stream = true) {
        const Writer = !stream ? writer_1.RecordBatchFileWriter : writer_1.RecordBatchStreamWriter;
        return Writer.writeAll(this).toUint8Array(true);
      }
      count() {
        return this._length;
      }
      select(...columnNames) {
        const nameToIndex = this._schema.fields.reduce((m, f, i) => m.set(f.name, i), /* @__PURE__ */ new Map());
        return this.selectAt(...columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
      }
      selectAt(...columnIndices) {
        const schema = this._schema.selectAt(...columnIndices);
        return new _Table(schema, this._chunks.map(({ length, data: { childData } }) => {
          return new recordbatch_1.RecordBatch(schema, length, columnIndices.map((i) => childData[i]).filter(Boolean));
        }));
      }
      assign(other) {
        const fields = this._schema.fields;
        const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {
          const [indices2, oldToNew2] = memo;
          const i = fields.findIndex((f) => f.name === f2.name);
          ~i ? oldToNew2[i] = newIdx : indices2.push(newIdx);
          return memo;
        }, [[], []]);
        const schema = this._schema.assign(other.schema);
        const columns = [
          ...fields.map((_f, i, _fs, j = oldToNew[i]) => j === void 0 ? this.getColumnAt(i) : other.getColumnAt(j)),
          ...indices.map((i) => other.getColumnAt(i))
        ].filter(Boolean);
        return new _Table(...recordbatch_2.distributeVectorsIntoRecordBatches(schema, columns));
      }
    };
    exports.Table = Table2;
    function tableFromIterable(input) {
      const { type } = input;
      if (type instanceof type_1.Struct) {
        return Table2.fromStruct(index_1.StructVector.from(input));
      }
      return null;
    }
    function tableFromAsyncIterable(input) {
      const { type } = input;
      if (type instanceof type_1.Struct) {
        return index_1.StructVector.from(input).then((vector) => Table2.fromStruct(vector));
      }
      return null;
    }
  }
});

// node_modules/apache-arrow/recordbatch.js
var require_recordbatch2 = __commonJS({
  "node_modules/apache-arrow/recordbatch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var table_1 = require_table();
    var vector_1 = require_vector();
    var visitor_1 = require_visitor();
    var schema_1 = require_schema();
    var compat_1 = require_compat();
    var chunked_1 = require_chunked();
    var args_1 = require_args();
    var type_1 = require_type();
    var recordbatch_1 = require_recordbatch();
    var index_1 = require_vector3();
    var RecordBatch2 = class _RecordBatch extends index_1.StructVector {
      constructor(...args) {
        let data;
        let schema = args[0];
        let children;
        if (args[1] instanceof data_1.Data) {
          [, data, children] = args;
        } else {
          const fields = schema.fields;
          const [, length, childData] = args;
          data = data_1.Data.Struct(new type_1.Struct(fields), 0, length, 0, null, childData);
        }
        super(data, children);
        this._schema = schema;
      }
      /** @nocollapse */
      static from(options) {
        if (compat_1.isIterable(options["values"])) {
          return table_1.Table.from(options);
        }
        return table_1.Table.from(options);
      }
      /** @nocollapse */
      static new(...args) {
        const [fs, xs] = args_1.selectFieldArgs(args);
        const vs = xs.filter((x) => x instanceof vector_1.Vector);
        return new _RecordBatch(...recordbatch_1.ensureSameLengthData(new schema_1.Schema(fs), vs.map((x) => x.data)));
      }
      clone(data, children = this._children) {
        return new _RecordBatch(this._schema, data, children);
      }
      concat(...others) {
        const schema = this._schema, chunks = chunked_1.Chunked.flatten(this, ...others);
        return new table_1.Table(schema, chunks.map(({ data }) => new _RecordBatch(schema, data)));
      }
      get schema() {
        return this._schema;
      }
      get numCols() {
        return this._schema.fields.length;
      }
      get dictionaries() {
        return this._dictionaries || (this._dictionaries = DictionaryCollector.collect(this));
      }
      select(...columnNames) {
        const nameToIndex = this._schema.fields.reduce((m, f, i) => m.set(f.name, i), /* @__PURE__ */ new Map());
        return this.selectAt(...columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
      }
      selectAt(...columnIndices) {
        const schema = this._schema.selectAt(...columnIndices);
        const childData = columnIndices.map((i) => this.data.childData[i]).filter(Boolean);
        return new _RecordBatch(schema, this.length, childData);
      }
    };
    exports.RecordBatch = RecordBatch2;
    var _InternalEmptyPlaceholderRecordBatch = class extends RecordBatch2 {
      constructor(schema) {
        super(schema, 0, schema.fields.map((f) => data_1.Data.new(f.type, 0, 0, 0)));
      }
    };
    exports._InternalEmptyPlaceholderRecordBatch = _InternalEmptyPlaceholderRecordBatch;
    var DictionaryCollector = class _DictionaryCollector extends visitor_1.Visitor {
      constructor() {
        super(...arguments);
        this.dictionaries = /* @__PURE__ */ new Map();
      }
      static collect(batch) {
        return new _DictionaryCollector().visit(batch.data, new type_1.Struct(batch.schema.fields)).dictionaries;
      }
      visit(data, type) {
        if (type_1.DataType.isDictionary(type)) {
          return this.visitDictionary(data, type);
        } else {
          data.childData.forEach((child, i) => this.visit(child, type.children[i].type));
        }
        return this;
      }
      visitDictionary(data, type) {
        const dictionary = data.dictionary;
        if (dictionary && dictionary.length > 0) {
          this.dictionaries.set(type.id, dictionary);
        }
        return this;
      }
    };
  }
});

// node_modules/apache-arrow/ipc/reader.js
var require_reader = __commonJS({
  "node_modules/apache-arrow/ipc/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var enum_1 = require_enum();
    var file_1 = require_file();
    var adapters_1 = require_adapters();
    var stream_1 = require_stream();
    var file_2 = require_file2();
    var vectorloader_1 = require_vectorloader();
    var recordbatch_1 = require_recordbatch2();
    var interfaces_1 = require_interfaces();
    var message_1 = require_message2();
    var compat_1 = require_compat();
    var RecordBatchReader3 = class _RecordBatchReader extends interfaces_1.ReadableInterop {
      constructor(impl) {
        super();
        this._impl = impl;
      }
      get closed() {
        return this._impl.closed;
      }
      get schema() {
        return this._impl.schema;
      }
      get autoDestroy() {
        return this._impl.autoDestroy;
      }
      get dictionaries() {
        return this._impl.dictionaries;
      }
      get numDictionaries() {
        return this._impl.numDictionaries;
      }
      get numRecordBatches() {
        return this._impl.numRecordBatches;
      }
      get footer() {
        return this._impl.isFile() ? this._impl.footer : null;
      }
      isSync() {
        return this._impl.isSync();
      }
      isAsync() {
        return this._impl.isAsync();
      }
      isFile() {
        return this._impl.isFile();
      }
      isStream() {
        return this._impl.isStream();
      }
      next() {
        return this._impl.next();
      }
      throw(value) {
        return this._impl.throw(value);
      }
      return(value) {
        return this._impl.return(value);
      }
      cancel() {
        return this._impl.cancel();
      }
      reset(schema) {
        this._impl.reset(schema);
        this._DOMStream = void 0;
        this._nodeStream = void 0;
        return this;
      }
      open(options) {
        const opening = this._impl.open(options);
        return compat_1.isPromise(opening) ? opening.then(() => this) : this;
      }
      readRecordBatch(index) {
        return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
      }
      [Symbol.iterator]() {
        return this._impl[Symbol.iterator]();
      }
      [Symbol.asyncIterator]() {
        return this._impl[Symbol.asyncIterator]();
      }
      toDOMStream() {
        return adapters_1.default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
      }
      toNodeStream() {
        return adapters_1.default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });
      }
      /** @nocollapse */
      // @ts-ignore
      static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
      }
      /** @nocollapse */
      static throughDOM(writableStrategy, readableStrategy) {
        throw new Error(`"throughDOM" not available in this environment`);
      }
      /** @nocollapse */
      static from(source) {
        if (source instanceof _RecordBatchReader) {
          return source;
        } else if (compat_1.isArrowJSON(source)) {
          return fromArrowJSON(source);
        } else if (compat_1.isFileHandle(source)) {
          return fromFileHandle(source);
        } else if (compat_1.isPromise(source)) {
          return (async () => await _RecordBatchReader.from(await source))();
        } else if (compat_1.isFetchResponse(source) || compat_1.isReadableDOMStream(source) || compat_1.isReadableNodeStream(source) || compat_1.isAsyncIterable(source)) {
          return fromAsyncByteStream(new stream_1.AsyncByteStream(source));
        }
        return fromByteStream(new stream_1.ByteStream(source));
      }
      /** @nocollapse */
      static readAll(source) {
        if (source instanceof _RecordBatchReader) {
          return source.isSync() ? readAllSync(source) : readAllAsync(source);
        } else if (compat_1.isArrowJSON(source) || ArrayBuffer.isView(source) || compat_1.isIterable(source) || compat_1.isIteratorResult(source)) {
          return readAllSync(source);
        }
        return readAllAsync(source);
      }
    };
    exports.RecordBatchReader = RecordBatchReader3;
    var RecordBatchStreamReader2 = class extends RecordBatchReader3 {
      constructor(_impl) {
        super(_impl);
        this._impl = _impl;
      }
      [Symbol.iterator]() {
        return this._impl[Symbol.iterator]();
      }
      async *[Symbol.asyncIterator]() {
        yield* this[Symbol.iterator]();
      }
    };
    exports.RecordBatchStreamReader = RecordBatchStreamReader2;
    var AsyncRecordBatchStreamReader2 = class extends RecordBatchReader3 {
      constructor(_impl) {
        super(_impl);
        this._impl = _impl;
      }
      [Symbol.iterator]() {
        throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
      }
      [Symbol.asyncIterator]() {
        return this._impl[Symbol.asyncIterator]();
      }
    };
    exports.AsyncRecordBatchStreamReader = AsyncRecordBatchStreamReader2;
    var RecordBatchFileReader2 = class extends RecordBatchStreamReader2 {
      constructor(_impl) {
        super(_impl);
        this._impl = _impl;
      }
    };
    exports.RecordBatchFileReader = RecordBatchFileReader2;
    var AsyncRecordBatchFileReader2 = class extends AsyncRecordBatchStreamReader2 {
      constructor(_impl) {
        super(_impl);
        this._impl = _impl;
      }
    };
    exports.AsyncRecordBatchFileReader = AsyncRecordBatchFileReader2;
    var RecordBatchReaderImpl = class {
      constructor(dictionaries = /* @__PURE__ */ new Map()) {
        this.closed = false;
        this.autoDestroy = true;
        this._dictionaryIndex = 0;
        this._recordBatchIndex = 0;
        this.dictionaries = dictionaries;
      }
      get numDictionaries() {
        return this._dictionaryIndex;
      }
      get numRecordBatches() {
        return this._recordBatchIndex;
      }
      isSync() {
        return false;
      }
      isAsync() {
        return false;
      }
      isFile() {
        return false;
      }
      isStream() {
        return false;
      }
      reset(schema) {
        this._dictionaryIndex = 0;
        this._recordBatchIndex = 0;
        this.schema = schema;
        this.dictionaries = /* @__PURE__ */ new Map();
        return this;
      }
      _loadRecordBatch(header, body) {
        return new recordbatch_1.RecordBatch(this.schema, header.length, this._loadVectors(header, body, this.schema.fields));
      }
      _loadDictionaryBatch(header, body) {
        const { id, isDelta, data } = header;
        const { dictionaries, schema } = this;
        const dictionary = dictionaries.get(id);
        if (isDelta || !dictionary) {
          const type = schema.dictionaries.get(id);
          return dictionary && isDelta ? dictionary.concat(vector_1.Vector.new(this._loadVectors(data, body, [type])[0])) : vector_1.Vector.new(this._loadVectors(data, body, [type])[0]);
        }
        return dictionary;
      }
      _loadVectors(header, body, types) {
        return new vectorloader_1.VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);
      }
    };
    var RecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
      constructor(source, dictionaries) {
        super(dictionaries);
        this._reader = !compat_1.isArrowJSON(source) ? new message_1.MessageReader(this._handle = source) : new message_1.JSONMessageReader(this._handle = source);
      }
      isSync() {
        return true;
      }
      isStream() {
        return true;
      }
      [Symbol.iterator]() {
        return this;
      }
      cancel() {
        if (!this.closed && (this.closed = true)) {
          this.reset()._reader.return();
          this._reader = null;
          this.dictionaries = null;
        }
      }
      open(options) {
        if (!this.closed) {
          this.autoDestroy = shouldAutoDestroy(this, options);
          if (!(this.schema || (this.schema = this._reader.readSchema()))) {
            this.cancel();
          }
        }
        return this;
      }
      throw(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return this.reset()._reader.throw(value);
        }
        return interfaces_1.ITERATOR_DONE;
      }
      return(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return this.reset()._reader.return(value);
        }
        return interfaces_1.ITERATOR_DONE;
      }
      next() {
        if (this.closed) {
          return interfaces_1.ITERATOR_DONE;
        }
        let message, { _reader: reader } = this;
        while (message = this._readNextMessageAndValidate()) {
          if (message.isSchema()) {
            this.reset(message.header());
          } else if (message.isRecordBatch()) {
            this._recordBatchIndex++;
            const header = message.header();
            const buffer = reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return { done: false, value: recordBatch };
          } else if (message.isDictionaryBatch()) {
            this._dictionaryIndex++;
            const header = message.header();
            const buffer = reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
        if (this.schema && this._recordBatchIndex === 0) {
          this._recordBatchIndex++;
          return { done: false, value: new recordbatch_1._InternalEmptyPlaceholderRecordBatch(this.schema) };
        }
        return this.return();
      }
      _readNextMessageAndValidate(type) {
        return this._reader.readMessage(type);
      }
    };
    var AsyncRecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
      constructor(source, dictionaries) {
        super(dictionaries);
        this._reader = new message_1.AsyncMessageReader(this._handle = source);
      }
      isAsync() {
        return true;
      }
      isStream() {
        return true;
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      async cancel() {
        if (!this.closed && (this.closed = true)) {
          await this.reset()._reader.return();
          this._reader = null;
          this.dictionaries = null;
        }
      }
      async open(options) {
        if (!this.closed) {
          this.autoDestroy = shouldAutoDestroy(this, options);
          if (!(this.schema || (this.schema = await this._reader.readSchema()))) {
            await this.cancel();
          }
        }
        return this;
      }
      async throw(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return await this.reset()._reader.throw(value);
        }
        return interfaces_1.ITERATOR_DONE;
      }
      async return(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return await this.reset()._reader.return(value);
        }
        return interfaces_1.ITERATOR_DONE;
      }
      async next() {
        if (this.closed) {
          return interfaces_1.ITERATOR_DONE;
        }
        let message, { _reader: reader } = this;
        while (message = await this._readNextMessageAndValidate()) {
          if (message.isSchema()) {
            await this.reset(message.header());
          } else if (message.isRecordBatch()) {
            this._recordBatchIndex++;
            const header = message.header();
            const buffer = await reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return { done: false, value: recordBatch };
          } else if (message.isDictionaryBatch()) {
            this._dictionaryIndex++;
            const header = message.header();
            const buffer = await reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
        if (this.schema && this._recordBatchIndex === 0) {
          this._recordBatchIndex++;
          return { done: false, value: new recordbatch_1._InternalEmptyPlaceholderRecordBatch(this.schema) };
        }
        return await this.return();
      }
      async _readNextMessageAndValidate(type) {
        return await this._reader.readMessage(type);
      }
    };
    var RecordBatchFileReaderImpl = class extends RecordBatchStreamReaderImpl {
      constructor(source, dictionaries) {
        super(source instanceof file_2.RandomAccessFile ? source : new file_2.RandomAccessFile(source), dictionaries);
      }
      get footer() {
        return this._footer;
      }
      get numDictionaries() {
        return this._footer ? this._footer.numDictionaries : 0;
      }
      get numRecordBatches() {
        return this._footer ? this._footer.numRecordBatches : 0;
      }
      isSync() {
        return true;
      }
      isFile() {
        return true;
      }
      open(options) {
        if (!this.closed && !this._footer) {
          this.schema = (this._footer = this._readFooter()).schema;
          for (const block of this._footer.dictionaryBatches()) {
            block && this._readDictionaryBatch(this._dictionaryIndex++);
          }
        }
        return super.open(options);
      }
      readRecordBatch(index) {
        if (this.closed) {
          return null;
        }
        if (!this._footer) {
          this.open();
        }
        const block = this._footer && this._footer.getRecordBatch(index);
        if (block && this._handle.seek(block.offset)) {
          const message = this._reader.readMessage(enum_1.MessageHeader.RecordBatch);
          if (message && message.isRecordBatch()) {
            const header = message.header();
            const buffer = this._reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return recordBatch;
          }
        }
        return null;
      }
      _readDictionaryBatch(index) {
        const block = this._footer && this._footer.getDictionaryBatch(index);
        if (block && this._handle.seek(block.offset)) {
          const message = this._reader.readMessage(enum_1.MessageHeader.DictionaryBatch);
          if (message && message.isDictionaryBatch()) {
            const header = message.header();
            const buffer = this._reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
      }
      _readFooter() {
        const { _handle } = this;
        const offset = _handle.size - message_1.magicAndPadding;
        const length = _handle.readInt32(offset);
        const buffer = _handle.readAt(offset - length, length);
        return file_1.Footer.decode(buffer);
      }
      _readNextMessageAndValidate(type) {
        if (!this._footer) {
          this.open();
        }
        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
          const block = this._footer && this._footer.getRecordBatch(this._recordBatchIndex);
          if (block && this._handle.seek(block.offset)) {
            return this._reader.readMessage(type);
          }
        }
        return null;
      }
    };
    var AsyncRecordBatchFileReaderImpl = class extends AsyncRecordBatchStreamReaderImpl {
      constructor(source, ...rest) {
        const byteLength = typeof rest[0] !== "number" ? rest.shift() : void 0;
        const dictionaries = rest[0] instanceof Map ? rest.shift() : void 0;
        super(source instanceof file_2.AsyncRandomAccessFile ? source : new file_2.AsyncRandomAccessFile(source, byteLength), dictionaries);
      }
      get footer() {
        return this._footer;
      }
      get numDictionaries() {
        return this._footer ? this._footer.numDictionaries : 0;
      }
      get numRecordBatches() {
        return this._footer ? this._footer.numRecordBatches : 0;
      }
      isFile() {
        return true;
      }
      isAsync() {
        return true;
      }
      async open(options) {
        if (!this.closed && !this._footer) {
          this.schema = (this._footer = await this._readFooter()).schema;
          for (const block of this._footer.dictionaryBatches()) {
            block && await this._readDictionaryBatch(this._dictionaryIndex++);
          }
        }
        return await super.open(options);
      }
      async readRecordBatch(index) {
        if (this.closed) {
          return null;
        }
        if (!this._footer) {
          await this.open();
        }
        const block = this._footer && this._footer.getRecordBatch(index);
        if (block && await this._handle.seek(block.offset)) {
          const message = await this._reader.readMessage(enum_1.MessageHeader.RecordBatch);
          if (message && message.isRecordBatch()) {
            const header = message.header();
            const buffer = await this._reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return recordBatch;
          }
        }
        return null;
      }
      async _readDictionaryBatch(index) {
        const block = this._footer && this._footer.getDictionaryBatch(index);
        if (block && await this._handle.seek(block.offset)) {
          const message = await this._reader.readMessage(enum_1.MessageHeader.DictionaryBatch);
          if (message && message.isDictionaryBatch()) {
            const header = message.header();
            const buffer = await this._reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
      }
      async _readFooter() {
        const { _handle } = this;
        _handle._pending && await _handle._pending;
        const offset = _handle.size - message_1.magicAndPadding;
        const length = await _handle.readInt32(offset);
        const buffer = await _handle.readAt(offset - length, length);
        return file_1.Footer.decode(buffer);
      }
      async _readNextMessageAndValidate(type) {
        if (!this._footer) {
          await this.open();
        }
        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
          const block = this._footer.getRecordBatch(this._recordBatchIndex);
          if (block && await this._handle.seek(block.offset)) {
            return await this._reader.readMessage(type);
          }
        }
        return null;
      }
    };
    var RecordBatchJSONReaderImpl = class extends RecordBatchStreamReaderImpl {
      constructor(source, dictionaries) {
        super(source, dictionaries);
      }
      _loadVectors(header, body, types) {
        return new vectorloader_1.JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);
      }
    };
    function shouldAutoDestroy(self, options) {
      return options && typeof options["autoDestroy"] === "boolean" ? options["autoDestroy"] : self["autoDestroy"];
    }
    function* readAllSync(source) {
      const reader = RecordBatchReader3.from(source);
      try {
        if (!reader.open({ autoDestroy: false }).closed) {
          do {
            yield reader;
          } while (!reader.reset().open().closed);
        }
      } finally {
        reader.cancel();
      }
    }
    async function* readAllAsync(source) {
      const reader = await RecordBatchReader3.from(source);
      try {
        if (!(await reader.open({ autoDestroy: false })).closed) {
          do {
            yield reader;
          } while (!(await reader.reset().open()).closed);
        }
      } finally {
        await reader.cancel();
      }
    }
    function fromArrowJSON(source) {
      return new RecordBatchStreamReader2(new RecordBatchJSONReaderImpl(source));
    }
    function fromByteStream(source) {
      const bytes = source.peek(message_1.magicLength + 7 & ~7);
      return bytes && bytes.byteLength >= 4 ? !message_1.checkForMagicArrowString(bytes) ? new RecordBatchStreamReader2(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader2(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader2(new RecordBatchStreamReaderImpl(function* () {
      }()));
    }
    async function fromAsyncByteStream(source) {
      const bytes = await source.peek(message_1.magicLength + 7 & ~7);
      return bytes && bytes.byteLength >= 4 ? !message_1.checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader2(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader2(new RecordBatchFileReaderImpl(await source.read())) : new AsyncRecordBatchStreamReader2(new AsyncRecordBatchStreamReaderImpl(async function* () {
      }()));
    }
    async function fromFileHandle(source) {
      const { size } = await source.stat();
      const file = new file_2.AsyncRandomAccessFile(source, size);
      if (size >= message_1.magicX2AndPadding) {
        if (message_1.checkForMagicArrowString(await file.readAt(0, message_1.magicLength + 7 & ~7))) {
          return new AsyncRecordBatchFileReader2(new AsyncRecordBatchFileReaderImpl(file));
        }
      }
      return new AsyncRecordBatchStreamReader2(new AsyncRecordBatchStreamReaderImpl(file));
    }
  }
});

// node_modules/apache-arrow/io/whatwg/iterable.js
var require_iterable = __commonJS({
  "node_modules/apache-arrow/io/whatwg/iterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    var compat_1 = require_compat();
    function toDOMStream2(source, options) {
      if (compat_1.isAsyncIterable(source)) {
        return asyncIterableAsReadableDOMStream(source, options);
      }
      if (compat_1.isIterable(source)) {
        return iterableAsReadableDOMStream(source, options);
      }
      throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
    }
    exports.toDOMStream = toDOMStream2;
    function iterableAsReadableDOMStream(source, options) {
      let it = null;
      const bm = options && options.type === "bytes" || false;
      const hwm = options && options.highWaterMark || 2 ** 24;
      return new ReadableStream({
        ...options,
        start(controller) {
          next(controller, it || (it = source[Symbol.iterator]()));
        },
        pull(controller) {
          it ? next(controller, it) : controller.close();
        },
        cancel() {
          (it && (it.return && it.return()) || true) && (it = null);
        }
      }, { highWaterMark: bm ? hwm : void 0, ...options });
      function next(controller, it2) {
        let buf;
        let r = null;
        let size = controller.desiredSize || null;
        while (!(r = it2.next(bm ? size : null)).done) {
          if (ArrayBuffer.isView(r.value) && (buf = buffer_1.toUint8Array(r.value))) {
            size != null && bm && (size = size - buf.byteLength + 1);
            r.value = buf;
          }
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      }
    }
    function asyncIterableAsReadableDOMStream(source, options) {
      let it = null;
      const bm = options && options.type === "bytes" || false;
      const hwm = options && options.highWaterMark || 2 ** 24;
      return new ReadableStream({
        ...options,
        async start(controller) {
          await next(controller, it || (it = source[Symbol.asyncIterator]()));
        },
        async pull(controller) {
          it ? await next(controller, it) : controller.close();
        },
        async cancel() {
          (it && (it.return && await it.return()) || true) && (it = null);
        }
      }, { highWaterMark: bm ? hwm : void 0, ...options });
      async function next(controller, it2) {
        let buf;
        let r = null;
        let size = controller.desiredSize || null;
        while (!(r = await it2.next(bm ? size : null)).done) {
          if (ArrayBuffer.isView(r.value) && (buf = buffer_1.toUint8Array(r.value))) {
            size != null && bm && (size = size - buf.byteLength + 1);
            r.value = buf;
          }
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      }
    }
  }
});

// node_modules/apache-arrow/io/whatwg/builder.js
var require_builder3 = __commonJS({
  "node_modules/apache-arrow/io/whatwg/builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_builder2();
    function builderThroughDOMStream2(options) {
      return new BuilderTransform(options);
    }
    exports.builderThroughDOMStream = builderThroughDOMStream2;
    var BuilderTransform = class {
      constructor(options) {
        this._numChunks = 0;
        this._finished = false;
        this._bufferedSize = 0;
        const { ["readableStrategy"]: readableStrategy, ["writableStrategy"]: writableStrategy, ["queueingStrategy"]: queueingStrategy = "count", ...builderOptions } = options;
        this._controller = null;
        this._builder = index_1.Builder.new(builderOptions);
        this._getSize = queueingStrategy !== "bytes" ? chunkLength : chunkByteLength;
        const { ["highWaterMark"]: readableHighWaterMark = queueingStrategy === "bytes" ? 2 ** 14 : 1e3 } = { ...readableStrategy };
        const { ["highWaterMark"]: writableHighWaterMark = queueingStrategy === "bytes" ? 2 ** 14 : 1e3 } = { ...writableStrategy };
        this["readable"] = new ReadableStream({
          ["cancel"]: () => {
            this._builder.clear();
          },
          ["pull"]: (c) => {
            this._maybeFlush(this._builder, this._controller = c);
          },
          ["start"]: (c) => {
            this._maybeFlush(this._builder, this._controller = c);
          }
        }, {
          "highWaterMark": readableHighWaterMark,
          "size": queueingStrategy !== "bytes" ? chunkLength : chunkByteLength
        });
        this["writable"] = new WritableStream({
          ["abort"]: () => {
            this._builder.clear();
          },
          ["write"]: () => {
            this._maybeFlush(this._builder, this._controller);
          },
          ["close"]: () => {
            this._maybeFlush(this._builder.finish(), this._controller);
          }
        }, {
          "highWaterMark": writableHighWaterMark,
          "size": (value) => this._writeValueAndReturnChunkSize(value)
        });
      }
      _writeValueAndReturnChunkSize(value) {
        const bufferedSize = this._bufferedSize;
        this._bufferedSize = this._getSize(this._builder.append(value));
        return this._bufferedSize - bufferedSize;
      }
      _maybeFlush(builder, controller) {
        if (controller === null) {
          return;
        }
        if (this._bufferedSize >= controller.desiredSize) {
          ++this._numChunks && this._enqueue(controller, builder.toVector());
        }
        if (builder.finished) {
          if (builder.length > 0 || this._numChunks === 0) {
            ++this._numChunks && this._enqueue(controller, builder.toVector());
          }
          if (!this._finished && (this._finished = true)) {
            this._enqueue(controller, null);
          }
        }
      }
      _enqueue(controller, chunk) {
        this._bufferedSize = 0;
        this._controller = null;
        chunk === null ? controller.close() : controller.enqueue(chunk);
      }
    };
    exports.BuilderTransform = BuilderTransform;
    var chunkLength = (chunk) => chunk.length;
    var chunkByteLength = (chunk) => chunk.byteLength;
  }
});

// node_modules/apache-arrow/io/whatwg/reader.js
var require_reader2 = __commonJS({
  "node_modules/apache-arrow/io/whatwg/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require_stream();
    var reader_1 = require_reader();
    function recordBatchReaderThroughDOMStream2(writableStrategy, readableStrategy) {
      const queue = new stream_1.AsyncByteQueue();
      let reader = null;
      const readable = new ReadableStream({
        async cancel() {
          await queue.close();
        },
        async start(controller) {
          await next(controller, reader || (reader = await open()));
        },
        async pull(controller) {
          reader ? await next(controller, reader) : controller.close();
        }
      });
      return { writable: new WritableStream(queue, { "highWaterMark": 2 ** 14, ...writableStrategy }), readable };
      async function open() {
        return await (await reader_1.RecordBatchReader.from(queue)).open(readableStrategy);
      }
      async function next(controller, reader2) {
        let size = controller.desiredSize;
        let r = null;
        while (!(r = await reader2.next()).done) {
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      }
    }
    exports.recordBatchReaderThroughDOMStream = recordBatchReaderThroughDOMStream2;
  }
});

// node_modules/apache-arrow/io/whatwg/writer.js
var require_writer2 = __commonJS({
  "node_modules/apache-arrow/io/whatwg/writer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require_stream();
    function recordBatchWriterThroughDOMStream2(writableStrategy, readableStrategy) {
      const writer = new this(writableStrategy);
      const reader = new stream_1.AsyncByteStream(writer);
      const readable = new ReadableStream({
        type: "bytes",
        async cancel() {
          await reader.cancel();
        },
        async pull(controller) {
          await next(controller);
        },
        async start(controller) {
          await next(controller);
        }
      }, { "highWaterMark": 2 ** 14, ...readableStrategy });
      return { writable: new WritableStream(writer, writableStrategy), readable };
      async function next(controller) {
        let buf = null;
        let size = controller.desiredSize;
        while (buf = await reader.read(size || null)) {
          controller.enqueue(buf);
          if (size != null && (size -= buf.byteLength) <= 0) {
            return;
          }
        }
        controller.close();
      }
    }
    exports.recordBatchWriterThroughDOMStream = recordBatchWriterThroughDOMStream2;
  }
});

// node_modules/apache-arrow/compute/predicate.js
var require_predicate = __commonJS({
  "node_modules/apache-arrow/compute/predicate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dictionary_1 = require_dictionary2();
    var Value = class _Value {
      eq(other) {
        if (!(other instanceof _Value)) {
          other = new Literal(other);
        }
        return new Equals(this, other);
      }
      le(other) {
        if (!(other instanceof _Value)) {
          other = new Literal(other);
        }
        return new LTeq(this, other);
      }
      ge(other) {
        if (!(other instanceof _Value)) {
          other = new Literal(other);
        }
        return new GTeq(this, other);
      }
      lt(other) {
        return new Not(this.ge(other));
      }
      gt(other) {
        return new Not(this.le(other));
      }
      ne(other) {
        return new Not(this.eq(other));
      }
    };
    exports.Value = Value;
    var Literal = class extends Value {
      constructor(v) {
        super();
        this.v = v;
      }
    };
    exports.Literal = Literal;
    var Col = class extends Value {
      constructor(name) {
        super();
        this.name = name;
      }
      bind(batch) {
        if (!this.colidx) {
          this.colidx = -1;
          const fields = batch.schema.fields;
          for (let idx = -1; ++idx < fields.length; ) {
            if (fields[idx].name === this.name) {
              this.colidx = idx;
              break;
            }
          }
          if (this.colidx < 0) {
            throw new Error(`Failed to bind Col "${this.name}"`);
          }
        }
        const vec = this.vector = batch.getChildAt(this.colidx);
        return (idx) => vec.get(idx);
      }
    };
    exports.Col = Col;
    var Predicate = class {
      and(...expr) {
        return new And(this, ...expr);
      }
      or(...expr) {
        return new Or(this, ...expr);
      }
      not() {
        return new Not(this);
      }
    };
    exports.Predicate = Predicate;
    var ComparisonPredicate = class extends Predicate {
      constructor(left, right) {
        super();
        this.left = left;
        this.right = right;
      }
      bind(batch) {
        if (this.left instanceof Literal) {
          if (this.right instanceof Literal) {
            return this._bindLitLit(batch, this.left, this.right);
          } else {
            return this._bindLitCol(batch, this.left, this.right);
          }
        } else {
          if (this.right instanceof Literal) {
            return this._bindColLit(batch, this.left, this.right);
          } else {
            return this._bindColCol(batch, this.left, this.right);
          }
        }
      }
    };
    exports.ComparisonPredicate = ComparisonPredicate;
    var CombinationPredicate = class extends Predicate {
      constructor(...children) {
        super();
        this.children = children;
      }
    };
    exports.CombinationPredicate = CombinationPredicate;
    CombinationPredicate.prototype.children = Object.freeze([]);
    var And = class _And extends CombinationPredicate {
      constructor(...children) {
        children = children.reduce((accum, p) => {
          return accum.concat(p instanceof _And ? p.children : p);
        }, []);
        super(...children);
      }
      bind(batch) {
        const bound = this.children.map((p) => p.bind(batch));
        return (idx, batch2) => bound.every((p) => p(idx, batch2));
      }
    };
    exports.And = And;
    var Or = class _Or extends CombinationPredicate {
      constructor(...children) {
        children = children.reduce((accum, p) => {
          return accum.concat(p instanceof _Or ? p.children : p);
        }, []);
        super(...children);
      }
      bind(batch) {
        const bound = this.children.map((p) => p.bind(batch));
        return (idx, batch2) => bound.some((p) => p(idx, batch2));
      }
    };
    exports.Or = Or;
    var Equals = class extends ComparisonPredicate {
      _bindLitLit(_batch, left, right) {
        const rtrn = left.v == right.v;
        return () => rtrn;
      }
      _bindColCol(batch, left, right) {
        const left_func = left.bind(batch);
        const right_func = right.bind(batch);
        return (idx, batch2) => left_func(idx, batch2) == right_func(idx, batch2);
      }
      _bindColLit(batch, col2, lit2) {
        const col_func = col2.bind(batch);
        if (col2.vector instanceof dictionary_1.DictionaryVector) {
          let key;
          const vector = col2.vector;
          if (vector.dictionary !== this.lastDictionary) {
            key = vector.reverseLookup(lit2.v);
            this.lastDictionary = vector.dictionary;
            this.lastKey = key;
          } else {
            key = this.lastKey;
          }
          if (key === -1) {
            return () => false;
          } else {
            return (idx) => {
              return vector.getKey(idx) === key;
            };
          }
        } else {
          return (idx, cols) => col_func(idx, cols) == lit2.v;
        }
      }
      _bindLitCol(batch, lit2, col2) {
        return this._bindColLit(batch, col2, lit2);
      }
    };
    exports.Equals = Equals;
    var LTeq = class extends ComparisonPredicate {
      _bindLitLit(_batch, left, right) {
        const rtrn = left.v <= right.v;
        return () => rtrn;
      }
      _bindColCol(batch, left, right) {
        const left_func = left.bind(batch);
        const right_func = right.bind(batch);
        return (idx, cols) => left_func(idx, cols) <= right_func(idx, cols);
      }
      _bindColLit(batch, col2, lit2) {
        const col_func = col2.bind(batch);
        return (idx, cols) => col_func(idx, cols) <= lit2.v;
      }
      _bindLitCol(batch, lit2, col2) {
        const col_func = col2.bind(batch);
        return (idx, cols) => lit2.v <= col_func(idx, cols);
      }
    };
    exports.LTeq = LTeq;
    var GTeq = class extends ComparisonPredicate {
      _bindLitLit(_batch, left, right) {
        const rtrn = left.v >= right.v;
        return () => rtrn;
      }
      _bindColCol(batch, left, right) {
        const left_func = left.bind(batch);
        const right_func = right.bind(batch);
        return (idx, cols) => left_func(idx, cols) >= right_func(idx, cols);
      }
      _bindColLit(batch, col2, lit2) {
        const col_func = col2.bind(batch);
        return (idx, cols) => col_func(idx, cols) >= lit2.v;
      }
      _bindLitCol(batch, lit2, col2) {
        const col_func = col2.bind(batch);
        return (idx, cols) => lit2.v >= col_func(idx, cols);
      }
    };
    exports.GTeq = GTeq;
    var Not = class extends Predicate {
      constructor(child) {
        super();
        this.child = child;
      }
      bind(batch) {
        const func = this.child.bind(batch);
        return (idx, batch2) => !func(idx, batch2);
      }
    };
    exports.Not = Not;
    var CustomPredicate = class extends Predicate {
      constructor(next, bind_) {
        super();
        this.next = next;
        this.bind_ = bind_;
      }
      bind(batch) {
        this.bind_(batch);
        return this.next;
      }
    };
    exports.CustomPredicate = CustomPredicate;
    function lit(v) {
      return new Literal(v);
    }
    exports.lit = lit;
    function col(n) {
      return new Col(n);
    }
    exports.col = col;
    function and(...p) {
      return new And(...p);
    }
    exports.and = and;
    function or(...p) {
      return new Or(...p);
    }
    exports.or = or;
    function custom(next, bind) {
      return new CustomPredicate(next, bind);
    }
    exports.custom = custom;
  }
});

// node_modules/apache-arrow/compute/dataframe.js
var require_dataframe = __commonJS({
  "node_modules/apache-arrow/compute/dataframe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var table_1 = require_table();
    var int_1 = require_int3();
    var schema_1 = require_schema();
    var predicate_1 = require_predicate();
    var recordbatch_1 = require_recordbatch2();
    var type_1 = require_type();
    table_1.Table.prototype.countBy = function(name) {
      return new DataFrame2(this.chunks).countBy(name);
    };
    table_1.Table.prototype.scan = function(next, bind) {
      return new DataFrame2(this.chunks).scan(next, bind);
    };
    table_1.Table.prototype.scanReverse = function(next, bind) {
      return new DataFrame2(this.chunks).scanReverse(next, bind);
    };
    table_1.Table.prototype.filter = function(predicate2) {
      return new DataFrame2(this.chunks).filter(predicate2);
    };
    var DataFrame2 = class extends table_1.Table {
      filter(predicate2) {
        return new FilteredDataFrame2(this.chunks, predicate2);
      }
      scan(next, bind) {
        const batches = this.chunks, numBatches = batches.length;
        for (let batchIndex = -1; ++batchIndex < numBatches; ) {
          const batch = batches[batchIndex];
          if (bind) {
            bind(batch);
          }
          for (let index = -1, numRows = batch.length; ++index < numRows; ) {
            next(index, batch);
          }
        }
      }
      scanReverse(next, bind) {
        const batches = this.chunks, numBatches = batches.length;
        for (let batchIndex = numBatches; --batchIndex >= 0; ) {
          const batch = batches[batchIndex];
          if (bind) {
            bind(batch);
          }
          for (let index = batch.length; --index >= 0; ) {
            next(index, batch);
          }
        }
      }
      countBy(name) {
        const batches = this.chunks, numBatches = batches.length;
        const count_by = typeof name === "string" ? new predicate_1.Col(name) : name;
        count_by.bind(batches[numBatches - 1]);
        const vector = count_by.vector;
        if (!type_1.DataType.isDictionary(vector.type)) {
          throw new Error("countBy currently only supports dictionary-encoded columns");
        }
        const countByteLength = Math.ceil(Math.log(vector.length) / Math.log(256));
        const CountsArrayType = countByteLength == 4 ? Uint32Array : countByteLength >= 2 ? Uint16Array : Uint8Array;
        const counts = new CountsArrayType(vector.dictionary.length);
        for (let batchIndex = -1; ++batchIndex < numBatches; ) {
          const batch = batches[batchIndex];
          count_by.bind(batch);
          const keys = count_by.vector.indices;
          for (let index = -1, numRows = batch.length; ++index < numRows; ) {
            let key = keys.get(index);
            if (key !== null) {
              counts[key]++;
            }
          }
        }
        return new CountByResult2(vector.dictionary, int_1.IntVector.from(counts));
      }
    };
    exports.DataFrame = DataFrame2;
    var CountByResult2 = class extends table_1.Table {
      constructor(values, counts) {
        const schema = new schema_1.Schema([
          new schema_1.Field("values", values.type),
          new schema_1.Field("counts", counts.type)
        ]);
        super(new recordbatch_1.RecordBatch(schema, counts.length, [values, counts]));
      }
      toJSON() {
        const values = this.getColumnAt(0);
        const counts = this.getColumnAt(1);
        const result = {};
        for (let i = -1; ++i < this.length; ) {
          result[values.get(i)] = counts.get(i);
        }
        return result;
      }
    };
    exports.CountByResult = CountByResult2;
    var FilteredDataFrame2 = class _FilteredDataFrame extends DataFrame2 {
      constructor(batches, predicate2) {
        super(batches);
        this._predicate = predicate2;
      }
      scan(next, bind) {
        const batches = this._chunks;
        const numBatches = batches.length;
        for (let batchIndex = -1; ++batchIndex < numBatches; ) {
          const batch = batches[batchIndex];
          const predicate2 = this._predicate.bind(batch);
          let isBound = false;
          for (let index = -1, numRows = batch.length; ++index < numRows; ) {
            if (predicate2(index, batch)) {
              if (bind && !isBound) {
                bind(batch);
                isBound = true;
              }
              next(index, batch);
            }
          }
        }
      }
      scanReverse(next, bind) {
        const batches = this._chunks;
        const numBatches = batches.length;
        for (let batchIndex = numBatches; --batchIndex >= 0; ) {
          const batch = batches[batchIndex];
          const predicate2 = this._predicate.bind(batch);
          let isBound = false;
          for (let index = batch.length; --index >= 0; ) {
            if (predicate2(index, batch)) {
              if (bind && !isBound) {
                bind(batch);
                isBound = true;
              }
              next(index, batch);
            }
          }
        }
      }
      count() {
        let sum = 0;
        const batches = this._chunks;
        const numBatches = batches.length;
        for (let batchIndex = -1; ++batchIndex < numBatches; ) {
          const batch = batches[batchIndex];
          const predicate2 = this._predicate.bind(batch);
          for (let index = -1, numRows = batch.length; ++index < numRows; ) {
            if (predicate2(index, batch)) {
              ++sum;
            }
          }
        }
        return sum;
      }
      *[Symbol.iterator]() {
        const batches = this._chunks;
        const numBatches = batches.length;
        for (let batchIndex = -1; ++batchIndex < numBatches; ) {
          const batch = batches[batchIndex];
          const predicate2 = this._predicate.bind(batch);
          for (let index = -1, numRows = batch.length; ++index < numRows; ) {
            if (predicate2(index, batch)) {
              yield batch.get(index);
            }
          }
        }
      }
      filter(predicate2) {
        return new _FilteredDataFrame(this._chunks, this._predicate.and(predicate2));
      }
      countBy(name) {
        const batches = this._chunks, numBatches = batches.length;
        const count_by = typeof name === "string" ? new predicate_1.Col(name) : name;
        count_by.bind(batches[numBatches - 1]);
        const vector = count_by.vector;
        if (!type_1.DataType.isDictionary(vector.type)) {
          throw new Error("countBy currently only supports dictionary-encoded columns");
        }
        const countByteLength = Math.ceil(Math.log(vector.length) / Math.log(256));
        const CountsArrayType = countByteLength == 4 ? Uint32Array : countByteLength >= 2 ? Uint16Array : Uint8Array;
        const counts = new CountsArrayType(vector.dictionary.length);
        for (let batchIndex = -1; ++batchIndex < numBatches; ) {
          const batch = batches[batchIndex];
          const predicate2 = this._predicate.bind(batch);
          count_by.bind(batch);
          const keys = count_by.vector.indices;
          for (let index = -1, numRows = batch.length; ++index < numRows; ) {
            let key = keys.get(index);
            if (key !== null && predicate2(index, batch)) {
              counts[key]++;
            }
          }
        }
        return new CountByResult2(vector.dictionary, int_1.IntVector.from(counts));
      }
    };
    exports.FilteredDataFrame = FilteredDataFrame2;
  }
});

// node_modules/apache-arrow/Arrow.js
var require_Arrow = __commonJS({
  "node_modules/apache-arrow/Arrow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var enum_1 = require_enum();
    exports.ArrowType = enum_1.ArrowType;
    exports.DateUnit = enum_1.DateUnit;
    exports.IntervalUnit = enum_1.IntervalUnit;
    exports.MessageHeader = enum_1.MessageHeader;
    exports.MetadataVersion = enum_1.MetadataVersion;
    exports.Precision = enum_1.Precision;
    exports.TimeUnit = enum_1.TimeUnit;
    exports.Type = enum_1.Type;
    exports.UnionMode = enum_1.UnionMode;
    exports.BufferType = enum_1.BufferType;
    var data_1 = require_data();
    exports.Data = data_1.Data;
    var type_1 = require_type();
    exports.DataType = type_1.DataType;
    exports.Null = type_1.Null;
    exports.Bool = type_1.Bool;
    exports.Int = type_1.Int;
    exports.Int8 = type_1.Int8;
    exports.Int16 = type_1.Int16;
    exports.Int32 = type_1.Int32;
    exports.Int64 = type_1.Int64;
    exports.Uint8 = type_1.Uint8;
    exports.Uint16 = type_1.Uint16;
    exports.Uint32 = type_1.Uint32;
    exports.Uint64 = type_1.Uint64;
    exports.Float = type_1.Float;
    exports.Float16 = type_1.Float16;
    exports.Float32 = type_1.Float32;
    exports.Float64 = type_1.Float64;
    exports.Utf8 = type_1.Utf8;
    exports.Binary = type_1.Binary;
    exports.FixedSizeBinary = type_1.FixedSizeBinary;
    exports.Date_ = type_1.Date_;
    exports.DateDay = type_1.DateDay;
    exports.DateMillisecond = type_1.DateMillisecond;
    exports.Timestamp = type_1.Timestamp;
    exports.TimestampSecond = type_1.TimestampSecond;
    exports.TimestampMillisecond = type_1.TimestampMillisecond;
    exports.TimestampMicrosecond = type_1.TimestampMicrosecond;
    exports.TimestampNanosecond = type_1.TimestampNanosecond;
    exports.Time = type_1.Time;
    exports.TimeSecond = type_1.TimeSecond;
    exports.TimeMillisecond = type_1.TimeMillisecond;
    exports.TimeMicrosecond = type_1.TimeMicrosecond;
    exports.TimeNanosecond = type_1.TimeNanosecond;
    exports.Decimal = type_1.Decimal;
    exports.List = type_1.List;
    exports.Struct = type_1.Struct;
    exports.Union = type_1.Union;
    exports.DenseUnion = type_1.DenseUnion;
    exports.SparseUnion = type_1.SparseUnion;
    exports.Dictionary = type_1.Dictionary;
    exports.Interval = type_1.Interval;
    exports.IntervalDayTime = type_1.IntervalDayTime;
    exports.IntervalYearMonth = type_1.IntervalYearMonth;
    exports.FixedSizeList = type_1.FixedSizeList;
    exports.Map_ = type_1.Map_;
    var table_1 = require_table();
    exports.Table = table_1.Table;
    var column_1 = require_column();
    exports.Column = column_1.Column;
    var visitor_1 = require_visitor();
    exports.Visitor = visitor_1.Visitor;
    var schema_1 = require_schema();
    exports.Schema = schema_1.Schema;
    exports.Field = schema_1.Field;
    var index_1 = require_vector3();
    exports.Vector = index_1.Vector;
    exports.BaseVector = index_1.BaseVector;
    exports.BinaryVector = index_1.BinaryVector;
    exports.BoolVector = index_1.BoolVector;
    exports.Chunked = index_1.Chunked;
    exports.DateVector = index_1.DateVector;
    exports.DateDayVector = index_1.DateDayVector;
    exports.DateMillisecondVector = index_1.DateMillisecondVector;
    exports.DecimalVector = index_1.DecimalVector;
    exports.DictionaryVector = index_1.DictionaryVector;
    exports.FixedSizeBinaryVector = index_1.FixedSizeBinaryVector;
    exports.FixedSizeListVector = index_1.FixedSizeListVector;
    exports.FloatVector = index_1.FloatVector;
    exports.Float16Vector = index_1.Float16Vector;
    exports.Float32Vector = index_1.Float32Vector;
    exports.Float64Vector = index_1.Float64Vector;
    exports.IntervalVector = index_1.IntervalVector;
    exports.IntervalDayTimeVector = index_1.IntervalDayTimeVector;
    exports.IntervalYearMonthVector = index_1.IntervalYearMonthVector;
    exports.IntVector = index_1.IntVector;
    exports.Int8Vector = index_1.Int8Vector;
    exports.Int16Vector = index_1.Int16Vector;
    exports.Int32Vector = index_1.Int32Vector;
    exports.Int64Vector = index_1.Int64Vector;
    exports.Uint8Vector = index_1.Uint8Vector;
    exports.Uint16Vector = index_1.Uint16Vector;
    exports.Uint32Vector = index_1.Uint32Vector;
    exports.Uint64Vector = index_1.Uint64Vector;
    exports.ListVector = index_1.ListVector;
    exports.MapVector = index_1.MapVector;
    exports.NullVector = index_1.NullVector;
    exports.StructVector = index_1.StructVector;
    exports.TimestampVector = index_1.TimestampVector;
    exports.TimestampSecondVector = index_1.TimestampSecondVector;
    exports.TimestampMillisecondVector = index_1.TimestampMillisecondVector;
    exports.TimestampMicrosecondVector = index_1.TimestampMicrosecondVector;
    exports.TimestampNanosecondVector = index_1.TimestampNanosecondVector;
    exports.TimeVector = index_1.TimeVector;
    exports.TimeSecondVector = index_1.TimeSecondVector;
    exports.TimeMillisecondVector = index_1.TimeMillisecondVector;
    exports.TimeMicrosecondVector = index_1.TimeMicrosecondVector;
    exports.TimeNanosecondVector = index_1.TimeNanosecondVector;
    exports.UnionVector = index_1.UnionVector;
    exports.DenseUnionVector = index_1.DenseUnionVector;
    exports.SparseUnionVector = index_1.SparseUnionVector;
    exports.Utf8Vector = index_1.Utf8Vector;
    var index_2 = require_builder2();
    exports.Builder = index_2.Builder;
    exports.BinaryBuilder = index_2.BinaryBuilder;
    exports.BoolBuilder = index_2.BoolBuilder;
    exports.DateBuilder = index_2.DateBuilder;
    exports.DateDayBuilder = index_2.DateDayBuilder;
    exports.DateMillisecondBuilder = index_2.DateMillisecondBuilder;
    exports.DecimalBuilder = index_2.DecimalBuilder;
    exports.DictionaryBuilder = index_2.DictionaryBuilder;
    exports.FixedSizeBinaryBuilder = index_2.FixedSizeBinaryBuilder;
    exports.FixedSizeListBuilder = index_2.FixedSizeListBuilder;
    exports.FloatBuilder = index_2.FloatBuilder;
    exports.Float16Builder = index_2.Float16Builder;
    exports.Float32Builder = index_2.Float32Builder;
    exports.Float64Builder = index_2.Float64Builder;
    exports.IntervalBuilder = index_2.IntervalBuilder;
    exports.IntervalDayTimeBuilder = index_2.IntervalDayTimeBuilder;
    exports.IntervalYearMonthBuilder = index_2.IntervalYearMonthBuilder;
    exports.IntBuilder = index_2.IntBuilder;
    exports.Int8Builder = index_2.Int8Builder;
    exports.Int16Builder = index_2.Int16Builder;
    exports.Int32Builder = index_2.Int32Builder;
    exports.Int64Builder = index_2.Int64Builder;
    exports.Uint8Builder = index_2.Uint8Builder;
    exports.Uint16Builder = index_2.Uint16Builder;
    exports.Uint32Builder = index_2.Uint32Builder;
    exports.Uint64Builder = index_2.Uint64Builder;
    exports.ListBuilder = index_2.ListBuilder;
    exports.MapBuilder = index_2.MapBuilder;
    exports.NullBuilder = index_2.NullBuilder;
    exports.StructBuilder = index_2.StructBuilder;
    exports.TimestampBuilder = index_2.TimestampBuilder;
    exports.TimestampSecondBuilder = index_2.TimestampSecondBuilder;
    exports.TimestampMillisecondBuilder = index_2.TimestampMillisecondBuilder;
    exports.TimestampMicrosecondBuilder = index_2.TimestampMicrosecondBuilder;
    exports.TimestampNanosecondBuilder = index_2.TimestampNanosecondBuilder;
    exports.TimeBuilder = index_2.TimeBuilder;
    exports.TimeSecondBuilder = index_2.TimeSecondBuilder;
    exports.TimeMillisecondBuilder = index_2.TimeMillisecondBuilder;
    exports.TimeMicrosecondBuilder = index_2.TimeMicrosecondBuilder;
    exports.TimeNanosecondBuilder = index_2.TimeNanosecondBuilder;
    exports.UnionBuilder = index_2.UnionBuilder;
    exports.DenseUnionBuilder = index_2.DenseUnionBuilder;
    exports.SparseUnionBuilder = index_2.SparseUnionBuilder;
    exports.Utf8Builder = index_2.Utf8Builder;
    var stream_1 = require_stream();
    exports.ByteStream = stream_1.ByteStream;
    exports.AsyncByteStream = stream_1.AsyncByteStream;
    exports.AsyncByteQueue = stream_1.AsyncByteQueue;
    var reader_1 = require_reader();
    exports.RecordBatchReader = reader_1.RecordBatchReader;
    exports.RecordBatchFileReader = reader_1.RecordBatchFileReader;
    exports.RecordBatchStreamReader = reader_1.RecordBatchStreamReader;
    exports.AsyncRecordBatchFileReader = reader_1.AsyncRecordBatchFileReader;
    exports.AsyncRecordBatchStreamReader = reader_1.AsyncRecordBatchStreamReader;
    var writer_1 = require_writer();
    exports.RecordBatchWriter = writer_1.RecordBatchWriter;
    exports.RecordBatchFileWriter = writer_1.RecordBatchFileWriter;
    exports.RecordBatchStreamWriter = writer_1.RecordBatchStreamWriter;
    exports.RecordBatchJSONWriter = writer_1.RecordBatchJSONWriter;
    var message_1 = require_message2();
    exports.MessageReader = message_1.MessageReader;
    exports.AsyncMessageReader = message_1.AsyncMessageReader;
    exports.JSONMessageReader = message_1.JSONMessageReader;
    var message_2 = require_message();
    exports.Message = message_2.Message;
    var recordbatch_1 = require_recordbatch2();
    exports.RecordBatch = recordbatch_1.RecordBatch;
    var dataframe_1 = require_dataframe();
    exports.DataFrame = dataframe_1.DataFrame;
    exports.FilteredDataFrame = dataframe_1.FilteredDataFrame;
    exports.CountByResult = dataframe_1.CountByResult;
    var util_bn_ = require_bn();
    var util_int_ = require_int2();
    var util_bit_ = require_bit();
    var util_math_ = require_math();
    var util_buffer_ = require_buffer();
    var util_vector_ = require_vector2();
    var predicate2 = require_predicate();
    exports.predicate = predicate2;
    exports.util = {
      ...util_bn_,
      ...util_int_,
      ...util_bit_,
      ...util_math_,
      ...util_buffer_,
      ...util_vector_
    };
  }
});

// node_modules/streamlit-component-lib/dist/StreamlitReact.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var import_react = __toESM(require_react());

// node_modules/event-target-shim/dist/event-target-shim.mjs
var privateData = /* @__PURE__ */ new WeakMap();
var wrappers = /* @__PURE__ */ new WeakMap();
function pd(event) {
  const retv = privateData.get(event);
  console.assert(
    retv != null,
    "'this' is expected an Event object, but got",
    event
  );
  return retv;
}
function setCancelFlag(data) {
  if (data.passiveListener != null) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "Unable to preventDefault inside passive event listener invocation.",
        data.passiveListener
      );
    }
    return;
  }
  if (!data.event.cancelable) {
    return;
  }
  data.canceled = true;
  if (typeof data.event.preventDefault === "function") {
    data.event.preventDefault();
  }
}
function Event(eventTarget, event) {
  privateData.set(this, {
    eventTarget,
    event,
    eventPhase: 2,
    currentTarget: eventTarget,
    canceled: false,
    stopped: false,
    immediateStopped: false,
    passiveListener: null,
    timeStamp: event.timeStamp || Date.now()
  });
  Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
  const keys = Object.keys(event);
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (!(key in this)) {
      Object.defineProperty(this, key, defineRedirectDescriptor(key));
    }
  }
}
Event.prototype = {
  /**
   * The type of this event.
   * @type {string}
   */
  get type() {
    return pd(this).event.type;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   */
  get target() {
    return pd(this).eventTarget;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   */
  get currentTarget() {
    return pd(this).currentTarget;
  },
  /**
   * @returns {EventTarget[]} The composed path of this event.
   */
  composedPath() {
    const currentTarget = pd(this).currentTarget;
    if (currentTarget == null) {
      return [];
    }
    return [currentTarget];
  },
  /**
   * Constant of NONE.
   * @type {number}
   */
  get NONE() {
    return 0;
  },
  /**
   * Constant of CAPTURING_PHASE.
   * @type {number}
   */
  get CAPTURING_PHASE() {
    return 1;
  },
  /**
   * Constant of AT_TARGET.
   * @type {number}
   */
  get AT_TARGET() {
    return 2;
  },
  /**
   * Constant of BUBBLING_PHASE.
   * @type {number}
   */
  get BUBBLING_PHASE() {
    return 3;
  },
  /**
   * The target of this event.
   * @type {number}
   */
  get eventPhase() {
    return pd(this).eventPhase;
  },
  /**
   * Stop event bubbling.
   * @returns {void}
   */
  stopPropagation() {
    const data = pd(this);
    data.stopped = true;
    if (typeof data.event.stopPropagation === "function") {
      data.event.stopPropagation();
    }
  },
  /**
   * Stop event bubbling.
   * @returns {void}
   */
  stopImmediatePropagation() {
    const data = pd(this);
    data.stopped = true;
    data.immediateStopped = true;
    if (typeof data.event.stopImmediatePropagation === "function") {
      data.event.stopImmediatePropagation();
    }
  },
  /**
   * The flag to be bubbling.
   * @type {boolean}
   */
  get bubbles() {
    return Boolean(pd(this).event.bubbles);
  },
  /**
   * The flag to be cancelable.
   * @type {boolean}
   */
  get cancelable() {
    return Boolean(pd(this).event.cancelable);
  },
  /**
   * Cancel this event.
   * @returns {void}
   */
  preventDefault() {
    setCancelFlag(pd(this));
  },
  /**
   * The flag to indicate cancellation state.
   * @type {boolean}
   */
  get defaultPrevented() {
    return pd(this).canceled;
  },
  /**
   * The flag to be composed.
   * @type {boolean}
   */
  get composed() {
    return Boolean(pd(this).event.composed);
  },
  /**
   * The unix time of this event.
   * @type {number}
   */
  get timeStamp() {
    return pd(this).timeStamp;
  },
  /**
   * The target of this event.
   * @type {EventTarget}
   * @deprecated
   */
  get srcElement() {
    return pd(this).eventTarget;
  },
  /**
   * The flag to stop event bubbling.
   * @type {boolean}
   * @deprecated
   */
  get cancelBubble() {
    return pd(this).stopped;
  },
  set cancelBubble(value) {
    if (!value) {
      return;
    }
    const data = pd(this);
    data.stopped = true;
    if (typeof data.event.cancelBubble === "boolean") {
      data.event.cancelBubble = true;
    }
  },
  /**
   * The flag to indicate cancellation state.
   * @type {boolean}
   * @deprecated
   */
  get returnValue() {
    return !pd(this).canceled;
  },
  set returnValue(value) {
    if (!value) {
      setCancelFlag(pd(this));
    }
  },
  /**
   * Initialize this event object. But do nothing under event dispatching.
   * @param {string} type The event type.
   * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
   * @param {boolean} [cancelable=false] The flag to be possible to cancel.
   * @deprecated
   */
  initEvent() {
  }
};
Object.defineProperty(Event.prototype, "constructor", {
  value: Event,
  configurable: true,
  writable: true
});
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
  Object.setPrototypeOf(Event.prototype, window.Event.prototype);
  wrappers.set(window.Event.prototype, Event);
}
function defineRedirectDescriptor(key) {
  return {
    get() {
      return pd(this).event[key];
    },
    set(value) {
      pd(this).event[key] = value;
    },
    configurable: true,
    enumerable: true
  };
}
function defineCallDescriptor(key) {
  return {
    value() {
      const event = pd(this).event;
      return event[key].apply(event, arguments);
    },
    configurable: true,
    enumerable: true
  };
}
function defineWrapper(BaseEvent, proto) {
  const keys = Object.keys(proto);
  if (keys.length === 0) {
    return BaseEvent;
  }
  function CustomEvent2(eventTarget, event) {
    BaseEvent.call(this, eventTarget, event);
  }
  CustomEvent2.prototype = Object.create(BaseEvent.prototype, {
    constructor: { value: CustomEvent2, configurable: true, writable: true }
  });
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (!(key in BaseEvent.prototype)) {
      const descriptor = Object.getOwnPropertyDescriptor(proto, key);
      const isFunc = typeof descriptor.value === "function";
      Object.defineProperty(
        CustomEvent2.prototype,
        key,
        isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
      );
    }
  }
  return CustomEvent2;
}
function getWrapper(proto) {
  if (proto == null || proto === Object.prototype) {
    return Event;
  }
  let wrapper = wrappers.get(proto);
  if (wrapper == null) {
    wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
    wrappers.set(proto, wrapper);
  }
  return wrapper;
}
function wrapEvent(eventTarget, event) {
  const Wrapper = getWrapper(Object.getPrototypeOf(event));
  return new Wrapper(eventTarget, event);
}
function isStopped(event) {
  return pd(event).immediateStopped;
}
function setEventPhase(event, eventPhase) {
  pd(event).eventPhase = eventPhase;
}
function setCurrentTarget(event, currentTarget) {
  pd(event).currentTarget = currentTarget;
}
function setPassiveListener(event, passiveListener) {
  pd(event).passiveListener = passiveListener;
}
var listenersMap = /* @__PURE__ */ new WeakMap();
var CAPTURE = 1;
var BUBBLE = 2;
var ATTRIBUTE = 3;
function isObject(x) {
  return x !== null && typeof x === "object";
}
function getListeners(eventTarget) {
  const listeners = listenersMap.get(eventTarget);
  if (listeners == null) {
    throw new TypeError(
      "'this' is expected an EventTarget object, but got another value."
    );
  }
  return listeners;
}
function defineEventAttributeDescriptor(eventName) {
  return {
    get() {
      const listeners = getListeners(this);
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listenerType === ATTRIBUTE) {
          return node.listener;
        }
        node = node.next;
      }
      return null;
    },
    set(listener) {
      if (typeof listener !== "function" && !isObject(listener)) {
        listener = null;
      }
      const listeners = getListeners(this);
      let prev = null;
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listenerType === ATTRIBUTE) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
        } else {
          prev = node;
        }
        node = node.next;
      }
      if (listener !== null) {
        const newNode = {
          listener,
          listenerType: ATTRIBUTE,
          passive: false,
          once: false,
          next: null
        };
        if (prev === null) {
          listeners.set(eventName, newNode);
        } else {
          prev.next = newNode;
        }
      }
    },
    configurable: true,
    enumerable: true
  };
}
function defineEventAttribute(eventTargetPrototype, eventName) {
  Object.defineProperty(
    eventTargetPrototype,
    `on${eventName}`,
    defineEventAttributeDescriptor(eventName)
  );
}
function defineCustomEventTarget(eventNames) {
  function CustomEventTarget() {
    EventTarget.call(this);
  }
  CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
    constructor: {
      value: CustomEventTarget,
      configurable: true,
      writable: true
    }
  });
  for (let i = 0; i < eventNames.length; ++i) {
    defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
  }
  return CustomEventTarget;
}
function EventTarget() {
  if (this instanceof EventTarget) {
    listenersMap.set(this, /* @__PURE__ */ new Map());
    return;
  }
  if (arguments.length === 1 && Array.isArray(arguments[0])) {
    return defineCustomEventTarget(arguments[0]);
  }
  if (arguments.length > 0) {
    const types = new Array(arguments.length);
    for (let i = 0; i < arguments.length; ++i) {
      types[i] = arguments[i];
    }
    return defineCustomEventTarget(types);
  }
  throw new TypeError("Cannot call a class as a function");
}
EventTarget.prototype = {
  /**
   * Add a given listener to this event target.
   * @param {string} eventName The event name to add.
   * @param {Function} listener The listener to add.
   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
   * @returns {void}
   */
  addEventListener(eventName, listener, options) {
    if (listener == null) {
      return;
    }
    if (typeof listener !== "function" && !isObject(listener)) {
      throw new TypeError("'listener' should be a function or an object.");
    }
    const listeners = getListeners(this);
    const optionsIsObj = isObject(options);
    const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
    const listenerType = capture ? CAPTURE : BUBBLE;
    const newNode = {
      listener,
      listenerType,
      passive: optionsIsObj && Boolean(options.passive),
      once: optionsIsObj && Boolean(options.once),
      next: null
    };
    let node = listeners.get(eventName);
    if (node === void 0) {
      listeners.set(eventName, newNode);
      return;
    }
    let prev = null;
    while (node != null) {
      if (node.listener === listener && node.listenerType === listenerType) {
        return;
      }
      prev = node;
      node = node.next;
    }
    prev.next = newNode;
  },
  /**
   * Remove a given listener from this event target.
   * @param {string} eventName The event name to remove.
   * @param {Function} listener The listener to remove.
   * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
   * @returns {void}
   */
  removeEventListener(eventName, listener, options) {
    if (listener == null) {
      return;
    }
    const listeners = getListeners(this);
    const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
    const listenerType = capture ? CAPTURE : BUBBLE;
    let prev = null;
    let node = listeners.get(eventName);
    while (node != null) {
      if (node.listener === listener && node.listenerType === listenerType) {
        if (prev !== null) {
          prev.next = node.next;
        } else if (node.next !== null) {
          listeners.set(eventName, node.next);
        } else {
          listeners.delete(eventName);
        }
        return;
      }
      prev = node;
      node = node.next;
    }
  },
  /**
   * Dispatch a given event.
   * @param {Event|{type:string}} event The event to dispatch.
   * @returns {boolean} `false` if canceled.
   */
  dispatchEvent(event) {
    if (event == null || typeof event.type !== "string") {
      throw new TypeError('"event.type" should be a string.');
    }
    const listeners = getListeners(this);
    const eventName = event.type;
    let node = listeners.get(eventName);
    if (node == null) {
      return true;
    }
    const wrappedEvent = wrapEvent(this, event);
    let prev = null;
    while (node != null) {
      if (node.once) {
        if (prev !== null) {
          prev.next = node.next;
        } else if (node.next !== null) {
          listeners.set(eventName, node.next);
        } else {
          listeners.delete(eventName);
        }
      } else {
        prev = node;
      }
      setPassiveListener(
        wrappedEvent,
        node.passive ? node.listener : null
      );
      if (typeof node.listener === "function") {
        try {
          node.listener.call(this, wrappedEvent);
        } catch (err) {
          if (typeof console !== "undefined" && typeof console.error === "function") {
            console.error(err);
          }
        }
      } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
        node.listener.handleEvent(wrappedEvent);
      }
      if (isStopped(wrappedEvent)) {
        break;
      }
      node = node.next;
    }
    setPassiveListener(wrappedEvent, null);
    setEventPhase(wrappedEvent, 0);
    setCurrentTarget(wrappedEvent, null);
    return !wrappedEvent.defaultPrevented;
  }
};
Object.defineProperty(EventTarget.prototype, "constructor", {
  value: EventTarget,
  configurable: true,
  writable: true
});
if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
  Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}

// node_modules/apache-arrow/Arrow.dom.mjs
var import_adapters = __toESM(require_adapters(), 1);
var import_builder = __toESM(require_builder2(), 1);
var import_reader = __toESM(require_reader(), 1);
var import_writer = __toESM(require_writer(), 1);
var import_iterable = __toESM(require_iterable(), 1);
var import_builder2 = __toESM(require_builder3(), 1);
var import_reader2 = __toESM(require_reader2(), 1);
var import_writer2 = __toESM(require_writer2(), 1);
var import_Arrow = __toESM(require_Arrow(), 1);
import_adapters.default.toDOMStream = import_iterable.toDOMStream;
import_builder.Builder["throughDOM"] = import_builder2.builderThroughDOMStream;
import_reader.RecordBatchReader["throughDOM"] = import_reader2.recordBatchReaderThroughDOMStream;
import_writer.RecordBatchWriter["throughDOM"] = import_writer2.recordBatchWriterThroughDOMStream;

// node_modules/streamlit-component-lib/dist/ArrowTable.js
var ArrowTable = (
  /** @class */
  function() {
    function ArrowTable2(dataBuffer, indexBuffer, columnsBuffer, styler) {
      var _this = this;
      this.getCell = function(rowIndex, columnIndex) {
        var isBlankCell = rowIndex < _this.headerRows && columnIndex < _this.headerColumns;
        var isIndexCell = rowIndex >= _this.headerRows && columnIndex < _this.headerColumns;
        var isColumnsCell = rowIndex < _this.headerRows && columnIndex >= _this.headerColumns;
        if (isBlankCell) {
          var classNames = ["blank"];
          if (columnIndex > 0) {
            classNames.push("level" + rowIndex);
          }
          return {
            type: "blank",
            classNames: classNames.join(" "),
            content: ""
          };
        } else if (isColumnsCell) {
          var dataColumnIndex = columnIndex - _this.headerColumns;
          var classNames = [
            "col_heading",
            "level" + rowIndex,
            "col" + dataColumnIndex
          ];
          return {
            type: "columns",
            classNames: classNames.join(" "),
            content: _this.getContent(_this.columnsTable, dataColumnIndex, rowIndex)
          };
        } else if (isIndexCell) {
          var dataRowIndex = rowIndex - _this.headerRows;
          var classNames = [
            "row_heading",
            "level" + columnIndex,
            "row" + dataRowIndex
          ];
          return {
            type: "index",
            id: "T_" + _this.uuid + "level" + columnIndex + "_row" + dataRowIndex,
            classNames: classNames.join(" "),
            content: _this.getContent(_this.indexTable, dataRowIndex, columnIndex)
          };
        } else {
          var dataRowIndex = rowIndex - _this.headerRows;
          var dataColumnIndex = columnIndex - _this.headerColumns;
          var classNames = [
            "data",
            "row" + dataRowIndex,
            "col" + dataColumnIndex
          ];
          var content = _this.styler ? _this.getContent(_this.styler.displayValuesTable, dataRowIndex, dataColumnIndex) : _this.getContent(_this.dataTable, dataRowIndex, dataColumnIndex);
          return {
            type: "data",
            id: "T_" + _this.uuid + "row" + dataRowIndex + "_col" + dataColumnIndex,
            classNames: classNames.join(" "),
            content
          };
        }
      };
      this.getContent = function(table, rowIndex, columnIndex) {
        var column = table.getColumnAt(columnIndex);
        if (column === null) {
          return "";
        }
        var columnTypeId = _this.getColumnTypeId(table, columnIndex);
        switch (columnTypeId) {
          case import_Arrow.Type.Timestamp: {
            return _this.nanosToDate(column.get(rowIndex));
          }
          default: {
            return column.get(rowIndex);
          }
        }
      };
      this.dataTable = import_Arrow.Table.from(dataBuffer);
      this.indexTable = import_Arrow.Table.from(indexBuffer);
      this.columnsTable = import_Arrow.Table.from(columnsBuffer);
      this.styler = styler ? {
        caption: styler.caption,
        displayValuesTable: import_Arrow.Table.from(styler.displayValues),
        styles: styler.styles,
        uuid: styler.uuid
      } : void 0;
    }
    Object.defineProperty(ArrowTable2.prototype, "rows", {
      get: function() {
        return this.indexTable.length + this.columnsTable.numCols;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArrowTable2.prototype, "columns", {
      get: function() {
        return this.indexTable.numCols + this.columnsTable.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArrowTable2.prototype, "headerRows", {
      get: function() {
        return this.rows - this.dataRows;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArrowTable2.prototype, "headerColumns", {
      get: function() {
        return this.columns - this.dataColumns;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArrowTable2.prototype, "dataRows", {
      get: function() {
        return this.dataTable.length;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArrowTable2.prototype, "dataColumns", {
      get: function() {
        return this.dataTable.numCols;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArrowTable2.prototype, "uuid", {
      get: function() {
        return this.styler && this.styler.uuid;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArrowTable2.prototype, "caption", {
      get: function() {
        return this.styler && this.styler.caption;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArrowTable2.prototype, "styles", {
      get: function() {
        return this.styler && this.styler.styles;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArrowTable2.prototype, "table", {
      get: function() {
        return this.dataTable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArrowTable2.prototype, "index", {
      get: function() {
        return this.indexTable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(ArrowTable2.prototype, "columnTable", {
      get: function() {
        return this.columnsTable;
      },
      enumerable: true,
      configurable: true
    });
    ArrowTable2.prototype.serialize = function() {
      return {
        data: this.dataTable.serialize(),
        index: this.indexTable.serialize(),
        columns: this.columnsTable.serialize()
      };
    };
    ArrowTable2.prototype.getColumnTypeId = function(table, columnIndex) {
      return table.schema.fields[columnIndex].type.typeId;
    };
    ArrowTable2.prototype.nanosToDate = function(nanos) {
      return new Date(nanos / 1e6);
    };
    return ArrowTable2;
  }()
);

// node_modules/streamlit-component-lib/dist/streamlit.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var ComponentMessageType;
(function(ComponentMessageType2) {
  ComponentMessageType2["COMPONENT_READY"] = "streamlit:componentReady";
  ComponentMessageType2["SET_COMPONENT_VALUE"] = "streamlit:setComponentValue";
  ComponentMessageType2["SET_FRAME_HEIGHT"] = "streamlit:setFrameHeight";
})(ComponentMessageType || (ComponentMessageType = {}));
var Streamlit = (
  /** @class */
  function() {
    function Streamlit2() {
    }
    Streamlit2.API_VERSION = 1;
    Streamlit2.RENDER_EVENT = "streamlit:render";
    Streamlit2.events = new EventTarget();
    Streamlit2.registeredMessageListener = false;
    Streamlit2.setComponentReady = function() {
      if (!Streamlit2.registeredMessageListener) {
        window.addEventListener("message", Streamlit2.onMessageEvent);
        Streamlit2.registeredMessageListener = true;
      }
      Streamlit2.sendBackMsg(ComponentMessageType.COMPONENT_READY, {
        apiVersion: Streamlit2.API_VERSION
      });
    };
    Streamlit2.setFrameHeight = function(height) {
      if (height === void 0) {
        height = document.body.scrollHeight;
      }
      if (height === Streamlit2.lastFrameHeight) {
        return;
      }
      Streamlit2.lastFrameHeight = height;
      Streamlit2.sendBackMsg(ComponentMessageType.SET_FRAME_HEIGHT, { height });
    };
    Streamlit2.setComponentValue = function(value) {
      var dataType;
      if (value instanceof ArrowTable) {
        dataType = "dataframe";
        value = value.serialize();
      } else if (isTypedArray(value)) {
        dataType = "bytes";
        value = new Uint8Array(value.buffer);
      } else if (value instanceof ArrayBuffer) {
        dataType = "bytes";
        value = new Uint8Array(value);
      } else {
        dataType = "json";
      }
      Streamlit2.sendBackMsg(ComponentMessageType.SET_COMPONENT_VALUE, {
        value,
        dataType
      });
    };
    Streamlit2.onMessageEvent = function(event) {
      var type = event.data["type"];
      switch (type) {
        case Streamlit2.RENDER_EVENT:
          Streamlit2.onRenderMessage(event.data);
          break;
      }
    };
    Streamlit2.onRenderMessage = function(data) {
      var args = data["args"];
      if (args == null) {
        console.error("Got null args in onRenderMessage. This should never happen");
        args = {};
      }
      var dataframeArgs = data["dfs"] && data["dfs"].length > 0 ? Streamlit2.argsDataframeToObject(data["dfs"]) : {};
      args = __assign(__assign({}, args), dataframeArgs);
      var disabled = Boolean(data["disabled"]);
      var theme = data["theme"];
      if (theme) {
        _injectTheme(theme);
      }
      var eventData = { disabled, args, theme };
      var event = new CustomEvent(Streamlit2.RENDER_EVENT, {
        detail: eventData
      });
      Streamlit2.events.dispatchEvent(event);
    };
    Streamlit2.argsDataframeToObject = function(argsDataframe) {
      var argsDataframeArrow = argsDataframe.map(function(_a) {
        var key = _a.key, value = _a.value;
        return [key, Streamlit2.toArrowTable(value)];
      });
      return Object.fromEntries(argsDataframeArrow);
    };
    Streamlit2.toArrowTable = function(df) {
      var _a = df.data, data = _a.data, index = _a.index, columns = _a.columns, styler = _a.styler;
      return new ArrowTable(data, index, columns, styler);
    };
    Streamlit2.sendBackMsg = function(type, data) {
      window.parent.postMessage(__assign({ isStreamlitMessage: true, type }, data), "*");
    };
    return Streamlit2;
  }()
);
var _injectTheme = function(theme) {
  var style = document.createElement("style");
  document.head.appendChild(style);
  style.innerHTML = "\n    :root {\n      --primary-color: " + theme.primaryColor + ";\n      --background-color: " + theme.backgroundColor + ";\n      --secondary-background-color: " + theme.secondaryBackgroundColor + ";\n      --text-color: " + theme.textColor + ";\n      --font: " + theme.font + ";\n    }\n\n    body {\n      background-color: var(--background-color);\n      color: var(--text-color);\n    }\n  ";
};
function isTypedArray(value) {
  var isBigIntArray = false;
  try {
    isBigIntArray = value instanceof BigInt64Array || value instanceof BigUint64Array;
  } catch (e) {
  }
  return value instanceof Int8Array || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int16Array || value instanceof Uint16Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Float32Array || value instanceof Float64Array || isBigIntArray;
}

// node_modules/streamlit-component-lib/dist/StreamlitReact.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StreamlitComponentBase = (
  /** @class */
  function(_super) {
    __extends(StreamlitComponentBase2, _super);
    function StreamlitComponentBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    StreamlitComponentBase2.prototype.componentDidMount = function() {
      Streamlit.setFrameHeight();
    };
    StreamlitComponentBase2.prototype.componentDidUpdate = function() {
      Streamlit.setFrameHeight();
    };
    return StreamlitComponentBase2;
  }(import_react.default.PureComponent)
);
function withStreamlitConnection(WrappedComponent) {
  var ComponentWrapper = (
    /** @class */
    function(_super) {
      __extends(ComponentWrapper2, _super);
      function ComponentWrapper2(props) {
        var _this = _super.call(this, props) || this;
        _this.componentDidMount = function() {
          Streamlit.events.addEventListener(Streamlit.RENDER_EVENT, _this.onRenderEvent);
          Streamlit.setComponentReady();
        };
        _this.componentDidUpdate = function() {
          if (_this.state.componentError != null) {
            Streamlit.setFrameHeight();
          }
        };
        _this.componentWillUnmount = function() {
          Streamlit.events.removeEventListener(Streamlit.RENDER_EVENT, _this.onRenderEvent);
        };
        _this.onRenderEvent = function(event) {
          var renderEvent = event;
          _this.setState({ renderData: renderEvent.detail });
        };
        _this.render = function() {
          if (_this.state.componentError != null) {
            return import_react.default.createElement(
              "div",
              null,
              import_react.default.createElement("h1", null, "Component Error"),
              import_react.default.createElement("span", null, _this.state.componentError.message)
            );
          }
          if (_this.state.renderData == null) {
            return null;
          }
          return import_react.default.createElement(WrappedComponent, { width: window.innerWidth, disabled: _this.state.renderData.disabled, args: _this.state.renderData.args, theme: _this.state.renderData.theme });
        };
        _this.state = {
          renderData: void 0,
          componentError: void 0
        };
        return _this;
      }
      ComponentWrapper2.getDerivedStateFromError = function(error) {
        return { componentError: error };
      };
      return ComponentWrapper2;
    }(import_react.default.PureComponent)
  );
  return (0, import_hoist_non_react_statics.default)(ComponentWrapper, WrappedComponent);
}
export {
  ArrowTable,
  Streamlit,
  StreamlitComponentBase,
  withStreamlitConnection
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

react/cjs/react.development.js:
  (** @license React v16.14.0
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

streamlit-component-lib/dist/ArrowTable.js:
  (**
   * @license
   * Copyright 2018-2021 Streamlit Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *    http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

streamlit-component-lib/dist/streamlit.js:
  (**
   * @license
   * Copyright 2018-2021 Streamlit Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *    http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

streamlit-component-lib/dist/StreamlitReact.js:
  (**
   * @license
   * Copyright 2018-2021 Streamlit Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *    http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

streamlit-component-lib/dist/index.js:
  (**
   * @license
   * Copyright 2018-2021 Streamlit Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *    http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=streamlit-component-lib.js.map
